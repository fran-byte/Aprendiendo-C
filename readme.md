# <img src="images/C_Logo.png"/> Programando en C - Material did√°ctico




---

### üîë **Palabras clave y fundamentos**

<table style="border: none; width: 100%;">
  <tr>
    <td><strong>Tema</strong></td>
    <td><strong>Subtemas</strong></td>
  </tr>
  <tr>
    <td><a href="https://github.com/fran-byte/Learn-C/blob/main/readme.md#0-lista-de-palabras-reservadas-en-c-est%C3%A1ndar-ansi-c--iso-c" style="text-decoration: none;">0. Palabras reservadas en C</a></td>
    <td>-</td>
  </tr>
</table>

---

### üì¶ **Variables y Tipos de Datos**

<table style="border: none; width: 100%;">
  <tr>
    <td><strong>Tema</strong></td>
    <td><strong>Subtemas</strong></td>
  </tr>
  <tr>
    <td><a href="#1--identificadores-tipos-de-datos-variables" style="text-decoration: none;">1. Identificadores, Tipos de Datos, Variables</a></td>
    <td>
      <a href="#11---tipos-de-datos" style="text-decoration: none;">1.1. Tipos de Datos</a><br>
      <a href="#12--declaraci√≥n-de-variables-y-alcance" style="text-decoration: none;">1.2. Declaraci√≥n de Variables y Alcance</a><br>
      <a href="#13--especificadores-de-almacenamiento-de-los-tipos-de-datos" style="text-decoration: none;">1.3. Especificadores de Almacenamiento</a><br>
      <a href="#14--constantes" style="text-decoration: none;">1.4. Constantes</a>
    </td>
  </tr>
</table>

---

### ‚ûï **Operadores**

<table style="border: none; width: 100%;">
  <tr>
    <td><strong>Tema</strong></td>
    <td><strong>Subtemas</strong></td>
  </tr>
  <tr>
    <td><a href="#2---operadores-aritm%C3%A9ticos-relaci%C3%B3nales-y-l%C3%B3gicos-operador-asignaci%C3%B3n-operador-sizeof-y-operadores-avanzados-operadores-sobre-bits-y-operador-" style="text-decoration: none;">2. Operadores</a></td>
    <td>
      <a href="#21--operadores-aritm%C3%A9ticos" style="text-decoration: none;">2.1. Operadores Aritm√©ticos</a><br>
      <a href="#22--operadores-relaci%C3%B3nales-y-l%C3%B3gicos" style="text-decoration: none;">2.2. Operadores Relacionales y L√≥gicos</a><br>
      <a href="#23--operador-asignaci%C3%B3n" style="text-decoration: none;">2.3. Operador Asignaci√≥n</a><br>
      <a href="#24--operador-sizeof" style="text-decoration: none;">2.4. Operador sizeof</a><br>
      <a href="#25--operadores-sobre-bits" style="text-decoration: none;">2.5. Operadores sobre Bits</a><br>
      <a href="#26--el-operador-" style="text-decoration: none;">2.6. Operador Ternario</a>
    </td>
  </tr>
</table>

---

### üîÅ **Conversi√≥n de Tipos**

<table style="border: none; width: 100%;">
  <tr>
    <td><strong>Tema</strong></td>
    <td><strong>Subtemas</strong></td>
  </tr>
  <tr>
    <td><a href="#3---conversi%C3%B3n-de-tipos-de-datos" style="text-decoration: none;">3. Conversi√≥n de Tipos de Datos</a></td>
    <td>
      <a href="#31--conversi%C3%B3n-autom%C3%A1tica-de-tipos-de-datos" style="text-decoration: none;">3.1. Conversi√≥n Autom√°tica</a><br>
      <a href="#32--conversi%C3%B3n-forzada-de-tipos-datos" style="text-decoration: none;">3.2. Conversi√≥n Forzada</a>
    </td>
  </tr>
</table>

---

### üß© **Control de Flujo**

<table style="border: none; width: 100%;">
  <tr>
    <td><strong>Tema</strong></td>
    <td><strong>Subtemas</strong></td>
  </tr>
  <tr>
    <td><a href="#4---sentencias-de-control-y-bucles" style="text-decoration: none;">4. Sentencias de Control y Bucles</a></td>
    <td>
      <a href="#41--sentencia-de-control-if" style="text-decoration: none;">4.1. Sentencia if</a><br>
      <a href="#52-sentencia-switch" style="text-decoration: none;">4.2. Sentencia switch</a><br>
      <a href="#53-bucle-for" style="text-decoration: none;">4.3. Bucle for</a><br>
      <a href="#54-bucle-while" style="text-decoration: none;">4.4. Bucle while</a><br>
      <a href="#55-bucle-dowhile" style="text-decoration: none;">4.5. Bucle do/while</a><br>
      <a href="#56-sentencias-break-y-continue" style="text-decoration: none;">4.6. Sentencias break y continue</a>
    </td>
  </tr>
</table>

---

### üßµ **Arrays, Cadenas y Punteros**

<table style="border: none; width: 100%;">
  <tr>
    <td><strong>Tema</strong></td>
    <td><strong>Subtemas</strong></td>
  </tr>
  <tr>
    <td><a href="#6-arrays-cadenas-y-punteros" style="text-decoration: none;">5. Arrays, Cadenas y Punteros</a></td>
    <td>
      <a href="#61-arrays-y-cadenas" style="text-decoration: none;">5.1. Arrays y Cadenas</a><br>
      <a href="#62-punteros" style="text-decoration: none;">5.2. Punteros</a>
    </td>
  </tr>
</table>

---

### üõ†Ô∏è **Funciones**

<table style="border: none; width: 100%;">
  <tr>
    <td><strong>Tema</strong></td>
    <td><strong>Subtemas</strong></td>
  </tr>
  <tr>
    <td><a href="#7-funciones" style="text-decoration: none;">6. Funciones</a></td>
    <td>
      <a href="#71-sentencia-return" style="text-decoration: none;">6.1. Sentencia return</a><br>
      <a href="#72-argumentos-de-funciones" style="text-decoration: none;">6.2. Argumentos de Funciones</a><br>
      <a href="#73-arrays-como-argumentos" style="text-decoration: none;">6.3. Arrays como Argumentos</a><br>
      <a href="#74-argumentos-de-main" style="text-decoration: none;">6.4. Argumentos de main()</a><br>
      <a href="#75-recursividad" style="text-decoration: none;">6.5. Recursividad</a><br>
      <a href="#76-punteros-a-funciones" style="text-decoration: none;">6.6. Punteros a Funciones</a><br>
      <a href="#77-static-en-funciones" style="text-decoration: none;">6.7. static en Funciones</a>
    </td>
  </tr>
</table>

---

### üß± **Estructuras y Tipos Compuestos**

<table style="border: none; width: 100%;">
  <tr>
    <td><strong>Tema</strong></td>
    <td><strong>Subtemas</strong></td>
  </tr>
  <tr>
    <td><a href="#8-estructuras-campos-de-bit-uniones-y-enumeraciones" style="text-decoration: none;">7. Estructuras, Campos de Bit, Uniones y Enumeraciones</a></td>
    <td>
      <a href="#81-estructuras" style="text-decoration: none;">7.1. Estructuras</a><br>
      <a href="#82-campos-de-bit" style="text-decoration: none;">7.2. Campos de Bit</a><br>
      <a href="#83-uniones" style="text-decoration: none;">7.3. Uniones</a><br>
      <a href="#84-enumeraciones" style="text-decoration: none;">7.4. Enumeraciones</a><br>
      <a href="#85-typedef" style="text-decoration: none;">7.5. typedef</a>
    </td>
  </tr>
</table>

---

### ‚öôÔ∏è **Preprocesador**

<table style="border: none; width: 100%;">
  <tr>
    <td><strong>Tema</strong></td>
    <td><strong>Subtemas</strong></td>
  </tr>
  <tr>
    <td><a href="#9-el-preprocesador" style="text-decoration: none;">8. El Preprocesador</a></td>
    <td>
      <a href="#91-directiva-define" style="text-decoration: none;">8.1. Directiva #define</a><br>
      <a href="#92-directiva-undef" style="text-decoration: none;">8.2. Directiva #undef</a><br>
      <a href="#93-directiva-error" style="text-decoration: none;">8.3. Directiva #error</a><br>
      <a href="#94-directiva-include" style="text-decoration: none;">8.4. Directiva #include</a><br>
      <a href="#95-directivas-condicionales" style="text-decoration: none;">8.5. Directivas Condicionales</a><br>
      <a href="#96-directiva-line" style="text-decoration: none;">8.6. Directiva #line</a><br>
      <a href="#97-directiva-pragma" style="text-decoration: none;">8.7. Directiva #pragma</a>
    </td>
  </tr>
</table>

---

### üì• **Entrada y Salida**

<table style="border: none; width: 100%;">
  <tr>
    <td><strong>Tema</strong></td>
    <td><strong>Subtemas</strong></td>
  </tr>
  <tr>
    <td><a href="#10-entrada-y-salida" style="text-decoration: none;">9. Entrada y Salida</a></td>
    <td>
      <a href="#101-entradasalida-desde-consola" style="text-decoration: none;">9.1. Entrada/Salida desde Consola</a><br>
      <a href="#102-entradasalida-desde-fichero" style="text-decoration: none;">9.2. Entrada/Salida desde Fichero</a>
    </td>
  </tr>
</table>

---

### üß† **Memoria Din√°mica**

<table style="border: none; width: 100%;">
  <tr>
    <td><strong>Tema</strong></td>
    <td><strong>Subtemas</strong></td>
  </tr>
  <tr>
    <td><a href="#11-asignaci√≥n-din√°mica-de-memoria" style="text-decoration: none;">10. Asignaci√≥n Din√°mica de Memoria</a></td>
    <td>
      <a href="#111-reserva-din√°mica" style="text-decoration: none;">10.1. Reserva Din√°mica</a><br>
      <a href="#112-liberaci√≥n-din√°mica" style="text-decoration: none;">10.2. Liberaci√≥n Din√°mica</a><br>
      <a href="#113-ejemplo-pr√°ctico" style="text-decoration: none;">10.3. Ejemplo Pr√°ctico</a>
    </td>
  </tr>
</table>

---

### üìå **Ap√©ndices**

<table style="border: none; width: 100%;">
  <tr>
    <td><strong>Tema</strong></td>
    <td><strong>Subtemas</strong></td>
  </tr>
  <tr>
    <td><a href="#12-ap√©ndices" style="text-decoration: none;">11. Ap√©ndices</a></td>
    <td>
      <a href="#121-funciones-de-biblioteca-ansi-c" style="text-decoration: none;">11.1. Funciones de Biblioteca ANSI C</a><br>
      <a href="#122-ejemplos-de-programas" style="text-decoration: none;">11.2. Ejemplos de Programas</a>
    </td>
  </tr>
</table>

---


 
### **0 Lista de Palabras Reservadas en C (Est√°ndar ANSI C / ISO C)**

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

---

#### **1. Palabras Reservadas B√°sicas (32 en total)**
Estas son las palabras clave definidas por el est√°ndar C que **no pueden usarse como identificadores** (nombres de variables, funciones, etc.):

| Categor√≠a          | Palabras Reservadas                                                                 |
|--------------------|------------------------------------------------------------------------------------|
| **Tipos de datos** | `char`, `short`, `int`, `long`, `float`, `double`, `void`, `_Bool` (C99), `_Complex` (C99), `_Imaginary` (C99) |
| **Modificadores**  | `signed`, `unsigned`, `const`, `volatile`, `restrict` (C99)                        |
| **Estructuras**    | `struct`, `union`, `enum`                                                          |
| **Control**        | `if`, `else`, `switch`, `case`, `default`, `for`, `do`, `while`, `break`, `continue`, `goto` |
| **Funciones**      | `return`                                                                           |
| **Memoria**        | `auto`, `register`, `static`, `extern`                                             |
| **Operadores**     | `sizeof`, `typedef`                                                                |
| **Otros**          | `inline` (C99), `_Alignas` (C11), `_Alignof` (C11), `_Atomic` (C11), `_Generic` (C11), `_Noreturn` (C11), `_Static_assert` (C11), `_Thread_local` (C11) |

---

#### **2. Extensiones Espec√≠ficas del Compilador**
Algunos compiladores a√±aden palabras reservadas propias (no est√°ndar). Ejemplos comunes:

- **GCC/G++**:  
  `__asm__`, `__attribute__`, `__inline__`, `__volatile__`, `__restrict__`, `__extension__`.  
- **Microsoft Visual C**:  
  `__cdecl`, `__declspec`, `__int64`, `__fastcall`, `__inline`.  

---

#### **3. Macros Predefinidas (No son palabras reservadas, pero son especiales)**
Estas pueden redefinirse, pero es peligroso:  
`NULL`, `true`, `false` (C99), `__FILE__`, `__LINE__`, `__DATE__`, `__TIME__`, `__func__` (C99).

---

#### **4. Diferencias entre Est√°ndares**
- **C89/C90**: 32 palabras reservadas.  
- **C99**: A√±ade `_Bool`, `_Complex`, `_Imaginary`, `inline`, `restrict`.  
- **C11**: A√±ade `_Alignas`, `_Alignof`, `_Atomic`, `_Generic`, `_Noreturn`, `_Static_assert`, `_Thread_local`.  

---

### **Ejemplo de Uso Incorrecto**
```c
int float = 10;  // ¬°Error! "float" es palabra reservada.
```

### **Ejemplo de Uso Correcto**
```c
int numero = 10;  // Correcto ("numero" no es palabra reservada).
```

---
### **Malas pr√°cticas de Programaci√≥n**

**Usar nombre de funciones de C como variables**  
Ejemplo: `malloc` como `calloc` **no son palabras reservadas** en el est√°ndar C. Son **funciones de la biblioteca est√°ndar** (`stdlib.h`), pero t√©cnicamente **pueden reutilizarse como nombres de variables**. Sin embargo, hacerlo es **mala pr√°ctica** y puede causar problemas. Aqu√≠ los detalles:

---

### **1. Ejemplo de Uso (Compila, pero es arriesgado)**

```c
#include <stdio.h>

int main() {
    int malloc = 42;  // Compila, pero "oscurece" la funci√≥n malloc().
    printf("%d\n", malloc);  // Imprime 42.
    return 0;
}
```
**Funciona**, pero ahora no podr√°s usar `malloc()` para asignar memoria din√°mica en ese √°mbito.

---

### **2. Riesgos Clave**
- **P√©rdida de funcionalidad**: Si necesitas usar `malloc()` o `calloc` despu√©s, el compilador tratar√° tu variable como un identificador, no como la funci√≥n.  
  ```c
  int* arr = malloc(10 * sizeof(int));  // ¬°Error! "malloc" es una variable, no una funci√≥n.
  ```
- **C√≥digo confuso**: Otros programadores (o t√∫ en el futuro) podr√≠an no entender por qu√© `malloc` no funciona como se espera.

---

### **3. ¬øPor qu√© el compilador lo permite?**
- **C no tiene namespaces**: Las funciones de la biblioteca est√°ndar no est√°n protegidas contra sobrescritura.  
- **El linker resuelve s√≠mbolos**: Si no incluyes `stdlib.h`, el compilador ni siquiera sabe que `malloc` es una funci√≥n.

---

### **4. Buenas Pr√°cticas**
- **Evita reutilizar nombres de funciones est√°ndar**. Usa alternativas claras:  
  ```c
  int mi_malloc = 42;  // ¬°Mejor!
  ```
- **Si accidentalmente lo haces**, renombra tu variable o usa el operador de resoluci√≥n de √°mbito (en C++):  
  ```cpp
  int malloc = 42;
  int* arr = ::malloc(10 * sizeof(int));  // C++: fuerza el uso de la funci√≥n global.
  ```
  *(En C puro no hay soluci√≥n directa; hay que renombrar la variable).*

---

### **5. Casos donde s√≠ podr√≠as hacerlo**
- **Macros maliciosas**: Si alguien defini√≥ `#define malloc algo_riesgoso`, podr√≠as "protegerte" con una variable local.  
  *(Pero es mejor usar `#undef malloc` y luego incluir `stdlib.h`).*

---


## 1.- IDENTIFICADORES, TIPOS DE DATOS, VARIABLES...

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

 
```
<tipo de dato> <nombre de variable>;

int a;
```

## 1.1. - Tipos de datos



|**Tipo de dato**|**Descripci√≥n.**|
| - | - |
|**char**|Car√°cter o entero peque√±o (byte)|
|**int**|Entero|
|**float**|Punto flotante|
|**double**|Punto flotante (mayor rango que *float*)|
|**void**|Sin tipo (uso especial)|



**Modificadores de Tipos de datos**

|**Modificador**|**Tipos de actuaci√≥n**|**Descripci√≥n**||
| - | - | - | :- |
|**signed**|char|int|Con signo (por defecto)|
|**unsigned**|char|int|Sin signo|
|**long**|int|double|Largo|
|**short**|int|Corto||

```
unsigned char a;
long double b;
short int i;
```
**Doble modificador a un mismo tipo de datos**
As√≠, es posible definir una variable de tipo :

```
unsigned long int (entero largo sin signo).
```


||**Rango de valores posibles en (notaci√≥n matem√°tica)**|| 
| :- | - | :- |
|**Tipo de variable declarada**|**16 bits**|**32 bits**|
|char / signed char|[-128 , 127]|[-128 , 127]|
|unsigned char|[0 , 255]|[0 , 255]|
|int / signed int|[-32768 , 32767]|[-2147483647 , 2147483648]|
|unsigned int|[0 , 65535]|[0 , 4294967295]|
|short int / signed short int|[-32768 , 32767]|[-32768 , 32767]|
|unsigned short int|[0 , 65535]|[0 , 65535]|
|long int / signed long int|[-2147483647 , 2147483648]|[-2147483647 , 2147483648]|
|unsigned long int|[0 , 4294967295]|[0 , 4294967295]|
|float|[-3.4E+38 , -3.4E-38], 0 , [3.4E-38 , 3.4E+38]|[-3.4E+38 , -3.4E-38], 0 , [3.4E-38 , 3.4E+38]|
|double|[-1.7E+308 , -1.7E-308], 0 , [1.7E-308 , 1.7E+308]|[-1.7E+308 , -1.7E-308], 0 , [1.7E-308 , 1.7E+308]|
|long double|[-3.4E+4932 , -1.1E-4932], 0 , [3.4E-4932 , 1.1E+4932]|[-3.4E-4932 , -1.1E+4932], 0 , [3.4E-4932 , 1.1E+4932]|



**Modificadores de acceso.** 
Limitan  el  uso  que  puede  realizarse  de  las  variables declaradas. 



|**Modificador**|**Efecto**|
| - | - |
|const|Variable de valor constante|
|volatile|Variable  cuyo  valor  es  modificado externamente|

**const** asegura de que su valor no ser√° modificado por el programa, salvo en el momento de su declaraci√≥n asign√°ndole un valor inicial.

```
const int x = 650;
```

Si intentamos modificar el valor de **x**, tal como **x=x+10;**, producir√° un error en tiempo de compilaci√≥n.

**volatile**, indica al compilador que la variable puede modificarse por un *proceso externo* al propio programa (como la hora del sistema), y por ello, que no trate de optimizar dicha variable suponi√©ndole un valor constante, etc. Cada vez que se usa la variable, se realice una comprobaci√≥n de su valor.

**const** y **volatile** pueden usarse de forma conjunta en ciertos casos, por lo cual no son excluyentes el uno del otro. Ello es posible si se declara una variable que actualizara el reloj del sistema, (proceso externo al programa), y que no queremos pueda modificarse en el interior del programa. Por ello, podremos declarar:

```
volatile const unsigned long int hora;
```

## 1.2- Declaraci√≥n de variables y alcance.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Podemos declarar las variables en cuatro lugares del m√≥dulo del programa:

- Variables **globales** Fuera de todas las funciones del programa, accesibles desde cualquier parte del programa.
- Variables **locales** dentro de una funci√≥n, accesibles tan solo por la funci√≥n en las que se declaran.
- Variable como **par√°metros** a la funci√≥n, accesibles de igual forma que si se declararan dentro de la funci√≥n.
- Variable **local de bloque** del programa, accesible tan solo dentro del bloque donde se declara.

``` c
#include <stdio.h>
int add; /* Variable global, accesible desde cualquier parte del programa*/
void suma(int x) /* Variable local declarada como par√°metro, accesible solo por la funci√≥n suma*/
{
  add = add + x;
  return;
}
void intercambio(int *a, int *b)
{
  if (*a > *b)
  {
    int inter; /* Variable local, accesible solo dentro del bloque donde se declara*/
    inter= *a;
    *a = *b;
    *b = inter;
  }
return;
}
int main(void) /*Funci√≥n principal del programa\*
{
  int contador, a = 9, b = 0; /*Variables locales, accesibles solo por main*/
  add = 0;
  intercambio(&a, &b);
  for(contador=a; contador<=b; contador++) suma(contador); printf(‚Äú%d\n‚Äù ,add);
  return(0);
}
```
## 1.3.- Especificadores de almacenamiento de los tipos de datos.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Los especificadores de almacenamiento deben preceder a la declaraci√≥n del tipo de dato de la variable. Estos especificadores de almacenamiento son:



||**Especificador de almacenamiento**|**Efecto**|
| :- | :- | - |
|auto||Variable  local  (por defecto)|
|extern||Variable externa|
|static||Variable est√°tica|
|register||Variable registro|


**auto** se usa para declarar que una variable local existe dentro de la subrutina o bloque de programa donde se declara, es por defecto y no se suele usar.

**extern** se usa en programas compuestos por varios m√≥dulos, se usa sobre las variables globales del m√≥dulo, y el compilador no crea un almacenamiento para ella en memoria, sino que, tan solo tiene en cuenta que dicha variable ya ha sido declarada en otro modulo del programa y es del tipo de dato que se indica.

**static** act√∫a seg√∫n el alcance de la variable:

- Para variables locales, **static** indica que la variable local debe almacenarse de forma permanente en memoria, como si fuera una variable global, pero su alcance como variable local declarada en la subrutina o bloque,conservando su valor entre llamadas a la funci√≥n.
- Para variables globales, **static** indica que la variable global es local al m√≥dulo del programa donde se declara, y, no ser√° conocida por ning√∫n otro m√≥dulo del programa.

**register** se aplica solo a variables locales de tipo **char** e **int**, indicando al compilador, si es posible, mantenga esa variable en un registro de la CPU y no cree una variable en la memoria. Se pueden declarar cuantas variables se deseen, pues el compilador ignorara dicha  declaraci√≥n  caso  de  no  poder  ser  satisfecha.  Y permite colocar en registros de la CPU variables usadas, como contadores de bucles, etc.

Algunos ejemplos de uso de los especificadores de almacenamiento son:

```
register unsigned int a;

static float b;

extern int c;

static const unsigned long int d;
```

## 1.4.- Constantes.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Valores fijos que el programa no puede alterar:



|**Tipo de dato**|**Constantes de ejemplo**|
| - | - |
|char|‚Äòa‚Äô ‚Äò9‚Äô 'Q'|
|int|1 -34 21000|
|long int|-34 67856L 456|
|short int|10 -12 1500|



|unsigned int|45600U 345 3|
| - | - |
|float|12\.45 4.34e-3 -2.8e9|
|double|-34.657 -2.2e-7 1.0e100|


Otras constantes son las constantes hexadecimales y octales, las constantes de cadena, y las constantes de barra invertida.

Las constantes hexadecimales y octales son **constantes enteras**, pero definidas en base 16 (constantes hexadecimales) o en base 8 (constantes octales).

Las constantes de tipo hexadecimal comienzan por los caracteres *0x*** seguidas del n√∫mero deseado. 
Las constantes de tipo octal comienzan por un cero (*0*). Por ejemplo, son constantes hexadecimales *0x34* (52 decimal), *0xFFFF* (65535 decimal); y constantes octales *011* (9 decimal), *0173* (123 decimal)

Las constantes de cadena son conjuntos de caracteres que se encierran entre comillas dobles. *‚ÄúEsto es una constante de cadena‚Äù*

Las  constantes de caracteres de barra invertida (tales como retorno de carro, etc.). Estas constantes son proporcionadas por C para que sea posible introducir dichas caracteres como constantes en los programas en los cuales sea necesario:



|**C√≥digo**|**Significado**|
| - | - |
|\b|Retroceso|
|\f|Alimentaci√≥n de hoja|
|\n|Nueva l√≠nea|
|\r|Retorno de carro|
|\t|Tabulador horizontal|
|\‚Äù|Doble comilla|
|\‚Äô|Simple comilla|
|\0|Nulo|
|\\|Barra invertida|
|\v|Tabulador vertical|
|\a|Alerta|
|\o|Constante octal|
|\x|Constante hexadecimal|


Son igual que el de cualquier otro car√°cter, as√≠, si *ch* es una variable de tipo *char*, podemos hacer: *ch=‚Äò\t‚Äô*, o *ch=‚Äò\x20‚Äô* (car√°cter espacio), etc., de igual forma que realizar√≠amos con cualquier otra constante de car√°cter.

Las constantes de barra invertida pueden usarse en el interior de constantes de cadena como un car√°cter m√°s, por ello: *"Esto es una linea\n"*.

## 2. - Operadores aritm√©ticos, relaci√≥nales y l√≥gicos; operador asignaci√≥n; operador sizeof y operadores avanzados (operadores sobre bits y operador ?)

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

## 2.1.- Operadores aritm√©ticos.

Los operadores aritm√©ticos existentes en C son, ordenados de mayor a menor precedencia:



|**Operador**||**Operador**||**Operador**||
| - | :- | - | :- | - | :- |
|**++**|Incremento|**--**|Decremento|||
|**-**|Menos unario|||||
|**\*** |Multiplicaci√≥n.|**/**|Divisi√≥n|**%**|M√≥dulo|
|**+**|Suma|**-**|Resta|||

Los operadores ++, -- y % solo pueden usarse con datos de tipo *int* o *char*. El operador incremento (++), incrementa en una unidad el valor de la variable sobre la que se aplica, el operador decremento (--), decrementa en una unidad el valor de la variable, y el operador m√≥dulo (%), calcula el resto de una divisi√≥n de dos variables de tipo entero o car√°cter.

Un aspecto que conviene explicar es el hecho de que los operadores incremento y decremento pueden preceder o posceder a su operando, lo cual permite escribir, si *x* es una variable de tipo *int*, las expresiones ++*x* o *x*++. Usado de forma aislada no presenta ninguna diferencia, sin embargo, cuando se usa en una expresi√≥n existe una diferencia en el orden de ejecuci√≥n del mismo. Cuando el operador incremento (o decremento) precede al operando, C primero realiza el incremento (o decremento), y despu√©s usa el valor del operando, realiz√°ndose la operaci√≥n al contrario si el operador poscede al operando. As√≠, consid√©rense el siguiente c√≥digo de un programa:

int var1=10,var2;

var2=++var1; /\* Pone 11 en var2, pues primero incrementa var1,\*/              /\* y luego asigna su valor a var2 \*/

Mientras que el siguiente c√≥digo funciona de forma distinta:

int var1=10,var2;

var2=var1++; /\* Pone 10 en var2, pues primero asigna su valor \*/              /\* a var2, y luego incrementa var1 \*/

## 2.2- Operadores relaci√≥nales y l√≥gicos.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Los operadores relaci√≥nales y l√≥gicos de C:


| **Operador** | **Nombre**          | **Operador** | **Nombre**               | **Operador** | **Nombre**        | **Operador** | **Nombre**               |
|--------------|---------------------|--------------|--------------------------|--------------|-------------------|--------------|--------------------------|
| `!`          | NOT l√≥gico          | `>`          | Mayor que                | `<`          | Menor que         | `>=`         | Mayor o igual que        |
| `==`         | Igual que           | `!=`         | No igual                 | `&&`         | AND l√≥gico        | `\|\|`       | OR l√≥gico                |
| `&`          | AND bit a bit       | `\|`         | OR bit a bit             | `^`          | XOR bit a bit     | `~`          | NOT bit a bit            |
| `<<`         | Desplazamiento izquierda | `>>`    | Desplazamiento derecha   | `?:`         | Operador ternario | `=`          | Asignaci√≥n b√°sica        |
| `+=`         | Asignaci√≥n con suma | `-=`         | Asignaci√≥n con resta      | `*=`         | Asignaci√≥n con multiplicaci√≥n | `/=` | Asignaci√≥n con divisi√≥n |
| `++`         | Incremento          | `--`         | Decremento               | `->`         | Acceso a miembro de estructura | `.*` | Acceso a miembro por puntero |
| `&`          | Direcci√≥n de        | `*`          | Dereferencia             | `sizeof`     | Tama√±o de tipo    | `,`          | Operador coma            |


Los operadores relaci√≥nales y l√≥gicos tiene menor prioridad que los operadores aritm√©ticos antes descritos, as√≠ , escribir *10>3+9* es equivalente a escribir *10>(3+9)*.

## 2.3.- Operador asignaci√≥n.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

El lenguaje C, a diferencia de otros lenguajes tales como Pascal, no diferencia la asignaci√≥n de cualquier otro operador del lenguaje. Para C, la asignaci√≥n es un operador, el llamado operador asignaci√≥n (=), el cual posee la prioridad m√°s baja de todos los operadores. Es por ello que en C podemos escribir expresiones del tipo:

if ((c=a\*b)<0) /\* if es la comprobaci√≥n condicional de C, que \*/                /\* se vera con posterioridad \*/

Esta expresi√≥n asigna a la variable *c* el valor de *a\*b* y devuelve su valor para compararlo con el valor constante *0*. Los par√©ntesis son necesarios pues el operador asignaci√≥n tiene la prioridad mas baja de todos los operadores.

## 2.4.- Operador sizeof.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

El operador **sizeof** es un operador en tiempo de compilaci√≥n. Devuelve el tama√±o de una variable o tipo de dato durante la compilaci√≥n, no durante la ejecuci√≥n del programa. Veamos algunos ejemplos:

**sizeof(int)** devuelve el valor 2 en los sistemas operativos de 16 bits y 4 en los de 

32 bits.

Si tenemos **char a[20]**, **sizeof(a)** devuelve el valor 20, y si tenemos **float a[6]**, *sizeof(a)*** devuelve el valor 24 (4\*6).

## 2.5.- Operadores sobre bits.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

El lenguaje C posee operadores que act√∫an a nivel de bits sobre los datos, estos operadores son:



|**Operador**|**Nombre**|**Operaci√≥n**|
| - | - | - |
|~|Not|Complemento a uno (NOT)|
|<<|Desplazamiento izquierda|Desplazamiento izquierda|
|>>|Desplazamiento derecha|Desplazamiento derecha|
|&|And|Y|
|^|Xor|O exclusivo (XOR)|
|\|\||Or|O|


Los operadores &, | y** ^ act√∫an sobre dos operandos, mientras que ~ ,<< **y *>>*** act√∫an sobre un solo operando. Veamos su actuaci√≥n sobre dos valores cualquiera:



|**Operador**|**Operando 1**|**Operando 2**|**Resultado**|
| - | - | - | - |
|~|0xB2||0x4D|
|<<3|0xB2||0x90|
|>>2|0xB2||0x2C|
|&|0xB2|0x79|0x30|
|^|0xB2|0x79|0xCB|
|||0xB2|0x79|0xFB|


Donde los n√∫meros que acompa√±an a los operadores << y** >> indican cuantas posiciones se desplaza el operando. La prioridad de los operadores sobre bits es:

- El operador ~ tiene la misma prioridad que los operadores ++ y .**--**.
- Los operadores <<  y >>  tienen la prioridad situada entre los operadores aritm√©ticos y los operadores relaci√≥nales y l√≥gicos.
- Los operadores &, ^ y |  tienen la prioridad situada entre los operadores relaci√≥nales y los operadores l√≥gicos (&& y ||).
- 
## 2.6.- El operador ?.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

El operador *?* se usa para reemplazar las sentencias *if/else* (que veremos con posterioridad) de formato general:

```
if (condici√≥n)    expresi√≥n;
else
      expresi√≥n;
```

Donde expresi√≥n debe ser una expresi√≥n sencilla y no otra sentencia de C. El operador ? es un operador ternario cuyo formato general es:!

Exp1 *?* Exp2 *:* Exp3;

Donde **Exp1**, **Exp2** y **Exp3** son expresiones. El operador *?* eval√∫a la expresi√≥n **Exp1**, si es cierta se eval√∫a **Exp2**  y si es falsa se eval√∫a **Exp3**. Veamos algunos ejemplos:

```
int x,y;

y=(x>10) ? 100 : 200;
```

Asignara el valor 100 a *y* si *x* es mayor de 10, y el valor 200 en caso contrario. int t;

```
(t) ? f1(t)+f2() : printf(‚Äút vale cero‚Äù);
```

Ejecutara las funciones *f1()* y *f2()* si *t* es distinto de cero, y la funci√≥n *printf* si *t* 

vale cero.

## 3 - Conversi√≥n de tipos de datos.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

## 3.1.- Conversi√≥n autom√°tica de tipos de datos.

El lenguaje C permite que en una misma expresi√≥n aparezcan diferentes tipos de datos, encarg√°ndose el compilador de realizar las operaciones de forma correcta. El compilador del lenguaje C, cuando en una misma expresi√≥n aparecen dos o m√°s tipos de datos, convierte todos los operandos al tipo del operando m√°s grande existente de acuerdo con las dos reglas siguientes:

- Todos los *char* y *short int* se convierten a *int*. Todos los *float* a *double*.
- Para todo par de operandos, lo siguiente ocurre en secuencia:
- Si uno de los operandos es un *long double*, el otro se convierte en *long double*.
- Si uno de los operandos es *double*, el otro se convierte a *double*.
- Si uno de los operandos es *long*, el otro se convierte a *long*.
- Si uno de los operandos es *unsigned*, el otro se convierte a *unsigned*.

Despu√©s de que el compilador aplique estas reglas de conversi√≥n, cada par de operandos ser√° del mismo tipo, y el resultado ser√° del tipo de los operandos. Veamos un ejemplo:

char ch; int i; float f; double d;

(  ch  /  i  )  +  (  f  \*  d  )  -  (  f  +  i  );   char   int        float double      float  int

Debido a que en la operaci√≥n existen diferentes tipos se aplica la primera 

conversi√≥n:

ch de char pasa a int.

f de float pasa a double.

(  ch  /  i  )  +  (  f  \*  d  )  -  (  f  +  i  );   int    int       double double     double  int

Al ser los dos operandos de igual tipo, realizamos la primera operaci√≥n, *(ch / i)*, y el resultado es de tipo *int*. De igual forma, para la segunda operaci√≥n, *(f \* d)*, y el resultado es de tipo *double*.

Para la tercera operaci√≥n, y dado que las variables no son del mismo tipo, se aplica la segunda regla, convirti√©ndose el *int* en *double*, realiz√°ndose la suma *(f + i)* como dos datos de tipo *double*, y siendo por tanto el resultado un *double*.

Ahora procedemos a realizar la suma de los dos primeros resultados *(ch / i) + (f \* d)*, como uno de ellos es de tipo *int***,** y el otro de tipo *double*, el *int* se convierte en *double* por la segunda regla, y el resultado es un *double*.

Y por √∫ltimo, realizamos la resta final, siendo los dos operandos de tipo *double* y el resultado final, por tanto, de tipo *double*.

## 3.2.- Conversi√≥n forzada de tipos datos.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

En C, existe, adem√°s, de la conversi√≥n autom√°tica de tipos de datos, la posibilidad de forzar la conversi√≥n de un tipo de datos en otro tipo de datos. Esta conversi√≥n de un tipo de datos en otro se llama ‚Äúcasts‚Äù, y su sintaxis es:

(tipo)expresi√≥n

Su utilidad queda claramente expresada en el ejemplo siguiente:

```
int a=3,b=2; float c; c=a/b;
```

La operaci√≥n asigna a *c* el valor *1.0* en vez de el valor *1.5*, ello se debe a que al ser *a* y *b* variables de tipo entero, se realiza una divisi√≥n entre enteros, y el resultado de *3/2* es *1*. A continuaci√≥n ese valor *1* se convierte a un valor en coma flotante para realizar la asignaci√≥n (valor *1.0*), y se asigna a *c*. Si lo que se desea es que la divisi√≥n se realice en punto flotante, debe escribirse la operaci√≥n de la siguiente forma:

```
c=(float)a/b;
```

Esta conversi√≥n forzada obliga a convertir la variable *a* en *float*, y entonces, aplicando las reglas de conversi√≥n autom√°tica de tipos, se realiza la divisi√≥n en coma flotante. Este proceso da lugar a que el resultado de la operaci√≥n sea *1.5*, y dicho valor sea el asignado a la variable *c*.!

## 4 - Sentencias de control y bucles.



## 4.1.- Sentencia de control if.

Antes de empezar a explicar las sentencias de control del lenguaje C, conviene explicar los conceptos de verdadero/falso y de sentencia que posee el lenguaje C.

El lenguaje C posee un concepto muy amplio de lo que es verdadero. Para C, cualquier valor que sea distinto de cero es verdadero, siendo por tanto falso solo si el valor cero. Es por ello que una expresi√≥n del tipo *if(x)* ser√° verdad siempre que el valor de la variable **x** sea distinto de cero, sea cual sea el tipo de la variable *x*.

El concepto de sentencia en C es igual que el de otros muchos lenguajes. Por sentencia se entiende en C cualquier instrucci√≥n simple o bien, cualquier conjunto de instrucciones simples que se encuentren encerradas entre los caracteres { y }, que marcan respectivamente el comienzo y el final de una sentencia.

La forma general de la sentencia *if* es:
```
if (condici√≥n)
    sentencia; 
else
`   `sentencia;
```

Siendo el *else* opcional. Si la *condici√≥n* es verdadera se ejecuta la *sentencia* asociada al *if*, en caso de que sea falsa la *condici√≥n* se ejecuta la *sentencia* asociada al *else*** (si existe** el *else*). Veamos algunos ejemplos de sentencias *if*:

```
int a,b;

if (a>b)
{
b--;
a=a+5; }
else
{
a++;
b=b-5; }
if (b-a!=7)
b=5;

```


Las sentencias de control *if* pueden ir anidadas. Un *if* anidado es una sentencia *if*  que es el objeto de otro *if*  o *else*. Esta anidaci√≥n de *if/else*  puede presentar la problem√°tica de decidir que *else*  va asociado a cada *if*. Considerese el siguiente ejemplo:

```
if (x)
  if (y) printf(‚Äú1‚Äù);
  else printf(‚Äú2‚Äù);
```

¬øA que *if* se refiere el *else*?. C soluciona este problema asociando cada *else* al *if* m√°s cercano posible y que todav√≠a no tiene ning√∫n *else* asociado. Es por ello que en este caso el *if* asociado al *else* es el *if(y)*. Si queremos que el *else* este asociado al *if(x)*, deber√≠amos escribirlo de la siguiente forma:

```
if (x)
{
  if (y)
  printf(‚Äú1‚Äù);
}
else
  printf(‚Äú2‚Äù);
```

2. **- Sentencia de control switch.**

  [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La forma general de la sentencia *switch* es:

switch(variable) {
case const1: sentencia; break; case const2:
sentencia;       break;    ...
`   `default:       sentencia; }

Donde *variable* debe ser de tipo *char* o *int*, y donde *const1*, *const2*, **...**, indican constantes de C del tipo de datos de la *variable*. Dichas constantes no pueden repetirse dentro del *switch*. El *default* es opcional y puede no aparecer, as√≠ como los *break* de los *case*. La sentencia *switch* se ejecuta comparando el valor de la variable con el valor de cada una de las constantes, realizando la comparaci√≥n desde arriba hacia abajo. En caso de que se encuentre una constante cuyo valor coincida con el valor de la variable, 

se empieza a ejecutar las sentencias hasta encontrar una sentencia *break*. En caso de que no se encuentre ning√∫n valor que coincida, se ejecuta el *default*** (si existe)**.** Veamos algunos ejemplos:

¬¥¬¥¬¥
int valor;
switch(valor)
{
  case 0: cont++;
    break;
  case 5: cont--;
    break;
  default: cont=-10; /\* Se ejecuta si valor no es 0 o 5 \*/ 
}
char d;
int cont=0;
switch(d)
{
  case ‚Äò\r‚Äô: cont++; /\* Si d es un retorno de carro, se \*/
`                      `/\* ejecuta este cont++ y el siguiente\*/                       /\* al no aparecer un break \*/
  case ‚Äò\x1B‚Äô: cont++;
    break;
  default: cont=-1;
}
¬¥¬¥¬¥

Las sentencias *switch* pueden aparecer unas dentro de otras, igual que suced√≠a con las sentencias *if*. Ve√°moslo con un ejemplo:

¬¥¬¥¬¥

char d, e;

switch (d) {
	case 'a':
	case 'A':
		switch (e) {
			case '1':
				d = 'z';
				e = '+';
				break;
			case '2':
				d = 'Z';
				e = '-';
		}
		break;

	case 'b':
	case 'B':
		switch (e) {
			case '0':
				d = '2';
			default:
				e = '+';
		}
}

```

3. **- Bucle for.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La sintaxis del bucle *for* es:

for(inicializaci√≥n,condici√≥n,incremento) sentencia;

En primer lugar, conviene destacar el hecho de la gran flexibilidad del bucle *for* de C. En C, el bucle *for* puede no contener *inicializaci√≥n*, *condici√≥n* o *incremento*, o incluso pueden no existir dos e incluso las tres expresiones del bucle. El bucle *for* se ejecuta siempre que la *condici√≥n* sea verdadera, es por ello que puede llegar a no ejecutarse.

Veamos algunos ejemplos de bucles *for*:

```
int i,suma=0; for(i=1;i<=100;i++)

suma=suma+i;

int i,j;

for(i=0,j=100;j>i;i++,j--) {

printf(‚Äú%d\n‚Äù,j-i); printf(‚Äú%d\n‚Äù,i-j);

}

float a=3e10;

for(;a>2;a=sqrt(a)) /\* sqrt() calcula la ra√≠z cuadrada \*/

printf(‚Äú%f‚Äù,a);

char d;

for(;getc(stdin)!=‚Äô\x1B‚Äô;); /\* Bucle que espera hasta que se \*/                             /\* pulsa la tecla Esc \*/

char d; for(;;) {

d=getc(stdin); printf(‚Äú%c‚Äù,d); if (d==‚Äò\x1B‚Äô)

break;

}
```



Como se observa en este √∫ltimo ejemplo, el bucle *for*  no posee ninguna expresi√≥n. Para salir de el se usa la sentencia *break*, dicha sentencia (ya vista junto con la sentencia de control *switch*) se explicara mas detalladamente con posterioridad.

4. **- Bucle while.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La sintaxis del bucle *while* es:

while (condici√≥n) sentencia;

Donde la *sentencia* puede no existir (sentencia vac√≠a), pero siempre debe existir la *condici√≥n*. El bucle *while*  se ejecuta mientras la condici√≥n sea verdad. Veamos algunos ejemplos de bucles *while*:

int i=1,suma=0; while (i<=100)

{

suma=suma+i; i++;

}

while (getc(stdin)!=‚Äò\x1B‚Äô); /\* Bucle que espera hasta que se \*/                              /\* pulse la tecla Esc \*/

while (1) /\* Recordar que en C lo que no es cero es verdad \*/ {

d=getc(stdin);

printf(‚Äú%c‚Äù,d);

if (d==‚Äò\x1B‚Äô)

break;

}

5. **- Bucle do/while.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Al contrario que los bucles *for* y *while* que comprueban la condici√≥n en lo alto de la misma, el bucle *do/while* comprueba la condici√≥n en la parte baja del mismo, lo cual provoca que el bucle se ejecute como m√≠nimo una vez. La sintaxis del bucle *do/while* es:

do

`   `sentencia;

while (condici√≥n);

El bucle *do/while* se ejecuta mientras la *condici√≥n* sea verdad. Veamos algunos ejemplos de bucle *do/while*:

int num;

do

scanf(‚Äú%d‚Äù,&num); while (num>100);

int i,j;

do

{

scanf(‚Äú%d‚Äù,&i);

scanf(‚Äú%d‚Äù,&j); }

while (i<j);

**5.6 - Sentencias de control break y continue .**

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Las sentencias de control *break* y *continue* permiten modificar y controlar la ejecuci√≥n de los bucles anteriormente descritos.

La sentencia *break* provoca la salida del bucle en el cual se encuentra y la ejecuci√≥n de la sentencia que se encuentra a continuaci√≥n del bucle.

La sentencia *continue* provoca que el programa vaya directamente a comprobar la condici√≥n del bucle en los bucles *while* y *do/while*, o bien, que ejecute el incremento y despu√©s compruebe la condici√≥n en el caso del bucle *for*.

Veamos algunos ejemplos de uso de *break* y de *continue*:

int x;

for(x=0;x<10;x++)

{

for(;;)

if (getc(stdin)==‚Äò\x1B‚Äô)

break;

`   `printf(‚ÄúSal√≠ del bucle infinito, el valor de x es: %d\n‚Äù,x); }

int x;

for(x=1;x<=100;x++) /\* Esta rutina imprime en pantalla los \*/

{                   /\*n√∫meros pares \*/

if (x%2)

continue;
printf(‚Äú%d\n‚Äù,x);

}

**Tema 6 - Arrays, cadenas y punteros.**

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

1. **‚Äì Arrays y cadenas.**

En C, un array unidimensional se declara como:

tipo nombre[tama√±o];

En C, el primer elemento de un array es el que posee el √≠ndice 0, por lo tanto, un array de 20 elementos posee sus elementos numerados de 0 a 19. Veamos unos ejemplos de declaraci√≥n y manejo de algunos arrays:

int x[100],i; for(i=0;i<100;i++)

x[i]=i;

char letras[256]; int i; for(i=0;i<256;i++)

letras[i]=i;

int x[10],i,suma;

for(i=0;i<10;i++)

{

`   `printf(‚ÄúIntroducir un n√∫mero: %d: ‚Äú,i);

scanf(‚Äú%d‚Äù,&x[i]);

}

for(suma=0,i=0;i<10;i++)

suma=suma+x[i];

printf(‚ÄúLa suma es: ‚Äú,suma);

Sin embargo, el lenguaje C no comprueba el tama√±o de los arrays, por lo cual, es posible construir una rutina como la siguiente, la cual ocasionara un incorrecto funcionamiento del programa:

float a[10];

int i;

for(i=0;i<100;i++) /\* Este bucle es incorrecto \*/

a[i]=i;

Es por ello, que es misi√≥n del programador comprobar que no se produzca el desbordamiento de los arrays.

Una  cadena,  tambi√©n  llamada  string,  es  un  tipo  especial  de  array unidimensional. Una cadena es un array de caracteres (*char*) que termina con un car√°cter especial (el car√°cter *‚Äò\0‚Äô*). Es por ello, que la declaraci√≥n de una cadena de caracteres se realiza exactamente igual que la declaraci√≥n de un array unidimensional de caracteres:

char cadena[tama√±o];

Como toda cadena debe terminar en el car√°cter *‚Äò\0‚Äô*, es por ello que si se quiere usar una cadena de 20 caracteres, debe declararse de tama√±o 21 (20 caracteres + car√°cter terminador).

Por lo dem√°s, puede usarse una cadena como si fuera un array unidimensional, pues se puede referenciar uno cualquiera de sus elementos, etc. Para manejar las cadenas, existen un gran n√∫mero de funciones de biblioteca que proporciona el standard ANSI-C, para m√°s informaci√≥n referirse al apendice A o a cualquier libro de C.

La declaraci√≥n de arrays de m√°s de una dimensi√≥n se realiza de forma parecida a la de una dimensi√≥n, la sintaxis de la declaraci√≥n de un array multidimensional es:

tipo nombre[tam1][tam2]...[tamN];

Y su indexaci√≥n, etc., se realiza de forma similar al array unidimensional. Veamos un ejemplo:

float matriz[2][3];

int i,j;

for(i=0;i<2;i++)

for(j=0;j<3;j++)

{

printf(‚ÄúM[%d][%d]: ‚Äú,i,j);

scanf(‚Äú%f‚Äù,&matriz[i][j]); }

Adem√°s, es posible inicializar los arrays en el momento de declararlos. Su 

sintaxis es:

tipo nombre[tam1][tam2]...[tamN]={lista\_de\_valores};

Por lo cual, podemos escribir:

float vector[3]={-3.0,5.7,-7.5};

Tambi√©n es posible inicializar arrays sin ponerles el tama√±o, el compilador cuenta el n√∫mero de caracteres de inicializaci√≥n y reserva el tama√±o necesario de forma autom√°tica. Por ejemplo:

float vector[]={-3.0,5.7,-7.5};

char cadena[]=‚ÄúEsto es una cadena‚Äù;

2. **‚Äì Punteros.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Los punteros son una de las poderosas herramientas que ofrece el lenguaje C a los programadores, sin embargo, son tambi√©n una de las m√°s peligrosas, el uso de punteros sin inicializar, etc., es una fuente frecuente de errores en los programas de C, y adem√°s, suele producir fallos muy dif√≠ciles de localizar y depurar.

Un  puntero  es  una  variable  que  contiene  una  direcci√≥n  de  memoria. Normalmente esa direcci√≥n es una posici√≥n de memoria de otra variable, por lo cual se suele decir que el puntero ‚Äúapunta‚Äù a la otra variable.

La sintaxis de la declaraci√≥n de una variable puntero es:

tipo \*nombre;

El tipo base de la declaraci√≥n sirve para conocer el tipo de datos al que pertenece la variable a la cual apunta la variable de tipo puntero. Esto es fundamental para poder leer el valor que almacena la zona de memoria apuntada por la variable puntero y para poder realizar ciertas operaciones aritm√©ticas sobre los mismos.

Algunos ejemplos de declaraci√≥n de variables puntero son:

int \*a;

char \*p;

float \*f;

Existen dos operadores especiales de los punteros, el operador *\** y el operador 

*&*.

El operador *&*** es un monario que devuelve la direcci√≥n de una variable de memoria. As√≠, si declaramos:

int \*a,b;

Y hacemos:

a=&b;

La variable puntero *a* contendr√° la direcci√≥n de memoria de la variable *b*.

El operador *\** es un operador monario que devuelve el valor de la variable situada en la direcci√≥n que sigue. Ve√°moslo con un ejemplo:

int \*a,b,c;

Si hacemos:

b=15; a=&b; c=\*a;

Entonces la variable *c*** contendr√° el valor *15*, pues *\*a* devuelve el valor de la direcci√≥n que sigue (a la que ‚Äúapunta‚Äù la variable puntero), y con anterioridad hemos hecho que *a* contenga la direcci√≥n de memoria de la variable *b*** usando para ello el operador *&*.

Con las variables de tipo puntero es posible realizar algunas operaciones:

- Asignaci√≥n de punteros. Es posible asignar el valor de una variable de tipo puntero a otra variable de tipo puntero. Por ejemplo:

int \*a,\*b,c; a=&c; b=a;

Entonces *b*** contiene el valor de *a*, y por ello, *b* tambi√©n ‚Äúapunta‚Äù a la variable *c*.

- Aritm√©tica de punteros. Sobre las variables de tipo puntero es posible utilizar los operadores +, -, ++ y --. Estos operadores incrementan o decrementan la posici√≥n de memoria a la que ‚Äúapunta‚Äù la variable puntero. El incremento o decremento se realiza de acuerdo al tipo base de la variable de tipo puntero, de ah√≠ la importancia del tipo del que se declara la variable puntero. Veamos esto con la siguiente tabla:



|**Operaci√≥n**|++|--|+9|-5||||||||
| - | - | - | - | - | :- | :- | :- | :- | :- | :- | :- |
|**Variable**|**Direcci√≥n actual**|**Nueva direcci√≥n**||||||||||
|int \*a;|3000||3002|2998|3018|2990||||||
|float \*b|3000||3004|2996|3036|2980||||||

*Tabla 6.2.1: Ejemplos de aritm√©tica de punteros en C.* Por lo tanto, si tenemos:

tipo \*a;

Y hacemos: a=a+num;

La posici√≥n a la que apunta *a* se incrementa en *num\*sizeof(tipo)*. Para la resta se decrementa de igual forma en *num\*sizeof(tipo)*. Los operadores ++  y --  son equivalentes a realizar *num=1*, y con ello quedan obviamente explicados.

- Comparaciones de punteros. Sobre las variables de tipo puntero es posible realizar operaciones de comparaci√≥n entre ellas. Veamos un ejemplo:

int \*a,\*b; if (a<b)

printf(‚Äúa apunta a una direcci√≥n m√°s baja que b‚Äù);

Existe una estrecha relaci√≥n entre los punteros y los arrays. Consideremos el siguiente fragmento de c√≥digo:

char str[80],\*p; p=str;

Este fragmento de c√≥digo pone en la variable puntero p la direcci√≥n del primer elemento del array *str*. Entonces, es posible acceder al valor de la quinta posici√≥n del array mediante *str[4]*** y** *\*(p+4)* (recu√©rdese que los √≠ndices de los arrays empiezan en 0). Esta estrecha relaci√≥n entre los arrays y los punteros queda m√°s evidente si se tiene  en cuenta que el nombre del array sin √≠ndice es la direcci√≥n de comienzo del array, y, si adem√°s,  se  tiene  en  cuenta  que  un  puntero  puede  indexarse  como  un  array unidimensional, por lo cual, en el ejemplo anterior, podr√≠amos referenciar ese elemento como *p[4]*.

Es posible obtener la direcci√≥n de un elemento cualquiera del array de la siguiente forma:

int str[80],\*p; p=&str[4];

Entonces, el puntero *p* contiene la direcci√≥n del quinto elemento del array *str*.

Hasta ahora hemos declarado variables puntero aisladas. Es posible, como con cualquier otro tipo de datos, definir un array de variables puntero. La declaraci√≥n para un array de punteros *int* de tama√±o *10* es:

int \*a[10];

Para asignar una direcci√≥n de una variable entera, llamada *var*, al tercer elemento del array de punteros, se escribe:

x[2]=&var;

Y para encontrar el valor de *var*: \*x[2];

Dado, adem√°s, que un puntero es tambi√©n una variable, es posible definir un puntero a un puntero. Supongamos que tenemos lo siguiente:

int a,\*b,\*\*c; b=&a; c=&b;

Y entonces, *\*\*c* tiene el valor de la variable *a*, pues *c* es un puntero a una variable que ya es de tipo puntero.

Este concepto de puntero a puntero podr√≠a extenderse a puntero a puntero a puntero, etc., pero no nos ocuparemos de ello. Adem√°s, existe el concepto de puntero a una funci√≥n, al cual nos referiremos en el tema dedicado a las funciones.

**Tema 7 - Funciones.** El formato general de una funci√≥n de C es:

tipo nombre(lista de par√°metros) {

`   `cuerpo de la funci√≥n

}

Las funciones son simulares a las de cualquier otro lenguaje, pero, tal y como citamos en la introducci√≥n, al no ser un lenguaje estructurado por bloques, no es posible declarar funciones dentro de otras funciones.

1. **- La sentencia return.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Antes de empezar la explicaci√≥n de las funciones, conviene explicar la sentencia *return*. La sentencia *return* permite, en primer lugar, salir de la funci√≥n desde cualquier punto de la misma, y en segundo lugar, devolver un valor del tipo de la funci√≥n, si ello es necesario (no se devuelve ning√∫n valor si la funci√≥n es de tipo *void*). Veamos un ejemplo:

int Comparacion(int a,int b)

{

`   `if (a>b) return 1;  /\* a es mayor que b \*/    if (a<b) return -1; /\* a es menor que b \*/    return 0;           /\* a y b son iguales \*/ }

Como se observa en el ejemplo, una funci√≥n puede contener m√°s de una sentencia *return*. Ello permite, la posibilidad de poder salir de la funci√≥n desde distintos puntos de la misma. Un aspecto que conviene resaltar es el hecho de que una funci√≥n tambi√©n termina su ejecuci√≥n si llega al final de la misma sin encontrar ninguna sentencia *return*. Ello es posible en toda funci√≥n de tipo *void*. Veamos un ejemplo:

void A(int \*a) {

`   `\*a=5;

}

Esa funci√≥n es equivalente a otra que tuviera como √∫ltima l√≠nea una sentencia *return*, y funcionar√≠a de igual forma.

2. **- Argumentos de las funciones, llamada por valor y por ![](Aspose.Words.ae55ca77-bd47-4be1-a802-7483922c91a3.005.png)"referencia".**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Una vez conocido el uso de la funci√≥n *return*, podemos introducirnos en la explicaci√≥n de las funciones. En primer lugar, si una funci√≥n usa argumentos, es  necesario declarar variables que acepten los argumentos de la funci√≥n. Veamos un ejemplo:

int EstaEn(char \*cad,char c) /\* Devuelve 1 si el car√°cter c \*/ {                            /\* esta en el string cad \*/

while (\*cad!=‚Äò\0‚Äô)

{

if (\*cad==c)

return 1;

cad++;

}

return 0;

}

Esta funci√≥n, podr√≠a ser llamada desde otra funci√≥n de la siguiente forma:

char cadena[]=‚ÄúEsta es una cadena de prueba‚Äù; if (EstaEn(cadena,‚Äôa‚Äô))

`   `printf(‚ÄúEsta‚Äù);

else

`   `printf(‚ÄúNo esta‚Äù);

A diferencia de otros lenguaje, el lenguaje C, solo permite pasar par√°metros a las funciones por valor. Si se desea que los cambios efectuados en una funci√≥n sobre una variable afecten fuera del alcance de la funci√≥n, es posible simular un paso por 

referencia mediante el uso de punteros. En efecto, si a una funci√≥n le pasamos como argumento la direcci√≥n de una variable, cualquier modificaci√≥n que se realice en esa direcci√≥n, afectara, l√≥gicamente, al valor que tiene la variable original, y con ello, conseguiremos el mismo efecto que un paso por referencia. Ve√°moslo con un ejemplo:

#include <stdio.h>

void Alfa(int \*val,float pos) {

\*val=5;

pos=7.7;

return;

}

void Beta(int val,float \*pos) {

val=10;

\*pos=14.7;

}

int main(void)

{

int a=6;

float b=9.87;

printf(‚ÄúAl principio valen a=%d b=%f\n‚Äù,a,b);    Alfa(&a,b);

`   `printf(‚ÄúDespu√©s de Alfa valen a=%d b=%f\n‚Äù,a,b);    Beta(a,&b);

`   `printf(‚ÄúDespu√©s de Beta valen a=%d b=%f\n‚Äù,a,b); }

Este programa mostrara en pantalla:

Al principio valen a=6 b=9.87 Despu√©s de Alfa  valen a=5 b=9.87 Despu√©s de Beta valen a=5 b=14.7

Ello es, pues a *Alfa* se le pasa la variable *a* por "referencia" (se le pasa *&a*, o sea, un puntero a la variable *a*), y la variable *b* por valor, mientras que en *Beta* sucede al rev√©s.

3. **- Arrays como argumentos de funciones.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Un aspecto a tener muy en cuenta es que C no permite el paso de un array por valor a una funci√≥n, un array es siempre pasado por "referencia", pues en la llamada, lo que se pasa es la direcci√≥n del primer elemento del array (recu√©rdese que el nombre de un array es un puntero al primer elemento). Por valor tan solo es posible pasar por valor elementos individuales del array, pero no el array completo. Ve√°moslo en un ejemplo:

#include <stdio.h>

void PasoValorReferencia(int \*array,int valor) {

array[5]=-8.6;

valor=4;

}

int main(void)

{

`   `int array[10]={0,0,0,0,0,0,0,0,0,0};    PasoValorReferencia(array,array[3]);

`   `printf(‚ÄúArray[5] vale: %d y array[3] vale:%d\n‚Äù,array[5],array[3]);    return 0;

}

Colocara en pantalla en el mensaje:

Array[5] vale: 8.6 y array[3] vale: 0

4. **- Argumentos de la funci√≥n main.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La  funci√≥n *main()*,  como  toda  funci√≥n  de  C,  acepta  argumentos.  Los argumentos que acepta la funci√≥n *main()* son un entero (*int argc*), un array de punteros a strings (*char \*argv[]*), y otro array de punteros a strings (*char \*env[]*). Aunque los nombres de dichos argumentos no tienen porque ser *argc*, *argv*, y *env*, en toda la literatura de C se usan dichos nombres, y aqu√≠ los respetaremos. El significado de los par√°metros *argc*, *argv* y *env* es el siguiente:

- El par√°metro *argc* contiene el n√∫mero de argumentos en la l√≠nea de ordenes de la llamada al programa.
- El par√°metro *argv* contiene un puntero a cada uno de los argumentos (strings) de la l√≠nea de ordenes de la llamada al programa.
- El par√°metro *env* contiene un puntero a cada una de las variables de ambiente (strings) del sistema operativo.

  Veamos un ejemplo de programa que use argumentos en la l√≠nea de ordenes:

#include <stdio.h>

int main(int argc,char \*argv[],char \*env[]) {

int i;

printf(‚ÄúEl valor de argc es: %d\n‚Äù,argc); for(i=0;i<argc;i++)

printf(‚ÄúEl argumento %d es: %s\n‚Äù,i,argv[i]); for(i=0;env[i]!=NULL;i++)

printf("La variable de ambiente %d es: %s\n",i,env[i]);    return 0;

}

Supongamos que el programa lo hemos llamado *prueba.exe*, entonces, llamando al programa con la siguiente l√≠nea:

prueba.exe   Este\_es\_el\_argumento\_1   Este\_es\_el\_argumento\_2

Escribir√° en pantalla:

El valor de argc es: 3

El argumento 0 es: prueba.exe

El argumento 1 es: Este\_es\_el\_argumento\_1

El argumento 2 es: Este\_es\_el\_argumento\_2

La variable de ambiente 0 es: COMSPEC=C:\DOS\COMMAND.COM La variable de ambiente 1 es: TEMP=C:\WINDOWS\TEMP

La variable de ambiente 2 es: PROMPT=$P$G

Como se puede observar, existen 3 argumentos, numerados de 0 a 2, siendo el argumento 0, siempre, el nombre del programa, y siendo el resto de argumentos los argumentos del programa. El n√∫mero y valor de las variables de ambiente depende, tanto  de  que  sistema  operativo  se  trate  (MS-DOS,  UNIX,  etc.),  como  de  la configuraci√≥n, etc., del procesador de comandos de dicho sistema operativo.

5. **- Recursividad.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Una funci√≥n de C puede llamarse a si misma. Este proceso recibe el nombre de recursividad. Los ejemplos de recursividad abundan, siendo uno de los mas habituales la funci√≥n factorial:

unsigned Factorial(unsigned num) {

if (num==0) return 1;

return num\*Factorial(num-1);

}

La recursividad es una poderosa herramienta de programaci√≥n, sin embargo, presenta dos problemas:

- La velocidad de ejecuci√≥n de un algoritmo programado de forma recursiva es mucho mas lento que el programado de forma iterativa.
- La recursividad, si es excesiva, puede ocasionar el desbordamiento de la pila, y con ello, el fallo en la ejecuci√≥n del programa.

Sin embargo, el uso de la recursividad es frecuente en campos como la inteligencia artificial, etc., y en la implementaci√≥n de ciertos algoritmos tales como el algoritmo de ordenaci√≥n "QuickSort", muy dif√≠cil de implementar de forma iterativa, pero relativamente sencillo de forma recursiva.

6. **- Punteros a funciones.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Al igual que cualquier otro tipo de dato, una funci√≥n ocupa una direcci√≥n de memoria, y por tanto, puede ser apuntada por un puntero. La declaraci√≥n de un puntero a una funci√≥n es:

tipo de dato (\*nombre de la variable)(prototipo);

Veamos algunos ejemplos:

int (\*a)(int,float); void (\*b)(void);

Generalmente, los punteros a funciones se usan en la programaci√≥n de bajo nivel,  tal  como  modificaci√≥n  de  interrupciones,  creaci√≥n  de  controladores  de dispositivos, etc.

7. **- El modificador de almacenamiento static aplicado a funciones.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Al igual que en el caso de las variables globales, es posible aplicar delante de una funci√≥n el modificador de almacenamiento *static*. Dicho modificador hace que la funci√≥n sobre la que se aplica sea local al m√≥dulo donde se encuentra, y no pueda ser conocida por los restantes m√≥dulos del programa, de igual forma a como suced√≠a con las variables globales. Esta modificaci√≥n del alcance de una funci√≥n permite realizar un mejor encapsulado del c√≥digo y simplificar la programaci√≥n en proyectos de gran envergadura.

**Tema 8 - Estructuras, campos de bit, uniones y** 

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

**enumeraciones.**

1. **- Estructuras.**

Una estructura es un conjunto de variables que se referencian bajo el mismo nombre. La sintaxis de la declaraci√≥n de una estructura en lenguaje C es:

struct nombre\_estructura{

tipo nombre\_variable;    tipo nombre\_variable;    ...

`   `tipo nombre\_variable; }variables\_estructura;

Es posible no poner el nombre de la estructura (*nombre\_estructura*), o bien, no crear en el momento de declarar la estructura ninguna variable de la estructura (*variables\_estructura*), pero no es posible eliminar la aparici√≥n de ambos elementos. Veamos algunos ejemplos de declaraci√≥n de estructuras:

struct LISTA{

int tam;

char cadena[50]; }var\_lista;

struct DATO{

int tam;

float vector[3];

struct DATO \*siguiente;

}; struct {

float a,b;

unsigned long i,j;

char cadena[5]; }memo[10];

struct ALFA{

int a;

float b;

};

struct BETA{

struct ALFA alfa;

float c,d; }variable;

Para referenciar un elemento de una estructura se realiza de la siguiente forma:

variables\_estructura.nombre\_variable;

As√≠, pod√≠amos referenciar los elementos de las estructuras anteriores de la siguiente forma:

var\_lista.tam; var\_list.cadena; var\_list.cadena[7]; memo[2].a; memo[6].cadena[3]; variable.alfa.a; variable.c;

Un aspecto que es necesario aclarar es el paso de estructuras como par√°metros a las funciones. A una funci√≥n es posible pasarle un elemento de los que componen la estructura, una estructura entera, e incluso, un array de estructuras. En caso de pasarle un elemento de la estructura, el paso se hace siguiendo las reglas del tipo del cual sea ese elemento; en el caso de una estructura entera, C la pasa, a no ser que se le indique lo contrario, por valor, y en el caso de un array de estructuras, como todo array, lo pasara por "referencia". Conviene aclarar en este momento que si la estructura posee en su interior un array de elementos, la estructura puede ser pasada por valor a una funci√≥n, pero el array ser√° pasado siempre por referencia. En concreto a la funci√≥n se le pasara por valor un puntero al primer elemento del array. Veamos todo esto en un ejemplo:

struct ALFA{ int a;

char b[20];

};

void PasoDeElementos(int val,char \*cadena) {

`   `val=15;

`   `cadena[7]=‚Äòa‚Äô;

}

void PasoDeLaEstructuraPorValor(struct ALFA a) {

`   `a.val=14;

`   `a.cadena[6]=‚Äòb‚Äô;

}

void PasoDeLaEstructuraPorReferencia(struct ALFA \*a) {

`   `\*(a.val)=13;

`   `\*(a.cadena)[5]=‚Äòc‚Äô;

}

void PasoDeUnArrayDeEstructuras(struct ALFA \*a) {

`   `a[4].val=12;

`   `a[5].cadena[4]=‚Äòd‚Äô;

}

int main(void)

{

struct ALFA a,b[10];

PasoDeElementos(a.val,a.b);    PasoDeLaEstructuraPorValor(a);    PasoDeLaEstructuraPorReferencia(&a);    PasoDeUnArrayDeEstructuras(b);

`   `return 0;

}

En el paso de una estructura por referencia, se ha usado una construcci√≥n *\*(variable\_estructura.nombre\_variable)*, esta construcci√≥n asigna el valor que se desea a esa variable de la estructura, pues *variable\_estructura.nombre\_variable* es un puntero a la variable. El uso de los par√©ntesis es necesario, pues el operador . tiene menor prioridad que el operador \*. Es por ello que C introduce un nuevo operador, el operador ->. Este operador es equivalente al otro, pero m√°s c√≥modo y f√°cil de escribir y de usar. Entonces, podr√≠amos haber escrito la funci√≥n de paso de una estructura por referencia de la forma siguiente:

void PasoDeLaEstructuraPorReferencia(struct ALFA \*a) {

`   `a->val=13;

`   `a->cadena[5]=‚Äòc‚Äô;

}

2. **- Campos de bit.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Un campo de bit es un m√©todo predefinido por C para poder acceder a un bit de un byte. Aunque dicho acceso siempre es posible mediante operaciones el uso de los operadores sobre bits, explicados con anterioridad, el uso de campos de bit puede a√±adir claridad al programa.

El m√©todo de declaraci√≥n de un campo de bit se basa en la estructura, pues un campo de bit no es mas que un tipo especial de estructura. El formato de declaraci√≥n de un campo de bit es:

struct nombre\_campo\_bit{

`   `tipo nombre1 : longitud;

`   `tipo nombre2 : longitud;    ...

`   `tipo nombreN : longitud; }variables\_campo\_bit;

El *tipo* de un campo de bit debe declararse como *unsigned int* o *signed int*. Veamos un ejemplo de declaraci√≥n de un campo de bit:

struct ALFA{

unsigned a : 1;

signed b : 2;

unsigned : 4;

unsigned c : 1; }campo;

En dicho ejemplo, se declara un campo de bit de tama√±o 4 al cual no se le da nombre, eso es valido, y su efecto es que esos cuatro bits no podr√≠an ser referenciados.

Es posible mezclar en la declaraci√≥n elementos normales de estructura con elementos de campo de bit. Veamos un ejemplo:

struct EMP{

`   `char nombre[20],apellido[2][20];    float sueldo;

`   `unsigned vacaciones:1;

`   `unsigned enfermo:1;

};

3. **- Uniones.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

En C una uni√≥n es una posici√≥n de memoria que se usa por varias variables similares, que pueden ser de tipos diferentes. La definici√≥n de uni√≥n es:

union nombre\_union{ tipo nombre1;

`   `tipo nombre2; ...

`   `tipo nombreN; }var\_union;

Como puede observarse su declaraci√≥n, etc., es parecida a la declaraci√≥n de una estructura. Sin embargo, en una uni√≥n, todos los tipos de datos comparten la misma direcci√≥n de memoria. As√≠, si declaramos:

union ALFA{

int a;

char b; }alfa;

Tendremos:

<------alfa.a------>

Byte0    Byte1 <-alfa.b->

Por lo tanto, *b* tendr√° en com√∫n con *a* el byte m√°s bajo. Un ejemplo mas √∫til de una uni√≥n es el siguiente:

union BETA{

unsigned short a; char b[2];

};beta

Entonces *beta.b[0]* contendr√° el byte bajo de *beta.a*, y *beta.b[1]* contendr√° el byte alto de *beta.a*. Ello permite acceder a la parte alta o baja de dicho *unsigned short* sin necesidad de usar operadores sobre bits.

4. **- Enumeraciones.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Una enumeraci√≥n es un conjunto de constantes enteras con nombre y especifica todos los valores legales que pueden tener unas variables. Las enumeraciones se declaran de la siguiente forma:

enum nombre\_enum{lista\_de\_enumeraci√≥n} lista\_de\_variables;

Donde, al igual que en las estructuras, puede no aparecer *nombre\_enum*  o *lista\_de\_variables*. Veamos un ejemplo de enumeraci√≥n:

enum MONEDAS{ peseta, duro, diez, cinco, cincuenta, cien, doscientas, quinientas} monedas\_espana;

Las enumeraciones asignan una constante entera a cada uno de los s√≠mbolos de la enumeraci√≥n, empezando por el valor *0*. Esto puede modificarse colocando en la declaraci√≥n el valor que deseamos tengan los elementos a partir de uno dado. Esto se realiza de la siguiente forma:

enum CURSO{ primero, segundo, tercero, cuarto\_t=100, quinto\_t, cuarto\_e=200, quinto\_e};

En este caso, las constantes *primero*, *segundo* y *tercero* tienen los valores *0*,*1* y *2*, las constantes cuarto\_t y quinto\_t los valores *100* y 101, y las constantes *cuarto\_e* y *quinto\_e* los valores *200* y *201* respectivamente.

5. **- La palabra reservada typedef.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

El lenguaje C permite mediante el uso de la palabra reservada *typedef* definir nuevos nombres para los tipos de datos existentes, esto no debe confundirse con la creaci√≥n de un nuevo tipo de datos. La palabra clave *typedef* permite solo asignarle un nuevo nombre a un tipo de datos ya existente. La sintaxis general de uso de *typedef* es:

typedef tipo nombre;

Donde *tipo* es cualquier tipo de datos permitido, y *nombre* es el nuevo nombre que se desea tenga ese tipo. Veamos algunos ejemplos:

typedef int entero;

typedef struct{

unsigned codigo;

char nombre[40];    char apellido[40]; }cliente;

Y entonces podr√≠an crearse nuevas variables de la forma:

entero a; cliente b,\*c;

**Tema 9 - El preprocesador.**

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

En un programa escrito en C, es posible incluir diversas instrucciones para el compilador dentro del c√≥digo fuente del programa. Estas instrucciones dadas al compilador son llamadas directivas del preprocesador y, aunque realmente no son parte del lenguaje C, expanden el √°mbito del entorno de programaci√≥n de C.

El preprocesador, definido por el standard ANSI de C, contiene las siguientes directivas:



|#if|#ifdef|#ifndef|#else|
| - | - | - | - |
|#elif|#endif|#include|#define|
|#undef|#line|#error|#pragma|

*Tabla 9.1: Directivas del preprocesador en C.*

1. **- Directiva #define.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La directiva define se usa para definir un identificador y una cadena que el compilador sustituir√° por el identificador cada vez que se encuentre en el archivo fuente. El standard ANSI llama al identificador "nombre de macro" y al proceso de sustituci√≥n "sustituci√≥n de macro". Por ejemplo:

#define TRUE 1 #define FALSE 0

El compilador, cada vez que vea el identificador *TRUE*, lo sustituir√° por el valor *1*, e igual con *FALSE*. El uso mas com√∫n de la directiva *#define* es la definici√≥n de valores constantes en el programa, tama√±os de arrays, etc.

Una caracter√≠stica que posee la directiva *#define* es que el "nombre de macro" puede contener argumentos. Cada vez que el compilador encuentra el "nombre de macro", los argumentos reales encontrados en el programa reemplazan los argumentos asociados con el nombre de macro. Veamos un ejemplo:

#define MIN(a,b) (a<b) ? a : b

Si tenemos ahora en el programa:

printf("El valor m√≠nimo es: %d\n",MIN(10,20));

El compilador sustituye el "nombre de macro" y sus argumentos en tiempo de compilaci√≥n, y ello equivale a haber escrito el c√≥digo:

printf("El valor m√≠nimo es: %d\n",(10<20) ? 10 : 20);

2. **- Directiva #undef.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La directiva *#undef* permite quitar una definici√≥n de "nombre de macro" que se realizo con anterioridad. Veamos un ejemplo:

#define TAM 10 .......

#undef TAM

A partir de *#undef TAM*, el "nombre de macro" *TAM*  deja de existir, ello permite localizar los "nombre de macro" donde sea necesario.

3. **- Directiva #error.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La directiva *#error* fuerza a parar la compilaci√≥n del programa, a la vez que muestra un mensaje de error. El mensaje de error no aparecer√° entre comillas dobles. Veamos un ejemplo:

#error Detenida compilaci√≥n

Su principal uso viene asociado a detener la compilaci√≥n en ciertas condiciones en asociaci√≥n con las directivas *#if*, etc., explicadas con posterioridad.

4. **- Directiva #include.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La directiva *#include* fuerza al compilador a incluir otro archivo fuente en el archivo que tiene la directiva *#include*, y a compilarlo. El nombre del archivo fuente a incluir se colocara entre comillas dobles o entre par√©ntesis de √°ngulo. Por ejemplo:

#include <stdio.h> #include "stdio.h"

Los archivos incluidos mediante *#include*  pueden a su vez poseer otras directivas *#include*. La diferencia existente entre encerrar el archivo entre par√©ntesis de √°ngulo o entre comillas dobles, es que, en el primer caso, se busca el archivo en los directorios de la linea de ordenes de compilaci√≥n, y, despu√©s en los directorios standard de C, pero nunca en el directorio de trabajo; y en el segundo caso el primer sitio donde se busca el archivo a incluir es en el directorio actual de trabajo, pas√°ndose, caso de no haber sido encontrado, a buscar en los mismos sitios que el caso anterior.

5. **- Directivas #if, #ifdef, #ifndef, #else, #elif y #endif.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Las  directivas *#if*, *#ifdef*, *#ifndef*, *#else*, *#elif*  y *#endif*  son  directivas condicionales de compilaci√≥n. Estas directivas permiten decirle al compilador que partes del programa debe compilar bajo distintas condiciones.

La idea general de la directiva *#if* es que si es verdad la expresi√≥n que se encuentra despu√©s del *#if*, se compilara el c√≥digo que figura entre el *#if* y el *#endif* se compilara. La directiva *#else* funciona de igual forma que el *else* del lenguaje C. La directiva *#elif* funciona como el escalonado de *if* del lenguaje C. La definici√≥n formal es:

#if expresi√≥n1

`   `secuencia de sentencias #elif expresi√≥n2

`   `secuencia de sentencias ......

#else

`   `secuencia de sentencias #endif

Veamos algunos ejemplos:

#define MEM 200

#if MEM>100

printf("MEM es mayor de 100"); #endif

#define VALOR 0

#if VALOR==0

`   `c=a\*b/(VALOR+1); #else

`   `c=a\*b/VALOR; #endif

Compilara el c√≥digo para el caso de *VALOR==0*.

#define VALOR 15

#if VALOR<0

`   `b=b/(-VALOR); #elif VALOR==0

`   `b=b/(VALOR+1); #else

b=b/VALOR;

#endif

Compilara el c√≥digo para el √∫ltimo caso.

La directivas *#ifdef* y *#ifndef* se usan tambi√©n para compilaci√≥n condicional, solo que no eval√∫an expresi√≥n alguna, solo comprueba si esta definido (*#ifdef*) o si no esta definido (*#ifndef*) alg√∫n nombre de macro. Su sintaxis general es:

#ifdef nombre de macro

`   `secuencia de sentencias #else

`   `secuencia de sentencias #endif

E igual para *#ifndef*. Veamos algunos ejemplos:

#define VAL 10

#ifdef VAL

printf("VAL definido"); #else

`   `printf("VAL no definido"); #endif

#ifndef NOVAL

`   `printf("NOVAL no definido"); #endif

Compilara el c√≥digo para el caso de *VAL*  definido y, adem√°s, compilara el c√≥digo de *NOVAL*, al no estar definida dicha macro. Como se observa no se comprueba el valor de *VAL*, o el de *NOVAL*, solo se comprueba si est√°n definidos o no.

6. **- Directiva #line.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La directiva *#line*  permite cambiar la cuenta de lineas del compilador y el nombre del archivo. Su sintaxis es:

#line n√∫mero ["nombre de archivo"]

Veamos un ejemplo:

#line 100 /\* Inicializa el contador de lineas a 100 \*/       /\* 10 lineas \*/

#error Detenida compilaci√≥n

Indicara el mensaje de error en la linea *110* del programa, y no en la que suceda 

realmente.

7. **- Directiva #pragma.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La directiva *#pragma*  es una directiva que permite dar instrucciones al compilador sobre como debe realizar la compilaci√≥n del c√≥digo fuente. Su sintaxis es:

#pragma nombre

**Tema 10 - Entrada y salida.**
 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Antes de empezar a explicar la entrada y salida en C, es necesario realizar dos peque√±os comentarios:

En primer lugar, para el correcto funcionamiento de la entrada y salida en C, y dado que las funciones de E/S, estructuras de datos usadas por esas funciones, etc., se encuentran declaradas en el archivo de cabecera *<stdio.h>*, es necesario incluir dicho archivo, mediante la directiva del preprocesador *#include*, para que la E/S funcione 

correctamente, pues en caso contrario, puede funcionar de forma incorrecta, e incluso, puede llegar a dar errores de compilaci√≥n.

En segundo lugar, aparte de la E/S por consola y la E/S de fichero mediante buffer intermedio, que ser√°n explicadas en este tema, existe una E/S de fichero sin buffer intermedio, proveniente de la primitiva implementaci√≥n de C en m√°quinas UNIX., y que el standard ANSI de C no ha estandarizado, por lo cual, no es recomendable su uso. Por este motivo, y dada su similitud en la mayor√≠a de apartados con el sistema de E/S de fichero mediante buffer intermedio, no ser√° explicado en el presente tema.

1. **- Entrada y salida desde consola.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La entrada y salida desde consola se refiere a las operaciones que se producen en el teclado y la pantalla del ordenador. Dichos dispositivos son autom√°ticamente abiertos y cerrados al comenzar y terminar el programa, por lo cual, no deben ser abiertos ni cerrados por el propio programa. Existen, b√°sicamente, seis funciones de entrada y salida desde consola, tres de entrada y tres de salida. Ve√°moslas:

La funci√≥n *getchar()*, lee un car√°cter desde el teclado. Dicha funci√≥n se define 

como:

int getchar(void);

Dicha funci√≥n lee caracteres, de uno en uno, desde el teclado, esperando, para leer los caracteres, la pulsaci√≥n de un retorno de carro. Es por ello que es posible escribir varios caracteres antes de que se ninguno de ellos sea le√≠do. La funci√≥n *getchar()* hace eco en pantalla del car√°cter le√≠do. En caso de error devuelve *EOF*.

La funci√≥n *putchar()* escribe un car√°cter a la pantalla del ordenador. Dicha funci√≥n se define como:

int putchar(int c);

La funci√≥n *putchar()*, si sucede de forma correcta, devuelve el car√°cter escrito. En caso de error devuelve el car√°cter *EOF*.

Veamos un ejemplo de uso de *getchar()* y *putchar()*:

#include <stdio.h>

int main(void) {

char ch;

do

{

ch=getchar(); putchar(ch);

}

while (ch!='e' && ch!='E');

return 0;

}

Este programa lee todas las teclas pulsadas en el teclado, y las coloca en pantalla, hasta leer una *'e'* o una *'E'*. Obs√©rvese que solo lee las teclas despu√©s de pulsar un retorno de carro.

La funci√≥n *gets()* lee un string desde el teclado. La funci√≥n se define como:

char \*gets(char \*s);

La funci√≥n *gets()* lee un string desde el teclado hasta que se pulsa un retorno de carro. El string es almacenado en la variable *s*, y el retorno de carro le√≠do desde el teclado es, autom√°ticamente, reemplazado por un car√°cter de final de string (*'\0'*). Devuelve un puntero a la variable *s* si sucede de forma correcta, y *NULL* en caso contrario. La funci√≥n *gets()*  permite corregir errores de teclado usando la tecla de retroceso antes de pulsar el retorno de carro.

La funci√≥n *puts()* escribe un string en pantalla. La funci√≥n se define como:

int puts(const char \*s);

La funci√≥n *puts()* escribe en pantalla el string almacenado en *s*, y a√±ade al final un retorno de carro. Devuelve un entero no negativo si sucede de forma correcta, y *EOF* en caso de error.

Veamos un ejemplo de uso de *gets()* y *puts()*:

#include <stdio.h> #define TAM 100

int main(void)

{

`   `char cadena[TAM];

`   `puts("Introduce una cadena:");

gets(cadena);

return 0;

}

La funci√≥n *scanf()* se usa para leer cualquier tipo de dato predefinido desde el teclado, y convertirlo, de forma autom√°tica, al formato interno adecuado. La funci√≥n se define como:

int scanf(const char \*formato[,direcci√≥n,...]);

El string *formato*  es la cadena de control que indica los datos a leer. Dicha cadena de control consta de tres clases de caracteres:

- Especificadores de formato.
- Caracteres de espacio en blanco.
- Caracteres que no sean espacios en blanco.

Los especificadores de formato est√°n precedidos por el signo *%*, y dicen a la funci√≥n que tipo de datos van a ser le√≠dos a continuaci√≥n. Los especificadores de formato validos son:



|**Especificado r**|**Descripci√≥n.**|
| :-: | - |
|%c|Leer un √∫nico car√°cter.|
|%d|Leer un entero decimal.|
|%i|Leer un entero decimal.|
|%e|Leer un n√∫mero en punto flotante.|
|%f|Leer un n√∫mero en punto flotante.|
|%g|Leer un n√∫mero en punto flotante.|
|%o|Leer un n√∫mero octal.|
|%s|Leer una cadena de caracteres.|
|%x|Leer un n√∫mero hexadecimal.|
|%p|Leer un puntero.|
|%n|Recibe un valor igual al n√∫mero de car√°cter le√≠dos.|
|%u|Leer un entero sin signo.|

*Tabla 10.1.1: Especificadores de formato de la funci√≥n scanf().*

Adem√°s, es posible utilizar los modificadores *h* (*short*), *l* (*long*)  y *L*. El modificador *h* se puede aplicar a los tipo *d*, *i*, *o*, *u* y *x*, e indica que el tipo de dato es *short int* o *unsigned short int* seg√∫n el caso. El modificador *l* se puede aplicar a los casos anteriores, indicando que el tipo de dato es *long int* o *unsigned long int*, pero, adem√°s, se puede aplicar a los tipos *e*, *f* y *g*, indicando, en tal caso, que el tipo de dato es *double*. Por √∫ltimo, el modificador *L* se puede aplicar a los tipos *e*, *f* y *g*, e indica que el tipo de dato es *long double*.

Los caracteres de espacio en blanco en la cadena de control dan lugar a que *scanf()* lea y salte sobre cualquier n√∫mero (incluido cero) de espacios en blanco. Un espacio en blanco es, adem√°s del car√°cter espacio, un tabulador o un salto de l√≠nea.

Un car√°cter que no sea espacio en blanco da lugar a que *scanf()* lea y elimine el car√°cter asociado. Por ejemplo, *%d:%d*  da lugar a que *scanf()*  lea primero un *int*, 

despu√©s lea, y descarte, los dos puntos, y luego lea otro *int*. Si el car√°cter especificado no se encuentra, *scanf()* termina su ejecuci√≥n.

Todas las variables utilizadas para recibir valores (si son necesarias), deben ser pasadas por "referencia", o sea, por sus direcciones. Esto supone que los argumentos deben ser punteros a las variables.

La presencia del signo \* despu√©s del signo % y antes del c√≥digo del formato produce que *scanf()* lea, pero no asigne el valor le√≠do a ninguna variable. Por ejemplo:

int x,y; scanf("%d%\*c%d",&x,&y);

Provoca que, si la entrada es *10/20*, se le asigne el valor *10* a la variable *x*, se lea, y se descarte el signo */*, y despu√©s se asigne el valor *20* a la variable *y*.

La funci√≥n *scanf()*  devuelve un n√∫mero igual al de campos que han sido asignados correctamente, este n√∫mero no incluye los campos que fueron le√≠dos, pero no asignados, utilizando el modificador \* para eliminar la asignaci√≥n. En caso de error devuelve *EOF*.

La funci√≥n *printf()* se usa para escribir cualquier tipo de dato a la pantalla. Su 

formato es:

int printf(const char \*formato[,argumento,...]);

La cadena apuntada por formato consta de dos tipos de elementos. El primer tipo esta constituido por los caracteres que se mostraran en pantalla. El segundo tipo contiene las ordenes de formato que describen la forma en que se muestran los argumentos. Las ordenes de formato est√°n precedidas por el signo *%* y le sigue el c√≥digo de formato. Estas ordenes de formato son:

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

|**Especificado r**|**Descripci√≥n**|
| :-: | - |
|%c|Car√°cter.|
|%d|Enteros decimales con signo.|
|%i|Enteros decimales con signo.|
|%e|Punto flotante en notaci√≥n cient√≠fica (e min√∫scula).|
|%E|Punto flotante en notaci√≥n cient√≠fica (E may√∫scula).|
|%f|Punto flotante.|
|%g|Usar el m√°s corto de %e y %f.|
|%G|Usar el m√°s corto de %E y %f.|
|%o|Octal sin signo.|
|%s|Cadena de caracteres.|
|%u|Enteros decimales sin signo.|
|%x|Hexadecimales sin signo (letras min√∫sculas).|
|%X|Hexadecimales sin signo (letras may√∫sculas).|
|%p|Mostrar un puntero.|
|%n|El argumento asociado es un puntero a un entero, el cual recibir√° el n√∫mero de caracteres escritos.|
| - | :- |
|%%|Imprimir el signo %.|

*Tabla 10.1.2: Especificadores de formato de la funci√≥n printf().*

Adem√°s, e igual que con la funci√≥n *scanf()*, existen los modificadores *h*, *l* y *L*. Para su uso consultar la funci√≥n *scanf()*.

La funci√≥n *printf()* devuelve el n√∫mero de car√°cteres escritos. En caso de error devuelve el valor *EOF*.

Veamos un ejemplo de uso de las funciones *scanf()* y *printf()*:

#include <stdio.h>

int main(void) {

int a,b;

printf("\nIntroduce el valor de a: "); scanf("%d",&a); printf("\nIntroduce el valor de b: "); scanf("%d",&b);

if (b!=0)

`      `printf("\nEl valor de %d dividido %d es: %f\n",

a,b,(float)a/b);

else

printf("\nError, b vale 0\n");

return 0;

}

2. **- Entrada y salida desde fichero.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Antes de explicar la entrada y salida desde fichero, conviene explicar el tipo de dato *FILE \**. Dicho tipo de dato es el "puntero de fichero", y es, realmente, una estructura que contiene la informaci√≥n sobre el nombre del fichero abierto, su modo de apertura (lectura, escritura, etc.), estado, etc. Dicho "puntero de fichero", por tanto, especifica el fichero que se esta usando y es, la forma que poseen las funciones de entrada y salida desde fichero de conocer sobre que archivo act√∫an.

Sobre un archivo es necesario, antes de poder usarlo, realizar una operaci√≥n, la apertura del mismo; una vez terminado su uso, es necesaria otra operaci√≥n, cerrar el archivo. De esto se encargan dos funciones de C. Dichas funciones son *fopen()*  y *fclose()*. Ve√°moslas con detalle:

La funci√≥n *fopen()* se encarga de abrir un archivo. Su definici√≥n es:

FILE \*fopen(char \*nombre,char \*modo);

Donde *nombre* es un string que contiene el nombre del archivo que queremos leer y *modo* es otro string que contiene el modo de apertura deseado. Dichos modos de apertura son:



|**Modo**|**Descripci√≥n**|
| - | - |
|r|Abrir un archivo para lectura.|
|w|Crear un archivo para escritura.|
|a|Abrir un archivo para a√±adir.|
|rb|Abrir un archivo binario para lectura.|
|wb|Crear un archivo binario para escritura.|
|ab|Abrir un archivo binario para a√±adir.|
|rt|Abrir un archivo de texto para lectura.|
|wt|Crear un archivo de texto para escritura.|
|at|Abrir un archivo de texto para a√±adir.|
|r+|Abrir una archivo para lectura/escritura.|
|w+|Crear un archivo para lectura/escritura.|
|a+|Abrir un archivo para leer/a√±adir.|
|r+b|Abrir un archivo binario para lectura/escritura.|
|w+b|Crear un archivo binario para lectura/escritura.|
|a+b|Abrir un archivo binario para leer/a√±adir.|
|r+t|Abrir un archivo de texto para lectura/escritura.|
|w+t|Crear un archivo de texto para lectura/escritura.|
|a+t|Abrir un archivo de texto para leer/a√±adir.|

*Tabla 10.2.1: Modos de apertura de un fichero con la funci√≥n fopen().*

En todos los casos de a√±adir, si el archivo especificado no existe, se procede a 

crearlo.

Si no se especifica en *modo* si la apertura se realiza para un archivo binario o texto, depender√° de la configuraci√≥n del sistema que la apertura sea en binario o en texto, siendo en la mayor√≠a de los casos en modo texto. La diferencia fundamental entre modo texto y modo binario es que en modo texto, secuencias de lectura tales como retorno de carro/alimentaci√≥n de l√≠nea se traducen en un √∫nico car√°cter nueva l√≠nea, mientras que en modo texto eso no sucede; el efecto contrario sucede en escritura.

La funci√≥n *fopen()*  devuelve un puntero de tipo *FILE*  a la estructura que representa el archivo abierto. En caso de que no pueda abrir o crear el archivo especificado, se devuelve un puntero *NULL*, por lo cual, siempre que se abra un archivo, deber√° comprobarse que el valor devuelto no es *NULL*, y entonces, el c√≥digo deber√° ser:

FILE \*fp;

if ((fp=fopen("prueba","w"))==NULL)

{

`   `puts("\nNo puedo abrir el fichero\n");    exit(1);

}

La funci√≥n *fclose()* cierra un archivo. Su definici√≥n es:

int fclose(FILE \*fp);

Donde *fp* es el puntero al fichero abierto mediante la funci√≥n *fopen()*.

La funci√≥n *fclose()* cierra el archivo, lo cual da lugar a que el buffer de archivo existente en memoria se libere, escribi√©ndose en el fichero si es necesario, adem√°s, libera el bloque de control de archivo, lo cual lo hace disponible para otro archivo (el sistema operativo limita el n√∫mero de ficheros abiertos simult√°neamente).

Un valor devuelto de cero indica que el archivo fue cerrado con √©xito. Cualquier valor distinto de cero indica un error.

Veamos un ejemplo de uso de *fopen()* y *fclose()*:

#include <stdio.h>

int main(int argc,char \*argv[]) {

FILE \*fp;

if (argc!=2)

{

`      `puts("Nombre del fichero no pasado");

return 0;

}

if ((fp=fopen(argv[1],"r"))==NULL)

{

`      `printf("Error abriendo el fichero: %s\n",argv[1]);

return 0;

}

if (fclose(fp))

{

`      `puts("Error cerrando el fichero");       return 1;

`   `}

`   `return 0; }

Una vez abierto un archivo, y hasta que se proceda a cerrarlo es posible leer, escribir, etc., en el, seg√∫n se indique en el modo de apertura. Las principales funciones de lectura y escritura sobre un archivo son:

int getc(FILE \*fp);

int putc(int ch,FILE \*fp);

char \*fgets(char \*str,int n,FILE \*fp);

int fputs(const char \*str,FILE \*fp);

int fscanf(FILE \*fp,const char \*formato[,direcci√≥n,...]); int fprintf(FILE \*fp,const char \*formato[,argumento,...]); int fread(void \*memoria,int num,int cont,FILE \*fp);

int fwrite(void \*memoria,int num,int cont,FILE \*fp);

La funci√≥n *getc()*  lee caracteres del archivo asociado a *fp*. Devuelve *EOF* cuando se alcanza el final del archivo.

La funci√≥n *putc()* escribe el car√°cter *ch* en el archivo asociado a *fp*. Devuelve el car√°cter escrito si funciona de forma correcta, y *EOF* en caso de error.

La funci√≥n *fgets()*  funciona de igual forma que la funci√≥n *gets()*, solo que, adem√°s de leer del fichero asociado a *fp*, el par√°metro *n* indica el n√∫mero m√°ximo de caracteres que se pueden leer. Existe, adem√°s, una sutil diferencia, la funci√≥n *fgets()* no elimina el retorno de carro (si se lee) de la cadena de entrada, sino que lo conserva en la misma,. a√±adiendo a continuaci√≥n de dicho retorno de carro, y de forma autom√°tica, el car√°cter de fin de cadena (*'\0'*).

La funci√≥n *fputs()* funciona igual que la funci√≥n *puts()*, solo que, adem√°s de escribir en el fichero asociado a *fp*, no a√±ade al final del string un retorno de carro, tal y como hacia la funci√≥n *puts()*.

Las funciones *fscanf()* y *fprintf()* funcionan de forma similar a sus equivalentes sobre la consola *scanf()* y *printf()*, solo que leen o escriben del archivo asociado a *fp*.

Las funci√≥n *fread()* permite leer un bloque de datos. Su declaraci√≥n es: int fread(void \*memoria,int num,int cont,FILE \*fp);

Donde *memoria* es un puntero a la zona de memoria donde se almacenaran los datos le√≠dos, *num* es el tama√±o (en bytes) de cada uno de los bloques a leer, *cont* es el n√∫mero de bloques (cada uno de *num* bytes de tama√±o) a leer, y *fp* es el puntero al fichero desde donde se lee.

La funci√≥n *fread()* devuelve el n√∫mero de bloques (no bytes) realmente le√≠dos.

La funci√≥n *fwrite()* es la funci√≥n dual a *fread()*. La funci√≥n *fwrite()* permite escribir un bloque de datos. Su declaraci√≥n es:

int fwrite(void \*memoria,int num,int cont,FILE \*fp);

Donde *memoria* es un puntero a la zona de memoria donde se encuentran los datos a escribir, *num* es el tama√±o (en bytes) de cada uno de los bloques a escribir, *cont* es el n√∫mero de bloques (cada uno de *num* bytes de tama√±o) a escribir, y *fp* es el puntero al fichero desde donde se escribe.

La funci√≥n *fwrite()*  devuelve el n√∫mero de bloques (no bytes) realmente 

escritos.

Un aspecto a resaltar de las funciones *fread()* y *fwrite()* es el hecho de que no realizan ning√∫n tipo de conversi√≥n con los datos le√≠dos o escritos, as√≠ , la secuencia retorno de carro/alimentaci√≥n de l√≠nea, no es convertida en el car√°cter nueva l√≠nea en la escritura,  y  viceversa  para  la  lectura.  Es  por  ello,  que  dichas  funciones  son, generalmente, usadas con archivos abiertos en modo binario.

Veamos un ejemplo de uso de *fread()* y *fwrite()*:

#include <stdio.h> #define TAM 1000

int main(int argc,char \*argv[]) {

FILE \*f\_inp,\*f\_out;

char buffer[TAM];

int num;

if (argc!=3)

return 0;

if ((f\_inp=fopen(argv[1],"rb"))==NULL)

return 0;

if ((f\_out=fopen(argv[2],"wb"))==NULL)

exit(1);

while ((num=fread(buffer,sizeof(char),TAM,f\_inp))!=0)

fwrite(buffer,sizeof(char),num,f\_out);

if (fclose(f\_inp) || fclose(f\_out)

exit(1);

`   `return 0; }

Adem√°s de las funciones de entrada y salida de datos desde archivo, descritas con anterioridad, existen tres funciones que no son de entrada y salida de datos y que conviene explicar. Dichas funciones son:

int ferror(FILE \*fp);

void rewind(FILE \*fp);

int fseek(FILE \*fp,long num,int origen);

La funci√≥n *ferror()* devuelve si durante la √∫ltima operaci√≥n realizada sobre el archivo asociado a *fp* se produjo o no un error. Devuelve el valor cero si no se produjo error, y un valor distinto de cero si se produjo error.

La funci√≥n *rewind()*  posiciona el indicador de posici√≥n del archivo *fp*  al principio del mismo.

La funci√≥n *fseek()*  se usa para operaciones de entrada y salida de acceso aleatorio. La funci√≥n *fseek()* desplaza el indicador de posici√≥n del archivo *fp* un tama√±o *num* desde la posici√≥n especificada por *origen*. Los valores validos para *origen* son:

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

|**Origen**|**Nombre de la constante**|**Valor**|
| - | - | - |
|Comienzo del archivo|SEEK\_SET|0|
|Posici√≥n actual|SEEK\_CUR|1|
|Final del archivo|SEEK\_END|2|

*Tabla 10.2.2: Valores del origen en la funci√≥n fseek().*

La funci√≥n *fseek()* devuelve un valor de cero si funciona correctamente. Un valor distinto de cero indica un error en la √∫ltima operaci√≥n de posicionamiento en el fichero.

La funci√≥n *fseek()* solo funciona correctamente en archivos abiertos en modo binario, pues, dadas las conversiones que se realizan en ciertas transacciones de caracteres en los archivos abiertos en modo texto, se producir√≠an errores en el posicionamiento en el fichero al usar dicha funci√≥n. Veamos un ejemplo de uso de *fseek()*:

#include <stdio.h>

int LeeCaracter(FILE \*fp,long pos,int origen) {

if (fseek(fp,pos,origen))

return(EOF);

return(getc(fp));

}

Antes de terminar este tema, es necesario comentar la existencia de tres ficheros que son abiertos de forma autom√°tica al comenzar la ejecuci√≥n del programa, y cerrados, tambi√©n de forma autom√°tica, al terminar la misma. Estos archivos son la entrada standard (*stdin*), la salida standard (*stdout*) y la salida standard de error (*stderr*). Normalmente estas ficheros est√°n asociados a la consola, pero pueden redireccionarse a cualquier otro dispositivo. Adem√°s, dado que son exactamente igual que ficheros, pueden usarse sus nombres en los mismos lugares que se usan las variables de tipo *FILE \**, por lo cual, cualquier funci√≥n de fichero puede usarse con la consola usando estos archivos standard abiertos al comenzar el programa. Es por ello, que podemos leer, por ejemplo, una cadena desde el teclado de la siguiente forma:

char cadena[100]; fgets(cadena,100,stdin);

Y escribir dicha cadena, por ejemplo en la salida standard de error, de la forma:

fputs(cadena,stderr);

**Tema 11 - Asignaci√≥n din√°mica de memoria.**

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Antes de empezar con el desarrollo del tema, es necesario aclarar que el mismo no pretende explicar las estructuras de datos din√°micas, sino tan solo dar unas ligeras nociones b√°sicas sobre la posibilidad de asignar memoria de forma din√°mica, esto es, en tiempo de ejecuci√≥n, y por tanto de crear nuevas variables.

Las funciones que realizan un manejo activo de la memoria del sistema requieren todas ellas para su correcto funcionamiento la inclusi√≥n, mediante la directiva del prepocesador *#include* del archivo de cabecera *<stdlib.h>*.

1. **- Reserva din√°mica de memoria.**

En C, la reserva din√°mica de memoria se realiza mediante el uso de funciones, existen varias funciones de reserva de memoria (ver ap√©ndice A), pero aqu√≠ solo explicaremos la reserva din√°mica de memoria mediante la funci√≥n *malloc()*. La funci√≥n *malloc()* tiene la forma:

void \*malloc(unsigned num\_bytes);

Siendo *num\_bytes*  el n√∫mero de bytes que se desean reservar. La funci√≥n *malloc()* devuelve un puntero al tipo de datos *void* (sin tipo). Dicho puntero puede ser asignado a una variable puntero de cualquier tipo base mediante una conversi√≥n forzada de tipo de datos (casts). Veamos un ejemplo:

int \*a;

a=(int \*)malloc(sizeof(int));

Y ahora podr√≠amos realizar la siguiente asignaci√≥n:

\*a=3;

La funci√≥n *malloc()*, y en general, cualquier funci√≥n de reserva din√°mica de memoria, devuelve un puntero nulo (*NULL*) si la reserva de memoria no puede realizarse, generalmente por falta de memoria disponible. Por ello, antes de usar un puntero devuelto por la funci√≥n *malloc()*  o por cualquier otra funci√≥n de reserva din√°mica de memoria es imprescindible, con el fin de evitar posibles fallos en la ejecuci√≥n del programa, comprobar que dicho puntero no es nulo (*NULL*). Veamos algunos ejemplos de reserva din√°mica de memoria:

float \*a;

a=(float \*)malloc(sizeof(float));

if (a==NULL) exit(0); /\* Salimos del programa \*/

unsigned long int\*b;

if ((b=(unsigned long int)malloc(sizeof(unsigned long int)))==NULL)

exit(0); /\* Salimos del programa \*/

struct ALFA{

unsigned a;

float b;

int \*c;

}\*d;

if ((d=(struct ALFA \*)malloc(sizeof(struct ALFA)))==NULL)

exit(0); /Salimos del programa \*/

2. **- Liberaci√≥n din√°mica de memoria.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La memoria din√°mica reservada es eliminada siempre al terminar la ejecuci√≥n del programa por el propio sistema operativo. Sin embargo, durante la ejecuci√≥n del programa puede ser interesante, e incluso necesario, proceder a liberar parte de la memoria reservada con anterioridad y que ya ha dejado de ser necesario tener reservada. Esto puede realizarse mediante la funci√≥n *free()*. La funci√≥n *free()* tiene la forma:

void free(void \*p);

Donde *p* es la variable de tipo puntero cuya zona de memoria asignada de forma din√°mica queremos liberar. Veamos un ejemplo de liberaci√≥n de memoria:

int \*a;

if ((a=(int \*)malloc(sizeof(int)))==NULL)

exit(0); /\* Salimos del programa \*/ ......

free(a);

Un aspecto a tener en cuenta es el hecho de que el puntero a liberar no debe apuntar a nulo (*NULL*), pues en tal caso se producir√° un fallo en el programa. Es por ello que cobra a√∫n m√°s sentido la necesidad de comprobar al reservar memoria de forma din√°mica que la reserva se ha realizado de forma correcta, tal y como se explico en el apartado anterior.

3. **-  Ejemplo  de  asignaci√≥n  y  liberaci√≥n  din√°mica  de memoria.**

    [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Vamos a ver un sencillo ejemplo pr√°ctico de como asignar y liberar memoria. Para ello construiremos las funciones necesarias para crear, manejar y liberar de forma din√°mica una lista ligada.

En primer lugar, definiremos la estructura de datos necesaria para ello. Esta estructura de datos es:

struct LISTA{

`   `tipo dato;

`   `struct LISTA \*sig; };

Donde *tipo* es cualquier tipo de datos valido (*float*, *int*, *long int*, etc.)

Las variables necesarias para crear la lista son las siguientes:

struct LISTA \*cabeza=NULL,\*p; tipo dato;

El c√≥digo de la funci√≥n de creaci√≥n de la lista, con inserci√≥n por la cabeza:

struct LISTA \*CrearLista(struct LISTA \*cabeza,tipo dato) {

`   `struct LISTA \*p;

if ((p=(struct LISTA \*)malloc(sizeof(struct LISTA)))==NULL)

exit(0); /\* Salimos del programa \*/

`   `p->dato=dato;

`   `p->sig=cabeza;

`   `return p;

}

Siendo la llamada para la creaci√≥n de la forma: cabeza=CrearLista(cabeza,dato);

La funci√≥n para obtener un elemento de la lista es:

struct LISTA \*BuscarLista(struct LISTA \*p,tipo dato) {

while (p!=NULL && p->dato!=dato)

p=p->sig;

return p;

}

Siendo la llamada de la forma:

if ((p=BuscarLista(cabeza,dato))!=NULL)    /\* El elemento ha sido encontrado \*/

Y por √∫ltimo, la funci√≥n para liberar un elemento de la memoria es:

struct LISTA \*LiberarLista(struct LISTA \*cabeza,tipo dato) {

`   `struct LISTA **p,**q;

`   `if (cabeza!=NULL)

`   `{

`      `p=cabeza;

`      `if (cabeza->dato==dato)          cabeza=cabeza->sig;

else

while (p!=NULL && p->dato!=dato) {

q=p;

p=p->sig;

}

if (p!=NULL)

{

q->sig=p->sig; free(p);

}

}

return cabeza;

}

Siendo la llamada: cabeza=LiberarLista(cabeza,dato);

**Ap√©ndice A - Funciones de biblioteca del** 

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

**standard ANSI de C.**

Antes de comenzar a describir las funciones de biblioteca del standard ANSI de C, unos peque√±os comentarios:

Existen muchas mas funciones de las aqu√≠ descritas, pero este peque√±o conjunto de funciones es lo suficientemente amplio como para que puedan realizarse todas las operaciones necesarias.

Las funciones se encuentran clasificadas de acuerdo a la funci√≥n que realizan (entrada/ salida de datos, etc.), con el fin de facilitar su uso.

Las funciones se presentan de la siguiente forma:

Nombre de la funci√≥n: *fclose*

Fichero de includes donde se encuentra su prototipo: *#include <stdio.h>* Formato de la funci√≥n: *int fclose(FILE \*f);*

Breve descripci√≥n de la funci√≥n.

**A.1 - Funciones de entrada y salida de datos.** fclose

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

#include <stdio.h> int fclose(FILE \*f);

La funci√≥n *fclose()* cierra el archivo asociado a la variable *f* y vuelca su buffer al disco. Despu√©s de un *fclose()*, la variable *f* queda desligada del archivo y cualquier buffer que tuviera asignado se libera. Si *fclose()* se ejecuta de forma correcta, devuelve el valor cero, en cualquier otro caso devuelve un valor distinto de cero.

feof

#include <stdio.h> int feof(FILE \*f);

La  funci√≥n *feof()*  comprueba  el  indicador  de  posici√≥n  del  archivo  para determinar si se ha alcanzado el final del archivo asociado a *f*. Un valor distinto de cero supone que el indicador de posici√≥n del archivo esta en el final del mismo, en caso contrario se devuelve el valor cero.

ferror

#include <stdio.h> int ferror(FILE \*f);

La funci√≥n *ferror()*** comprueba si existen errores en alguna operaci√≥n realizada sobre el archivo asociado a *f***.** Un valor devuelto de cero indica que no hay errores, un valor distinto de cero indica la existencia de errores. Los indicadores de error asociados a *f*  permanecen activos hasta que se cierra el archivo o se llama a las funciones *rewind()* o *perror()*.

fflush

#include <stdio.h> int fflush(FILE \*f);

La funci√≥n *fflush()* vac√≠a el buffer asociado a la variable *f*. Si el archivo ha sido abierto para escritura, *fflush()* vac√≠a el contenido del buffer de salida en el archivo. Si el archivo ha sido abierto para lectura, *fflush()* tan solo vac√≠a el contenido del buffer de entrada. Un valor de cero indica que el buffer se ha vaciado de forma correcta, un valor distinto de cero indica un error. Todos los buffers se vuelcan autom√°ticamente cuando un programa termina de forma correcta, cuando est√°n llenos, o cuando se cierra el archivo (ver *fclose()*).

fgetc

#include <stdio.h> int fgetc(FILE \*f);

La funci√≥n *fgetc()* devuelve el car√°cter del archivo de entrada asociado a *f*, e incrementa el indicador de posici√≥n del archivo. El car√°cter se lee como *unsigned char* y se convierte a *int*, por lo cual no existe ning√∫n problema en asignarle el valor devuelto por *fgetc()* a una variable de tipo car√°cter (*char*).

fgets

#include <stdio.h>

char \*fgets(char \*cad,int num,FILE \*f);

La funci√≥n *fgets()*  lee como m√°ximo hasta *num-1*  caracteres del archivo asociado a *f*** y los sit√∫a en el array apuntado por *cad*. Los caracteres se leen hasta que se recibe un car√°cter de salto de linea, un *EOF* (fin de fichero) o hasta que se llega al limite especificado. Despu√©s de le√≠dos los caracteres, se pone autom√°ticamente un car√°cter de nulo inmediatamente despu√©s del ultimo car√°cter le√≠do. Si se termina la lectura por un car√°cter de salto de linea, dicho car√°cter se guarda como parte de *cad*. Si 

tiene √©xito, *fgets()* devuelve un puntero a la direcci√≥n de *cad*. En caso de error devuelve un puntero nulo (*NULL*).

fopen

#include <stdio.h>

FILE \*fopen(const char \*nombre,const char \*modo);

La funci√≥n *fopen()*  abre un archivo cuyo nombre viene dado por *nombre*  y devuelve un puntero a una estructura de tipo *FILE* que se le asocia en la apertura. El  tipo de operaciones permitidas en el archivo est√°n definidas por el valor de *modo*. Los valores permitidos de *modo* son:

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

|**Modo**|**Descripci√≥n**|
| - | - |
|r|Abrir un archivo para lectura.|
|w|Crear un archivo para escritura.|
|a|Abrir un archivo para a√±adir.|
|rb|Abrir un archivo binario para lectura.|
|wb|Crear un archivo binario para escritura.|
|ab|Abrir un archivo binario para a√±adir.|
|rt|Abrir un archivo de texto para lectura.|
|wt|Crear un archivo de texto para escritura.|
|at|Abrir un archivo de texto para a√±adir.|
|r+|Abrir una archivo para lectura/escritura.|
|w+|Crear un archivo para lectura/escritura.|
|a+|Abrir un archivo para leer/a√±adir.|
|r+b|Abrir un archivo binario para lectura/escritura.|
|w+b|Crear un archivo binario para lectura/escritura.|
|a+b|Abrir un archivo binario para leer/a√±adir.|
|r+t|Abrir un archivo de texto para lectura/escritura.|
|w+t|Crear un archivo de texto para lectura/escritura.|
|a+t|Abrir un archivo de texto para leer/a√±adir.|

*Tabla A.1.1: Modos de apertura de un fichero con la funci√≥n fopen().*

Si *fopen()* tiene √©xito en abrir el archivo, devuelve un puntero de tipo *FILE*, en caso contrario devuelve un puntero nulo (*NULL*).

fprintf

#include <stdio.h>

int fprintf(FILE \*f,const char \*formato,...);

La funci√≥n *fprintf()*  escribe en el archivo asociado a *f*  los valores de los argumentos que componen su lista de argumentos seg√∫n se especifica en la cadena *formato*. Devuelve un n√∫mero que indica el n√∫mero de caracteres escritos. Si se produce un error se devuelve un valor negativo. Para una explicaci√≥n sobre sus argumentos cons√∫ltese la funci√≥n *printf()*.

fputc

#include <stdio.h>

int fputc(int c,FILE \*f);

La  funci√≥n *fputc()*  escribe el car√°cter especificado por *c*  en el  archivo especificado por *f* a partir de la posici√≥n actual del archivo, y entonces incrementa el indicador de posici√≥n del archivo. Aunque *c* tradicionalmente se declara de tipo *int*, es convertido por *fputc()* a *unsigned char*, por lo cual en lugar de un *int* se puede usar como argumento un *char* o *unsigned char*. Si se utiliza un *int*, la parte alta del mismo 

ser√° ignorada y no se escribir√°. Si se ejecuta de forma correcta, *fputc()* devuelve el valor *c*, en caso de error devuelve el valor *EOF*.

fputs

#include <stdio.h>

int fputs(const char \*cad,FILE \*f);

La funci√≥n *fputs()* escribe el contenido de la cadena de caracteres apuntada por *cad* en el archivo especificado por *f*. El car√°cter nulo de terminaci√≥n de la cadena no es escrito. En caso de error *fputs()* devuelve el valor *EOF*.

fread

#include <stdio.h>

int fread(void \*buf,size\_t tam,sise\_t cuenta, FILE \*f);

La funci√≥n *fread()* lee *cuenta* numero de elementos, cada uno de ellos de *tam* bytes de longitud, del archivo asociado a la variable *f*, y los sit√∫a en el array apuntado por *buf*. El indicador de posici√≥n del archivo se incrementa en el n√∫mero de bytes le√≠dos. La funci√≥n *fread()* devuelve el n√∫mero de elementos realmente le√≠dos. Si se leen menos elementos de los pedidos en la llamada se produce un error. La funci√≥n *fread()* 

funciona de forma correcta en archivos abiertos en modo binario; en archivos abiertos en modo texto, pueden producirse ciertos cambios de caracteres (salto de carro seguido de salto de linea se convierte en salto de linea, etc.).

fscanf

#include <stdio.h>

int fscanf(FILE \*f,const char \*formato,...);

La funci√≥n *fscanf()* lee del archivo asociado a la variable *f*** de igual forma que la funci√≥n *scanf()* lo realiza del teclado. Devuelve el numero de argumentos a los que realmente se asigna valores. Este n√∫mero no incluye los campos ignorados. Si se produce un error antes de realizar la primera asignaci√≥n se devuelve el valor *EOF*. Para mas informaci√≥n consultar la funci√≥n *scanf()*.

fseek

#include <stdio.h>

#int fseek(FILE \*f,long desp,int origen);

La funci√≥n *fseek()* coloca el indicador de posici√≥n del archivo asociado a la variable *f*** de acuerdo a los valores dados por *origen* y *desp*. Su objetivo es dar soporte a las operaciones de E/S de acceso directo. El valor de *origen* debe ser una de estas constantes, definidas en *stdio.h*:

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

|**Origen**|**Nombre de la constante**|**Valor**|
| - | - | - |
|Comienzo del archivo|SEEK\_SET|0|
|Posici√≥n actual|SEEK\_CUR|1|
|Final del archivo|SEEK\_END|2|
| - | - | - |

*Tabla A.1.2: Valores del origen en la funci√≥n fseek().*

La funci√≥n *fseek()* devuelve un valor de cero si sucede correctamente, en caso contrario el valor devuelto es distinto de cero.

Puede utilizarse *fseek()* para mover el indicador de posici√≥n en el archivo a cualquier lugar del mismo, incluso mas alla del final del mismo, pero es un error intentar situarse antes del comienzo del archivo.

ftell

#include <stdio.h> long ftell(FILE \*f);

La funci√≥n *ftell()* devuelve el valor actual del indicador de posici√≥n del archivo asociado a la variable *f*. Para archivos binarios, el valor devuelto es el n√∫mero de bytes desde el principio del archivo. Para archivos de texto solo debe usarse como argumento para la funci√≥n *fseek()*, ya que, debido a que secuencias de caracteres como retorno de carro y salto de l√≠nea pueden sustituirse por un salto de l√≠nea, el tama√±o aparente del archivo puede variar. Si falla la funci√≥n *ftell()* devuelve el valor *-1L*.

fwrite

#include <stdio.h>

int fwrite(const void \*buf,size\_t tam,size\_t cuenta,FILE \*f);

La funci√≥n *fwrite()* escribe *cuenta* numero de elementos, cada uno de ellos de *tam* bytes de longitud, del array apuntado por *buf* al archivo asociado a la variable *f***.** El indicador de posici√≥n del archivo se incrementa en el n√∫mero de bytes escritos. La funci√≥n *fwrite()* devuelve el n√∫mero de elementos realmente escritos. Si se escriben menos elementos de los pedidos en la llamada se produce un error. La funci√≥n *fwrite()* funciona de forma correcta en archivos abiertos en modo binario; en archivos abiertos en modo texto, pueden producirse ciertos cambios de caracteres (salto de carro seguido de salto de linea se convierte en salto de linea, etc.).

getc

#include <stdio.h> int getc(FILE \*f);

La funci√≥n *getc()*** devuelve del archivo de entrada asociado a la variable *f* el siguiente car√°cter desde la posici√≥n actual e incrementa el indicador de posici√≥n del archivo. El car√°cter se lee como *unsigned char* y se transforma en un *int*. Si se alcanza el final de archivo devuelve el car√°cter *EOF*. Debido a que *EOF* es un valor valido para  archivos  abiertos en modo  binario,  debe  utilizarse la funci√≥n *feof()*  para comprobar el final del fichero en dichos archivos.

gets

#include <stdio.h>

char \*gets(char \*cad);

La funci√≥n *gets()* lee caracteres desde *stdin* (entrada standard, normalmente el teclado), y los sit√∫a en el array de caracteres apuntado por *cad*. Se leen caracteres hasta que se recibe un car√°cter de salto de l√≠nea o una marca de *EOF*. El car√°cter de terminaci√≥n se transforma, autom√°ticamente, en el car√°cter nulo para terminar la cadena. Si se ejecuta correctamente, *gets()* devuelve un puntero a *cad*. En caso de error se devuelve un puntero nulo (*NULL*). No existe l√≠mite al n√∫mero de caracteres que leer√° *gets()*, por lo cual le corresponde al programador asegurarse de que no se sobrepasa el tama√±o del array apuntado por *cad*.

perror

#include <stdio.h>

int perror(const char \*cad);

La funci√≥n *perror()* convierte el valor de la variable global *errno* en una cadena de caracteres y escribe esta cadena en *stderr* (salida standard de error). Si el valor de *cad* no es nulo (*NULL*), se escribe primero la cadena apuntada por *cad*, seguida de dos puntos y el mensaje de error asociado.

printf

#include <stdio.h>

int printf(const char \*formato,...);

La funci√≥n *printf()* escribe en *stdout* (salida standard, generalmente la pantalla), los argumentos que componen la lista de argumentos bajo el control de la cadena apuntada por *formato*. La cadena apuntada por *formato*  consta de dos tipos de elementos. El primer tipo esta constituido por los caracteres que se mostraran en pantalla. El segundo tipo contiene las ordenes de formato que describen la forma en que se muestran los argumentos. Una orden de formato comienza por el signo *%*, y le sigue el c√≥digo de formato. Las ordenes de formato son:

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

|**Especificador**|**Descripci√≥n**|
| - | - |
|%c|Car√°cter.|
|%d|Enteros decimales con signo.|
|%i|Enteros decimales con signo.|
|%e|Punto flotante en notaci√≥n cient√≠fica (e min√∫scula).|
|%E|Punto flotante en notaci√≥n cient√≠fica (E may√∫scula).|
|%f|Punto flotante.|
|%g|Usar el m√°s corto de %e y %f.|
|%G|Usar el m√°s corto de %E y %f.|
|%o|Octal sin signo.|
|%s|Cadena de caracteres.|
|%u|Enteros decimales sin signo.|
|%x|Hexadecimales sin signo (letras min√∫sculas).|



|%X|Hexadecimales sin signo (letras may√∫sculas).|
| - | - |
|%p|Mostrar un puntero.|
|%n|El argumento asociado es un puntero a un entero, el cual recibir√° el n√∫mero de caracteres escritos.|
|%%|Imprimir el signo %.|

*Tabla A.1.3: Especificadores de formato de la funci√≥n printf().*

Existen ademas los modificadores *h*  (*short*), *l*  (*long*) y *L*. El modificador *h* (*short*) se puede aplicar a los tipos *d*, *i*, *o*, *u*., *x* y *X*, y le dice que el tipo de datos es *short int* o *unsigned short int* seg√∫n el caso. El modificador *l* (*long*), se puede aplicar a los casos anteriores, significando que el tipo de datos es *long int* o *unsigned long int*, pero, adem√°s, se puede aplicar a los tipos *e*, *E*, *f* y *g*, indicando que el tipo de datos es *double*. El modificador *L* se puede aplicar a los tipos *e*, *E*, *f* y *g*, y dice que el tipo de datos es *long double*.

La funci√≥n *printf()* devuelve el n√∫mero de caracteres realmente escritos. Un valor negativo indica que se ha producido un error. 

putc

#include <stdio.h>

int putc(int c,FILE \*f);

La funci√≥n *putc()* escribe el car√°cter contenido en el byte menos significativo de **c**  en el archivo apuntado por *f*. Dado que los argumentos de tipo *char*  son transformados en argumentos de tipo *int*  en el momento de la llamada, se pueden 

utilizar variables de tipo *char*  para el argumento *c*  de *putc()*. La funci√≥n *putc()* devuelve el car√°cter escrito. En caso de error devuelve *EOF*, y, dado que *EOF* es un valor valido en archivos abiertos en modo binario, se recomienda en dicho tipo de archivos el uso de la funci√≥n *ferror()* para la comprobaci√≥n de errores.

puts

#include <stdio.h> int puts(char \*cad);

La funci√≥n *puts()* escribe la cadena apuntada por *cad* en el dispositivo de salida standard. El car√°cter nulo de terminaci√≥n de cadena se transforma en un car√°cter de salto de l√≠nea. Si tiene √©xito, se devuelve un valor no negativo. En caso de error se devuelve el valor *EOF*.

rewind

#include <stdio.h> void rewind(FILE \*f);

La funci√≥n *rewind()* mueve el indicador de posici√≥n del archivo apuntado por *f* al principio del mismo. La funci√≥n *rewind()* inicializa tambi√©n los indicadores de error y de fin de archivo asociados a la variable *f*. Ning√∫n valor es devuelto.

scanf

#include <stdio.h>

int scanf(const char \*formato,...);

La funci√≥n *scanf()*  es una rutina de prop√≥sito general que lee de *stdin* (dispositivo standard de entrada, normalmente el teclado). Puede leer los tipos de datos que haya y transformarlos en el formato interno adecuado. Es la inversa de la funci√≥n *printf()*. La cadena de control especificada por *formato*  consiste en tres clases de caracteres:

- Especificadores de formato.
- Caracteres de espacio en blanco.
- Caracteres que no sean espacios en blanco.

Los especificadores de formato de entrada est√°n precedidos por el signo *%*, y dicen a *scanf()* que tipo de datos van a ser le√≠dos a continuaci√≥n. Los especificadores de formato validos son:

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

|**Especificador**|**Descripci√≥n.**|
| - | - |
|%c|Leer un √∫nico car√°cter.|
|%d|Leer un entero decimal.|
|%i|Leer un entero decimal.|
|%e|Leer un n√∫mero en punto flotante.|
|%f|Leer un n√∫mero en punto flotante.|
|%g|Leer un n√∫mero en punto flotante.|
|%o|Leer un n√∫mero octal.|
|%s|Leer una cadena de caracteres.|
|%x|Leer un n√∫mero hexadecimal.|
|%p|Leer un puntero.|
|%n|Recibe un valor igual al n√∫mero de car√°cter le√≠dos.|
|%u|Leer un entero sin signo.|

*Tabla A.1.4: Especificadores de formato de la funci√≥n scanf().*

Adem√°s, es posible utilizar los modificadores *h* (*short*), *l* (*long*) y *L* de igual forma que en la funci√≥n *printf()*.

Un espacio en blanco en la cadena de control da lugar a que *scanf()* salte sobre uno o mas espacios de la cadena de entrada, un espacio en blanco puede ser un espacio, un tabulador o un salto de l√≠nea. Adem√°s, un espacio en blanco da lugar, tambi√©n, a que *scanf()* lea, pero no guarde cualquier n√∫mero de espacios en blanco, incluso cero.

Un car√°cter que no sea espacio en blanco, da lugar a que *scanf()* lea y elimine el car√°cter asociado. Por ejemplo, *%d:%d*  da lugar a que *scanf()*  lea primero un *int*, despu√©s lea, y descarte, los dos puntos, y luego lea otro *int*. Si el car√°cter especificado no se encuentra, *scanf()* termina su ejecuci√≥n.

Todas las variables utilizadas para recibir valores a trav√©s de *scanf()* deben ser pasadas por referencia, o sea, por sus direcciones. Esto supone que los argumentos deben ser punteros a las funciones.

La presencia del signo *\** despu√©s del signo *%* y antes del c√≥digo del formato, produce que *scanf()* lea, pero no asigne el valor le√≠do a ninguna variable, por ejemplo:

*scanf("%d%\*c%d",&x,&y);*

Provoca, si la entrada es *10/20*, que se le asigne el valor *10* a la variable *x*, se lea y descarte el signo */*, y despu√©s se asigne el valor *20* a la variable *y*.

La funci√≥n *scanf()*  devuelve un n√∫mero igual al de campos que han sido asignados correctamente, este n√∫mero no incluye los campos que fueron le√≠dos, pero no asignados, utilizando el modificador *\** para eliminar la asignaci√≥n.

setbuf

#include <stdio.h>

void setbuf(FILE \*f, char \*buf);

La funci√≥n *setbuf()* se utiliza para determinar el buffer del archivo asociado a la variable *f* que se utilizara, o bien, si se llama con *buf* a nulo (*NULL*), para desactivar el buffer. Si un buffer va a ser definido por el programador, su tama√±o debe ser *BUFSIZ*, siendo *BUFSIZ* una constante definida en el archivo *stdio.h*. La funci√≥n *setbuf()* no devuelve ning√∫n valor.

setvbuf

#include <stdio.h>

int setvbuf(FILE \*f,char \*buf,int modo,.size\_t tam);

La funci√≥n *setvbuf()* permite al programador especificar el buffer, el tama√±o y el modo para el archivo asociado a la variable *f*. El array de caracteres apuntado por *buf* se utiliza como buffer de *f* para las operaciones de entrada y salida. Si *buf* es nulo (*NULL*), *setvbuf()* creara su propio buffer, de tama√±o *tam*, mediante una llamada a la funci√≥n *malloc()*. El tama√±o del buffer se fija mediante el valor de *tam*, que debe ser siempre mayor de cero. La variable *modo* determina el uso del buffer. Los valores legales de *modo*, definidos en *stdio.h*, son:

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

|**Modo**|**Descripci√≥n**|
| - | - |
|\_IOFBF|Modo normal, el buffer se vac√≠a solo cuando se llena (en escritura), o bien, cuando ya se ha le√≠do todo su  contenido (en lectura).|
|\_IOLBF|Igual al anterior, solo que el buffer tambi√©n se vac√≠a cuando se lee o escribe un retorno de carro.|
|\_IONBF|Desactiva el buffer.|

*Tabla A.1.5: Valores del modo en la funci√≥n setvbuf().*

La funci√≥n *setvbuf()* devuelve un valor de cero si se ejecuta con √©xito. En caso de error, un valor distinto de cero ser√° devuelto.

sprintf

#include <stdio.h>

int sprintf(char \*buf,const char \*formato,...);

La funci√≥n *sprintf()*  es id√©ntica a la funci√≥n *printf()*, excepto que la salida generada se sit√∫a en el array apuntado por *buf*. El valor devuelto por la funci√≥n es igual al n√∫mero de caracteres realmente situados en el array. Para una mayor explicaci√≥n refi√©rase a la funci√≥n *printf()*.

sscanf

#include <stdio.h>

int sscanf(const char \*buf,const char \*formato,...);

La funci√≥n *sscanf()* es id√©ntica a la funci√≥n *scanf()*, excepto que los datos son le√≠dos del array apuntado por *buf*. El valor devuelto por la funci√≥n es igual al n√∫mero de campos que hubieran sido realmente asignados. Este n√∫mero no incluye los campos que fueron saltados al utilizar el modificador de ordenes de formato *\**. Para m√°s detalles vea la funci√≥n *scanf()*.

ungetc

#include <stdio.h>

int ungetc(int c,FILE \*f);

La funci√≥n *ungetc()*  devuelve el car√°cter especificado por el byte menos significativo de *c*  al archivo especificado por *f*. Este car√°cter ser√° devuelto en la siguiente operaci√≥n de lectura sobre el archivo. Una llamada a *fflush()* o a *fseek()* deshace una operaci√≥n *ungetc()*  y deshecha el car√°cter previamente devuelto a la 

secuencia de entrada. No se debe usar *ungetc()* sobre una marca de *EOF*. El valor devuelto por la funci√≥n es igual a *c*, si la funci√≥n ha tenido √©xito, e igual a *EOF*, si ha fallado.

**A.2 -Funciones de caracteres.** isalnum

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

#include <ctype.h> int isalnum(int ch);

La funci√≥n *isalnum()* devuelve un valor distinto de cero si *ch* es una letra del alfabeto o un d√≠gito. En caso contrario, se devuelve un valor distinto de cero.

isalpha

#include <ctype.h> int isalpha(int ch);

La funci√≥n *isalpha()* devuelve un valor distinto de cero si *ch* es una letra del alfabeto, en cualquier otro caso devuelve cero.

iscntrl

#include <ctype.h> int iscntrl(int ch);

La funci√≥n *iscntrl()* devuelve un valor distinto de cero si *ch* se encuentra entre *0* y *0x1F* o si *ch* es igual a *0x7F* (tecla DEL), en cualquier otro caso devuelve cero.

isdigit

#include <ctype.h> int isdigit(int ch);

La funci√≥n *isdigit()* devuelve un valor distinto de cero si *ch* es un d√≠gito (*0..9*), en cualquier otro caso devuelve el valor cero.

isgraph

#include <ctype.h> int isgraph(int ch);

La funci√≥n *isgraph()*  devuelve un valor distinto de cero si *ch*  es cualquier car√°cter imprimible distinto del espacio, en cualquier otro caso devuelve cero.

islower

#include <ctype.h> int islower(int ch);

La funci√≥n *islower()* devuelve un valor distinto de cero si *ch* es una car√°cter min√∫scula, en cualquier otro caso devuelve cero.

isprint

#include <ctype.h> int isprint(int ch);

La funci√≥n *isprintf()*  devuelve un valor distinto de cero si *ch*  es cualquier car√°cter imprimible, incluyendo el espacio, en cualquier otro caso devuelve cero.

ispunct

#include <ctype.h>

int ispunct(int ch);

La funci√≥n *ispunct()* devuelve un valor distinto de cero si *ch* es un car√°cter de puntuaci√≥n, excluyendo el espacio, en cualquier otro caso devuelve el valor cero.

isspace

#include <ctype.h> int isspace(int ch);

La funci√≥n *isspace()* devuelve un valor distinto de cero si *ch* es un espacio, tabulador, o car√°cter de salto de l√≠nea, en cualquier otro caso devuelve el valor cero.

isupper

#include <ctype.h> int isupper(int ch);

La funci√≥n *isupper()*  devuelve un valor distinto de cero si *ch*  es una letra may√∫scula, en cualquier otro caso devuelve cero.

isxdigit

#include <ctype.h>

int isxdigit(int ch);

La funci√≥n *isxdigit()*  devuelve un valor distinto de cero si *ch*  es un d√≠gito hexadecimal, en cualquier otro caso devuelve cero. Un d√≠gito hexadecimal est√° en uno de estos rangos: *0* hasta *9*, *A* hasta *F* y *a* hasta *f*.

tolower

#include <ctype.h> int tolower(int ch);

La funci√≥n *tolower()* devuelve el equivalente en min√∫scula de *ch*, si *ch* es una letra may√∫scula, en cualquier otro caso se devuelve *ch* sin modificar.

toupper

#include <ctype.h> int toupper(int ch);

La funci√≥n *toupper()* devuelve el equivalente en may√∫sculas de *ch*, si *ch* es una letra min√∫scula, en cualquier otro caso se devuelve *ch* sin modificar.

**A.3 - Funciones de cadenas.** memchr

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

#include <string.h>

void \*memchr(const void \*buffer,int ch,size\_t cuenta);

La funci√≥n *memchr()*  busca en *buffer*  la primera ocurrencia de *ch*  en los primeros *cuenta* caracteres. La funci√≥n devuelve un puntero a la primera ocurrencia del car√°cter *ch* en *buffer*. Si no encuentra ch, devuelve un puntero nulo (*NULL*).

memcmp

#include <string.h>

int memcmp(const void \*buf1,const void \*buf2,size\_t cuenta);

La funci√≥n *memcmp()* compara los primeros cuenta caracteres de los arrays apuntados por *buf1* y *buf2*. La comparaci√≥n se hace lexicogr√°ficamente. La funci√≥n devuelve un entero que es interpretado seg√∫n se indica a continuaci√≥n:



|**Valor devuelto**|**Descripci√≥n**|
| - | - |
|Menor que cero|buf1 es menor que buf2|
|Igual a cero|buf1 es igual a buf2|
|Mayor que cero|buf1 es mayor que buf2|

*Tabla A.3.1: Interpretaci√≥n de los valores devueltos por la funci√≥n memcmp().*

memcpy

#include <string.h>

void \*memcpy(void \*hacia,const void \*desde,size\_t cuenta);

La funci√≥n *memcpy()* copia *cuenta* caracteres del array apuntado por *desde* en el array apuntado por *hacia*. Si los arrays se superponen, el comportamiento de *memcpy()* queda indefinido. La funci√≥n devuelve un puntero a *hacia*.

memset

#include <string.h>

void \*memset(void \*buf,int ch,size\_t cuenta);

La funci√≥n *memset()* copia el byte menos significativo de *ch* en los primero *cuenta* caracteres del array apuntado por *buf*. Devuelve *buf*. Su uso m√°s com√∫n es inicializar una regi√≥n de memoria con alg√∫n valor conocido.

strcat

#include <string.h>

char \*strcat(char \*cad1,const char \*cad2);

La funci√≥n *strcat()* concatena una copia de *cad2* en *cad1*, y a√±ade al final de *cad1* un car√°cter nulo (*'\0'*). El car√°cter nulo de terminaci√≥n, que originalmente ten√≠a *cad1*, es sustituido por el primer car√°cter de *cad2*. La cadena *cad2* no se modifica en esta operaci√≥n. La funci√≥n *strcat()* devuelve *cad1*.

strchr

#include <string.h>

char \*strchr(char \*cad,int ch);

La funci√≥n *strchr()* devuelve un puntero a la primera ocurrencia del byte menos significativo de *ch* en la cadena apuntada por *cad*. Si no sucede, devuelve un puntero nulo (*NULL*).

strcmp

#include <string.h>

int strcmp(const char \*cad1,const char \*cad2);

La funci√≥n *strcmp()* compara lexicogr√°ficamente dos cadenas que finalizan con el car√°cter nulo, y devuelve un entero que se interpreta de la siguiente forma:

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

|**Valor devuelto**|**Descripci√≥n**|
| - | - |
|Menor que cero|cad1 es menor que cad2|
|Igual a cero|cad1 es igual a cad2|
|Mayor que cero|cad1  es  mayor  que cad2|

*Tabla A.3.2: Interpretaci√≥n de los valores devueltos por la funci√≥n strcmp().*

strcpy

#include <string.h>

char \*strcpy(char \*cad1,const char \*cad2);

La funci√≥n *strcpy()* se utiliza para copiar el contenido de *cad2* en *cad1*. El elemento *cad2* debe ser un puntero a una cadena que finalice con un car√°cter nulo. La funci√≥n devuelve un puntero a *cad1*.

strlen

#include <string.h>

unsigned int strlen(char \*cad);

La funci√≥n *strlen()* devuelve el n√∫mero de caracteres de la cadena apuntada por *cad* que finaliza con un car√°cter nulo. El car√°cter nulo no se contabiliza.

strtok

#include <string.h>

char \*strtok(char \*cad1,const char \*cad2);

La funci√≥n *strtok()* devuelve un puntero a la siguiente palabra de la cadena apuntada por *cad1*. Los caracteres que constituyen la cadena apuntada por *cad2* son los delimitadores que identifican la palabra. Devuelve un puntero nulo (*NULL*) cuando no existe ninguna palabra que devolver.

La primera vez que se llama a *strtok()* se utiliza realmente *cad1* en la llamada. Las llamadas posteriores utilizan un puntero nulo (*NULL*) como primer argumento.

La funci√≥n *strtok()* modifica la cadena apuntada por *cad1*, pues, cada vez que se encuentra una palabra, se pone un car√°cter nulo donde esta el delimitador. De esta forma *strtok()* puede continuar avanzando por la cadena.

**A.4 - Funciones matem√°ticas.** acos

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

#include <math.h> double acos(double arg);

La funci√≥n *acos()* devuelve el arcocoseno de *arg*. El argumento de *acos()* debe estar en el rango de *-1* a *1*, en cualquier otro caso se produce un error de dominio.

asin

#include <math.h> double asin(double arg);

La funci√≥n *asin()* devuelve el arcoseno de *arg*. El argumento de *asin()* debe estar en el rango de *-1* a *1*, en cualquier otro caso se produce un error de dominio.

atan

#include <math.h> double atan(double arg);

La funci√≥n *atan()* devuelve el arcotangente de *arg*.

atan2

#include <math.h>

double atan2(double y,double x);

La funci√≥n *atan2()*  devuelve el arcotangente de *y/x*. Utiliza el signo de sus argumentos para obtener el cuadrante del valor devuelto.

ceil

#include <math.h> double ceil(double num);

La funci√≥n *ceil()*  devuelve el menor entero mayor o igual que *num*  y lo representa como *double*. Por ejemplo, dado *1.02*, *ceil()* devuelve *2.0*, dado *-1.02*, *ceil()* devuelve *-1.0*.

cos

#include <math.h> double cos(double arg);

La funci√≥n *cos()* devuelve el coseno de *arg*. El valor de *arg* debe venir dado en 

radianes.

cosh

#include <math.h> double cosh(double arg);

La funci√≥n *cosh()* devuelve el coseno hiperb√≥lico de *arg*. El valor de *arg* debe venir dado en radianes.

exp

#include <math.h> double exp(double arg);

La funci√≥n *exp()* devuelve el n√∫mero *e* elevado a la potencia de *arg*.

fabs

#include <math.h> double fabs(double num);

La funci√≥n *fabs()* devuelve el valor absoluto de *num*.

floor

#include <math.h> double floor(double num);

La funci√≥n *floor()* devuelve el mayor entero, representado como *double*, que no es mayor que *num*. Por ejemplo, dado *1.02*, *floor()* devuelve *1.0*, dado *-1.02*, *floor()* devuelve *-2.0*.

fmod

#include <math.h>

double fmod(double x,double y);

La funci√≥n *fmod()* devuelve el resto de la divisi√≥n entera *x/y*.

log

#include <math.h> double log(double num);

La funci√≥n *log()* devuelve el logaritmo neperiano de *num*. Se produce un error de dominio si *num* es negativo, y un error de rango si el argumento es cero.

log10

#include <math.h>

double log10(double num);

La funci√≥n *log10()* devuelve el logaritmo en base *10* de *num*. Se produce un error de dominio si *num* es negativo, y un error de rango si el argumento es cero.

pow

#include <math.h>

double pow(double base,double exp);

La funci√≥n *pow()* devuelve *base* elevada a *exp*. Se produce un error de dominio si *base*  es cero y *exp*  es menor o igual a cero. Tambi√©n puede ocurrir si *base*  es negativo y *exp* no es entero. Un desbordamiento produce un error de rango.

sin

#include <math.h> double sin(double arg);

La funci√≥n *sin()* devuelve el seno de *arg*. El valor de *arg* debe venir dado en 

radianes.

sinh

#include <math.h> double sinh(double arg);

La funci√≥n *sinh()* devuelve el seno hiperb√≥lico de *arg*. El valor de *arg* debe venir dado en radianes.

sqrt

#include <math.h> double sqrt(double num);

La funci√≥n *sqrt()* devuelve la ra√≠z cuadrada de *num*. Si se llama con un n√∫mero negativo, se produce un error de dominio.

tan

#include <math.h> double tan(double arg);

La funci√≥n *tan()* devuelve la tangente de *arg*. El valor de *arg* debe venir dado en 

radianes.

tanh

#include <math.h> double tanh(double arg);

La funci√≥n *tanh()* devuelve la tangente hiperb√≥lica de *arg*. El valor de *arg* debe venir dado en radianes.

**A.5 - Asignaci√≥n din√°mica de memoria.** calloc

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

#include <stdlib.h>

void \*calloc(size\_t num,size\_t tam);

La funci√≥n *calloc()* asigna memoria para un array de *num* objetos, cada uno de los cuales tiene tama√±o *tam*. La memoria asignada es inicializada con el valor cero. La funci√≥n *calloc()* devuelve un puntero al primer byte de la regi√≥n asignada. Si no existe memoria libre suficiente para satisfacer la petici√≥n, se devuelve un puntero nulo (*NULL*).

free

#include <stdlib.h> void free(void \*ptr);

La funci√≥n *free()*  libera la memoria apuntada por *ptr*, haciendo que dicha memoria este disponible para futuras asignaciones. Solo se debe llamar a *free()* con un puntero que haya sido previamente asignado utilizando alguna funci√≥n de asignaci√≥n din√°mica.

malloc

#include <stdlib.h>

void \*malloc(size\_t tam);

La funci√≥n *malloc()*  devuelve un puntero al primer byte de una regi√≥n de memoria de tama√±o *tam* que se encuentra libre. Si no existe memoria suficiente para satisfacer la petici√≥n, se devuelve un puntero nulo (*NULL*).

realloc

#include <stdlib.h>

void \*realloc(void \*ptr,size\_t tam);

La funci√≥n *realloc()* cambia el tama√±o de la memoria apuntada por *ptr* al que esta especificado por *tam*. El valor de *tam* puede ser mayor o menor que el original. Devuelve un puntero al nuevo bloque de memoria, ya que puede ser necesario que *realloc()* traslade el bloque de posici√≥n al incrementar su tama√±o. Si esto sucede, el contenido del antiguo bloque se copia en el nuevo bloque, por lo cual, la informaci√≥n no se pierde.

Si *ptr* es un puntero nulo (*NULL*), *realloc()* simplemente asigna *tam* bytes de memoria y devuelve un puntero a dicha memoria. Si *tam* es cero, la memoria asignada se libera. Si no existe memoria suficiente para satisfacer la petici√≥n, *realloc()* devuelve un puntero nulo (*NULL*), y el bloque de memoria original se deja sin cambiar.

**A.6 - Funciones varias.** abs

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

#include <stdlib.h> int abs(int num);

La funci√≥n *abs()* devuelve el valor absoluto del entero dado por *num*.

atof

#include <stdlib.h>

double atof(const char \*cad);

La funci√≥n *atof()* convierte la cadena apuntada por *cad* en un valor de tipo *double*. La cadena debe contener un n√∫mero valido en coma flotante. En caso contrario el valor devuelto es indefinido.

El n√∫mero puede terminar por cualquier car√°cter que no pueda formar parte de un n√∫mero v√°lido en coma flotante. Esto incluye espacios en blanco, signos de puntuaci√≥n distintos del punto, y caracteres que no sean *E* o *e*. As√≠ si se llama a *atof()* con la cadena *"100.00HOLA"*, devolver√° el valor *100.00*.

atoi

#include <stdlib.h>

int atoi(const char \*cad);

La funci√≥n *atoi()* convierte la cadena apuntada por *cad* en un valor de tipo *int*. La cadena debe contener un n√∫mero entero valido. Si no es este el caso, el valor devuelto es  indefinido,  aunque, la  mayor√≠a  de implementaciones de la funci√≥n devuelven el valor cero.

El n√∫mero puede acabar con cualquier car√°cter que no pueda formar parte de un n√∫mero entero. Esto incluye espacios en blanco, signos de puntuaci√≥n, y cualquier car√°cter que no sea la *E* o la *e*. Esto supone que si se llama a *atoi()* con la cadena *"123.23"*, devolver√° el valor *123*.

atol

#include <stdlib.h>

long int atol(const char \*cad);

La funci√≥n *atol()* convierte la cadena apuntada por *cad* en un valor de tipo *long int*. Para m√°s informaci√≥n consultar la funci√≥n *atoi()*.

exit

#include <stdlib.h> void exit(int estado);

La funci√≥n *exit()***  da lugar inmediatamente a la terminaci√≥n normal de un programa. El valor de *estado*  se pasa al proceso que llamo a este programa, normalmente el sistema operativo, si el entorno lo soporta. Por convenio, si el valor de *estado* es cero, se supone que se ha producido una terminaci√≥n normal del programa. Un valor distinto de cero puede utilizarse para indicar un error definido por la implementaci√≥n.

labs

#include <stdlib.h> long labs(long num);

La funci√≥n *labs()* devuelve el valor absoluto de *num*.

system

#include <stdlib.h>

int system(const char \*cad);

La funci√≥n *system()*  pasa la cadena apuntada por *cad*  como una orden al procesador de ordenes del sistema operativo. Si se llama a *system()* con un puntero nulo (*NULL*), devuelve un valor distinto de cero si est√° presente un procesador de  ordenes, en otro caso, se devuelve un valor distinto de cero. Si *cad* no es un puntero nulo (*NULL*), *system()*  devuelve el valor cero si la orden ha sido correctamente ejecutada, y un valor distinto de cero en caso contrario.

El lenguaje de programaci√≥n C

**Ap√©ndice B: Ejemplos de programas en C.**

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

En este ap√©ndice se incluyen algunos programas de ejemplo escritos en lenguaje C. Los programas han sido realizados de forma que puedan ser compilados en la mayor√≠a de compiladores existentes para los sistemas operativos MS-DOS y UNIX sin que exista la necesidad de realizar ning√∫n tipo de cambio en los mismos.

**B.1 - palindro.c.**

/\* Programa que calcula si una palabra es palindroma, esto es, se lee igual de derecha a izquierda que de izquierda a derecha. \*/![](Aspose.Words.ae55ca77-bd47-4be1-a802-7483922c91a3.006.png)

#include <stdio.h> #include <string.h>

#define TAM 100

/\* Rutina que calcula si una palabra es palindroma. Parametros: char \*cadena Puntero al string con la palabra. Return: int 0 no palindroma, <>0 palindroma. \*/

int Palindroma(char \*cadena) {

`   `register int i,j;

`   `i=0;

`   `j=strlen(cadena)-1;

`   `while (i<j && cadena[i]==cadena[j])

{

i++;

j--;

}

return (i>=j);

}

int main(void)

{

`   `char cadena[TAM];

`   `printf("\nIntroduce la palabra\n");    gets(cadena);

`   `printf("La palabra: %s %s palindroma.\n",cadena,       (Palindroma(cadena)) ? "es" : "no es");

return 0;

}

**B.2 - matriz.c.**

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

/\* Programa que calcula el producto de dos matrices. \*/ #include <stdio.h>![](Aspose.Words.ae55ca77-bd47-4be1-a802-7483922c91a3.007.png)

/\* Definicion del tama√±o maximo \*/ #define TAM 10

/\* Definicion de los codigos de error \*/ #define OK 0

#define ERROR 1

/\* Definicion de la estructura de datos \*/ struct MATRIZ

{

unsigned fila,columna;

float matriz[TAM][TAM];

};

/\* Rutina que muestra un menu y pide una opcion del menu. Parametros: Ninguno. Return: char Opcion del menu elegida. \*/

char Menu(void) {

`   `register char d;

`   `printf("\nElige la opcion deseada:\n");    printf("\t0 -- Salir del programa.\n");    printf("\t1 -- Cambiar la matriz A.\n");    printf("\t2 -- Cambiar la matriz B.\n");    printf("\t3 -- Calcular A\*B\n");

`   `printf("\t4 -- Calcular B\*A\n");

while ((d=getchar())<'0' || d>'4');

return d;

}

/\* Rutina que pide el numero de filas o de columnas de una matriz. Parametros: char \*cadena Puntero al string a mostrar.

Return: unsigned Numero de filas o de columnas. \*/

unsigned PedirTamano(const char \*cadena) {

unsigned valor;

do

{

printf("%s",cadena);       scanf("%u",&valor);

`   `}

`   `while (valor==0 || valor>TAM);    return valor;

}

/\* Rutina que cambia una matriz.

Parametros: struct MATRIZ \*a Puntero a la matriz que vamos a cambiar. Return: Ninguno. \*/

void PedirMatriz(struct MATRIZ \*a) {

register unsigned i,j;

float valor;

`   `a->fila=PedirTamano("\nNumero de filas de la matriz: ");

`   `a->columna=PedirTamano("\nNumero de columnas de la matriz: \n");

for(i=0;i<a->fila;i++)

for(j=0;j<a->columna;j++)

`      `{

`         `printf("M[%u][%u]: ",i,j);

`         `scanf("%f",&valor);

`         `a->matriz[i][j]=valor;

`      `}

}

/\* Rutina que multiplica dos matrices. Las matrices se pasan por puntero pues ello es mas rapido, aunque no se modifican en toda la funcion.

Parametros: struct MATRIZ \*a Puntero a la estructura con la primera matriz a multiplicar.

`            `struct MATRIZ \*b Puntero a la estructura con la segunda matriz a multiplicar.

`            `struct MATRIZ \*res Puntero a la estructura que contendra el resultado.

Return: int Codigo de error. \*/

int Multiplicar(const struct MATRIZ \*a,const struct MATRIZ \*b,struct MATRIZ \*res)

{

register unsigned i,j,k;

if (a->columna!=b->fila)

`      `return ERROR;

`   `res->fila=a->fila;

`   `res->columna=b->columna;

for(i=0;i<a->fila;i++)

for(j=0;j<b->columna;j++)

{

res->matriz[i][j]=0;

for(k=0;k<a->fila;k++) res->matriz[i][j]+=a->matriz[i][k]\*b->matriz[k][j];

}

return OK;

}

/\* Rutina que muestra en pantalla el resultado de la operacion. Parametros: struct MATRIZ \*res Puntero a la estructura con el resultado.

Return: Ninguno. \*/

void Mostrar(const struct MATRIZ \*res) {

register unsigned i,j;

for(i=0;i<res->fila;i++)

{

`      `for(j=0;j<res->columna;j++)

`         `printf("Res[%u][%u]= %f\n",i,j,res->matriz[i][j]);       printf("\nPulsa Enter para continuar.\n");       getchar();

`   `}

}

int main(void)![](Aspose.Words.ae55ca77-bd47-4be1-a802-7483922c91a3.009.png)

{

`   `struct MATRIZ a,b,res;    char d;

`   `a.fila=a.columna=b.fila=b.columna=1;    a.matriz[0][0]=b.matriz[0][0]=1.0;

do

switch(d=Menu())

{

case '0':break;

case '1':PedirMatriz(&a);

break;

case '2':PedirMatriz(&b);

break;

case '3':

if (Multiplicar(&a,&b,&res)==ERROR)

`               `printf("\nNo es posible multiplicar A\*B\n");

else

Mostrar(&res);

break;

case '4':

`            `if (Multiplicar(&b,&a,&res)==ERROR)

`               `printf("\nNo es posible multiplicar B\*A\n");

else

Mostrar(&res);

break;

}

while (d!='0'); return 0;

}

**B.3 - ordenar.c.**

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

/\* Programa que ordena un fichero de cualquier tama√±o mediante el algoritmo QuickSort. El fichero contiene como primer elemento un unsigned con el numero de elementos del fichero, y a continuacion figuran todos los elementos a ordenar \*/![](Aspose.Words.ae55ca77-bd47-4be1-a802-7483922c91a3.010.png)

#include <stdio.h> #include <stdlib.h>

/\* Rutina que lee el fichero de datos y devuelve un puntero al array de la memoria reservada.

Parametros: char \*nombre Nombre del fichero a leer.

`            `unsigned \*num Puntero al unsigned que contendra el numero de elementos del array. Return: float \* Puntero al array de float, NULL si sucede un error. \*/

float \*LeerFichero(const char \*nombre, unsigned \*num) {

FILE \*fp;

float \*p;

register unsigned i;

if ((fp=fopen(nombre,"rt"))==NULL)

{

`      `printf("\nError, no puedo abrir el fichero: %s\n",nombre);

return NULL;

}

fscanf(fp,"%u\n",num);

if ((p=(float \*)calloc(\*num,sizeof(float)))==NULL)

{

`      `printf("\nError, memoria insuficiente.\n");

fclose(fp);

return NULL;

}

for(i=0;i<\*num;i++)

fscanf(fp,"%f\n",&p[i]);

fclose(fp);

return p;

}

/\* Rutina que escribe el fichero de datos ordenado.

Parametros: char \*nombre Nombre del fichero donde guardar los datos.             unsigned num Numero de elementos del array.

`            `float \*p Puntero al array ordenado.

Return: Ninguno. \*/

void GuardarFichero(const char \*nombre,const unsigned num,const float \*p)

{

FILE \*fp;

register unsigned i;

if ((fp=fopen(nombre,"wt"))==NULL)

{

`      `printf("\nError, no puedo crear el fichero: %s\n",nombre);

return;

}

fprintf(fp,"%u\n",num);

for(i=0;i<num;i++)

fprintf(fp,"%f\n",p[i]);

fclose(fp);

}

/\* Rutina que ordena un array segun el algoritmo Quick-Sort. Parametros:   float \*p Puntero al array a ordenar.

`              `unsigned izq Elemento de la izquierda a ordenar.               unsigned der Elemento de la derecha a ordenar. Return:   Ninguno. \*/

void QuickSort(float \*p,unsigned izq,unsigned der) {

register unsigned i=izq,j=der;

float val,inter;

val=p[(i+j)/2];

do

{

while (p[i]<val) i++; while (p[j]>val) j--; if (i<=j)

{![](Aspose.Words.ae55ca77-bd47-4be1-a802-7483922c91a3.011.png)

inter=p[i]; p[i]=p[j]; p[j]=inter;

i++;

j--;

}

}

while (i<=j);

if (izq<j) QuickSort(p,izq,j); if (i<der) QuickSort(p,i,der); return;

}

int main(int argc,char \*argv[]) {

float \*p;

unsigned num;

if (argc!=3)

`   `{

`      `printf("\nModo de uso: %s <fichero1> <fichero2>\n",argv[0]);

return(1);

}

if ((p=LeerFichero(argv[1],&num))==NULL)

return 1;

QuickSort(p,0,num-1);

GuardarFichero(argv[2],num,p);

free(p);

return 0;

}

**B.4 - fichero.c.**

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

/\* Programa que maneja una peque√±a base de datos directamente sobre el fichero \*/![](Aspose.Words.ae55ca77-bd47-4be1-a802-7483922c91a3.012.png)

#include <stdio.h> #include <string.h>

/\* Definicion de las constantes del programa \*/ #define TAM 30

#define TAM\_BUFFER 10

/\* Definicion de los codigos de error \*/ #define OK 0

#define ERROR 1

/\* Definicion de las estructuras de datos del programa \*/ struct FICHA

{

unsigned long dni;

char nombre[TAM];

`   `char apellido[2][TAM];

};

/\* Rutina que muestra un menu en pantalla. Parametros: Ninguno. Return: char Opcion elegida. \*/

char Menu(void) {

`   `register char d;

`   `printf("\nElige una opcion:\n");

`   `printf("\t0 -- Salir del programa.\n");

`   `printf("\t1 -- Insertar un nuevo elemento.\n");

`   `printf("\t2 -- Buscar un elemento por su dni.\n");

`   `printf("\t3 -- Buscar un elemento por su apellido.\n");

while ((d=getchar())<'0' || d>'3');

return d;

}

/\* Rutina que muestra un elemento en pantalla.

Parametros: struct FICHA \*ficha Puntero a la estructura con los datos a mostrar.

Return: Ninguno. \*/

void Mostrar(const struct FICHA \*ficha)

{

`   `printf("\n\nDNI: %lu\n",ficha->dni);

`   `printf("NOMBRE: %s\n",ficha->nombre);

`   `printf("PRIMER APELLIDO: %s\n",ficha->apellido[0]);    printf("SEGUNDO APELLIDO: %s\n",ficha->apellido[1]);    printf("\nPulsa Enter para continuar\n");    getchar();

}

/\* Rutina que busca un elemento dado su dni.

Parametros: FILE \*fichero Puntero al fichero de trabajo.

`            `unsigned long dni Numero de dni a buscar.

`            `char opcion Opcion de ejecucion, 1 mostrar, 0 no mostrar. Return: int Codigo de error. \*/

int BuscarDni(FILE \*fichero,const unsigned long dni,const char opcion) {

struct FICHA ficha;

fseek(fichero,0L,SEEK\_SET);

while (fread(&ficha,sizeof(struct FICHA),1,fichero)==1)

if (dni==ficha.dni)

{

if (opcion)

Mostrar(&ficha);

Return OK;

}

`   `return ERROR;

}

/\* Rutina que busca por apellidos.

Parametros: FILE \*fichero Puntero al fichero de trabajo.             char \*apellido Apellido a buscar.

Return: int Codigo de error.\*/

int BuscarApellido(FILE \*fichero,char \*apellido) {

struct FICHA ficha;

char encontrado=0;

fseek(fichero,0L,SEEK\_SET);

while (fread(&ficha,sizeof(struct FICHA),1,fichero)==1) if (!strcmp(apellido,ficha.apellido[0]) ||

`         `!strcmp(apellido,ficha.apellido[1]))

`      `{

`         `Mostrar(&ficha);

`         `encontrado=1;

`      `}

`   `return (encontrado) ? OK : ERROR;

}

/\* Rutina que inserta un nuevo elemento en el fichero. Parametros: FILE \*fichero Puntero al fichero de trabajo.

`            `struct FICHA \*ficha Puntero a la ficha a insertar. Return: int Codigo de error. \*/

int Insertar(FILE \*fichero,const struct FICHA \*ficha) {

`   `if (BuscarDni(fichero,ficha->dni,0)!=ERROR)

`      `return ERROR;

`   `fseek(fichero,0L,SEEK\_END);

fwrite(ficha,sizeof(struct FICHA),1,fichero);

return OK;

}

/\* Rutina que pide los datos de una ficha.

Parametros: struct FICHA \*ficha Puntero a la ficha que contendra los datos.

`            `char opcion Opcion de ejecucion (0..2).

Return: struct FICHA \* Puntero a la ficha que contiene los datos. \*/

struct FICHA \*PedirDatos(struct FICHA \*ficha, const char opcion)

{

switch(opcion)

{

case 0: printf("\nDNI: ");

scanf("%lu",&ficha->dni); fflush(stdin);

break;

case 1: fflush(stdin);

printf("APELLIDO: ");          strupr(gets(ficha->apellido[1]));

break;

case 2: printf("\nDNI: ");

scanf("%lu",&ficha->dni); fflush(stdin);

printf("NOMBRE: ");

strupr(gets(ficha->nombre));

printf("PRIMER APELLIDO: ");          strupr(gets(ficha->apellido[0]));

`         `printf("SEGUNDO APELLIDO: ");          strupr(gets(ficha->apellido[1]));

82
El lenguaje de programaci√≥n C

break; }![](Aspose.Words.ae55ca77-bd47-4be1-a802-7483922c91a3.013.png)

return ficha;

}

int main(int argc,char \*argv[]) {

FILE \*fichero;

struct FICHA ficha;

register char d;

if (argc!=2)

{

printf("\nModo de uso: %s <fichero>\n",argv[0]);

return 1;

}

if ((fichero=fopen(argv[1],"a+b"))==NULL)

{

`      `printf("\nError creando el fichero: %s\n",argv[1]);

return 1;

}

if (setvbuf(fichero,NULL,\_IOFBF,

TAM\_BUFFER\*sizeof(struct FICHA))!=0)

{

`      `printf("\nError creando el buffer para %d elementos.\n",

TAM\_BUFFER);

fclose(fichero);

return 1;

}

do

switch(d=Menu())

{

case '0':break;

case '1':if (Insertar(fichero,PedirDatos(&ficha,2))==ERROR)                      printf("\nNumero de dni duplicado.\n");             break;

`         `case '2':PedirDatos(&ficha,0);

`            `if (BuscarDni(fichero,ficha.dni,1)==ERROR)

`               `printf("\nDni no existente.\n");

`            `break;

`         `case '3':PedirDatos(&ficha,1);

`            `if (BuscarApellido(fichero,ficha.apellido[1])==ERROR)

`               `printf("\nApellido inexistente.\n");

break;

}

while (d!='0');

fclose(fichero);

return 0;

}

**B.5 - arbol.c.**

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

/\* Programa que lee las palabras de un fichero y las almacena en un arbol binario \*/![](Aspose.Words.ae55ca77-bd47-4be1-a802-7483922c91a3.014.png)

#include <stdio.h>


El lenguaje de programaci√≥n C

#include <ctype.h> #include <string.h> #include <stdlib.h>

/\* Definicion de la longitud maxima de una palabra \*/ #define TAM 30

/\* Definicion de las estructuras de datos del programa \*/ struct ARBOL

{

char pal[TAM+1];

struct ARBOL \*izq,\*der;

};

/\* Rutina que lee una palabra del fichero.

Parametros: FILE \*fichero Puntero al fichero de donde se leen las palabras.

`            `char \*cadena Array de caracteres donde almacenar las palabras.

Return: char \* Puntero a la cadena con la palabra leida, NULL si error. \*/

char \*LeerPalabra(FILE \*fichero,char \*cadena) {

register char d,i=0;

while ((d=fgetc(fichero))!=EOF && !isalpha(d));

if (d==EOF)

return NULL;

do

cadena[i++]=d;

while (i<TAM && (isalpha(d=fgetc(fichero)) || isdigit(d) || 

d=='\_'));

cadena[i]='\0';

`   `return cadena;

}

/\* Rutina que crea el arbol binario, leyendo para ello el fichero. Parametros: char \*nombre Nombre del fichero a leer.

Return: struct ARBOL \* Puntero a la raiz del arbol creado, NULL si error. \*/

struct ARBOL \*LeerFichero(char \*nombre) {

`   `FILE \*fichero;

`   `char cadena[TAM+1],insertado;

int val;

struct ARBOL \*cab=NULL,\*p,\*q;

if ((fichero=fopen(nombre,"rt"))==NULL)

`   `{

`      `printf("\nError, no puedo leer el fichero: %s\n",nombre);       return(NULL);

`   `}

`   `while (LeerPalabra(fichero,cadena)!=NULL)

{

if ((q=(struct ARBOL \*)malloc(sizeof(struct ARBOL)))==NULL) {

`         `printf("\nError reservando memoria.\n");

fclose(fichero);

return NULL;

}

`      `strcpy(q->pal,cadena);

q->izq=q->der=NULL;

if (cab==NULL)

cab=q;

else

{

p=cab;

insertado=0;

while (!insertado)

if ((val=strcmp(cadena,p->pal))<0)

if (p->izq==NULL)

{

`                  `p->izq=p; insertado=1;

}

else

p=p->izq; else

if (val>0)

if (p->der==NULL) {

p->der=q; insertado=1;

}

else

p=p->der; else

insertado=1;

}

} fclose(fichero); return cab;

}

/\* Rutina que muestra por pantalla el arbol ordenado a la vez que libera la memoria.

Parametros: struct ARBOL \*p Puntero al nodo a mostrar.

`            `unsigned \*cont Puntero al contador de elementos para permitir parar la visualizacion.

Return: Ninguno.

\*/

void Mostrar(struct ARBOL \*p,unsigned \*cont)

{

if (p->izq!=NULL)

Mostrar(p->izq,cont);

puts(p->pal);

if (++\*cont>21)

{

\*cont=1;

printf("\nPulsa Enter para continuar.\n"); getchar();

}

if (p->der!=NULL)

Mostrar(p->der,cont);![](Aspose.Words.ae55ca77-bd47-4be1-a802-7483922c91a3.015.png)

free(p);

}

int main(int argc,char \*argv[]) {

struct ARBOL \*p; unsigned cont=1;

if (argc!=2)

{

`      `printf("\nModo de uso: %s <fichero>\n",argv[0]);

return 1;

}

if ((p=LeerFichero(argv[1]))==NULL)

return 1;

printf("\n\n\n\n\n\n");

Mostrar(p,&cont);

`   `return 0;

}
86

[ref1]: Aspose.Words.ae55ca77-bd47-4be1-a802-7483922c91a3.001.png
[ref2]: Aspose.Words.ae55ca77-bd47-4be1-a802-7483922c91a3.002.png
[ref3]: Aspose.Words.ae55ca77-bd47-4be1-a802-7483922c91a3.008.png



---

## üîç **Uso de Valgrind para Depuraci√≥n de Memoria en C**

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Valgrind es una herramienta esencial para detectar **errores de memoria** (leaks, accesos inv√°lidos, etc.) en programas C. Su uso es especialmente cr√≠tico en proyectos como los de 42, donde la gesti√≥n manual de memoria es frecuente.

### üìå **Instalaci√≥n (Linux/macOS)**
```bash
# Ubuntu/Debian
sudo apt install valgrind

# macOS (via Homebrew)
brew install valgrind
```

### üî• **Comando B√°sico**
```bash
valgrind --leak-check=full ./tu_programa argumentos
```

### üõ†Ô∏è **Flags Recomendados para M√°xima Detecci√≥n**
| Flag | Descripci√≥n |
|------|-------------|
| `--leak-check=full` | Detalla el origen de *todos* los memory leaks |
| `--show-leak-kinds=all` | Muestra leaks definitivos, indirectos y posibles |
| `--track-origins=yes` | Rastrea or√≠genes de valores no inicializados |
| `--trace-children=yes` | Analiza procesos hijos (√∫til si usas `fork()` o `system()`) |
| `--error-exitcode=1` | Retorna error si hay problemas (ideal para CI/CD) |

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

### üéØ **Ejemplo Pr√°ctico**
Supongamos que tu programa `so_long` tiene un memory leak:
```bash
valgrind --leak-check=full --show-leak-kinds=all ./so_long map.ber
```
**Salida t√≠pica:**
```
==12345== 40 bytes in 1 blocks are definitely lost in loss record 1 of 2
==12345==    at 0x483877F: malloc (vg_replace_malloc.c:307)
==12345==    by 0x109234: crear_mapa (mapa.c:15)
==12345==    by 0x109567: main (main.c:28)
```
- **Interpretaci√≥n**: 40 bytes perdidos en `mapa.c`, l√≠nea 15. ¬°Debes liberarlos con `free()`!

### üìù **Errores Comunes que Detecta**
| Error | Causa | Soluci√≥n |
|-------|-------|----------|
| **Definitely lost** | Memoria nunca liberada | A√±ade `free()` donde corresponda |
| **Invalid read/write** | Acceso a memoria liberada o fuera de l√≠mites | Verifica √≠ndices y punteros |
| **Use of uninitialized values** | Variables no inicializadas | Inicializa siempre las variables |

### üö® **Supresi√≥n de Falsos Positivos (Ej: MiniLibX)**
Crea un archivo `mlx.supp`:
```xml
{
   <MLX_False_Positives>
   Memcheck:Leak
   ...
   fun:mlx_init
   ...
}
```
Y √∫salo con:
```bash
valgrind --suppressions=mlx.supp ./tu_programa
```

