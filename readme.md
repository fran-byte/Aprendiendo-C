# <img src="images/C_Logo.png"/> Programando en C - Material did√°ctico




### üîë **Palabras clave y fundamentos**

<a href="https://github.com/fran-byte/Learn-C/blob/main/readme.md#0-lista-de-palabras-reservadas-en-c-est%C3%A1ndar-ansi-c--iso-c"><img src="https://img.shields.io/badge/0.%20Palabras%20reservadas%20en%20C-96bf44"></a>

---

### üì¶ **Variables y Tipos de Datos**

<a href="#1--identificadores-tipos-de-datos-variables"><img src="https://img.shields.io/badge/1.%20Identificadores,%20Tipos%20de%20Datos,%20Variables-787a77"></a><br>
<a href="#11---tipos-de-datos"><img src="https://img.shields.io/badge/1.1.%20Tipos%20de%20Datos-96bf44"></a>
<a href="#12--declaraci√≥n-de-variables-y-alcance"><img src="https://img.shields.io/badge/1.2.%20Declaraci√≥n%20de%20Variables%20y%20Alcance-96bf44"></a>
<a href="#13--especificadores-de-almacenamiento-de-los-tipos-de-datos"><img src="https://img.shields.io/badge/1.3.%20Especificadores%20de%20Almacenamiento-96bf44"></a>
<a href="#14--constantes"><img src="https://img.shields.io/badge/1.4.%20Constantes-96bf44"></a>

---

### ‚ûï **Operadores**

<a href="#2---operadores-aritm%C3%A9ticos-relaci%C3%B3nales-y-l%C3%B3gicos-operador-asignaci%C3%B3n-operador-sizeof-y-operadores-avanzados-operadores-sobre-bits-y-operador-"><img src="https://img.shields.io/badge/2.%20Operadores-787a77"></a><br>
<a href="#21--operadores-aritm%C3%A9ticos"><img src="https://img.shields.io/badge/2.1.%20Operadores%20Aritm%C3%A9ticos-96bf44"></a>
<a href="#22--operadores-relaci%C3%B3nales-y-l%C3%B3gicos"><img src="https://img.shields.io/badge/2.2.%20Operadores%20Relacionales%20y%20L%C3%B3gicos-96bf44"></a>
<a href="#23--operador-asignaci%C3%B3n"><img src="https://img.shields.io/badge/2.3.%20Operador%20Asignaci%C3%B3n-96bf44"></a>
<a href="#24--operador-sizeof"><img src="https://img.shields.io/badge/2.4.%20Operador%20sizeof-96bf44"></a>
<a href="#25--operadores-sobre-bits"><img src="https://img.shields.io/badge/2.5.%20Operadores%20sobre%20Bits-96bf44"></a>
<a href="#26--el-operador-"><img src="https://img.shields.io/badge/2.6.%20Operador%20Ternario-96bf44"></a>

---

### üîÅ **Conversi√≥n de Tipos**

<a href="#3---conversi%C3%B3n-de-tipos-de-datos"><img src="https://img.shields.io/badge/3.%20Conversi√≥n%20de%20Tipos%20de%20Datos-787a77"></a><br>
<a href="#31--conversi%C3%B3n-autom%C3%A1tica-de-tipos-de-datos"><img src="https://img.shields.io/badge/3.1.%20Conversi√≥n%20Autom√°tica-96bf44"></a>
<a href="#32--conversi%C3%B3n-forzada-de-tipos-datos"><img src="https://img.shields.io/badge/3.2.%20Conversi√≥n%20Forzada-96bf44"></a>

---

### üß© **Control de Flujo**

<a href="#4---sentencias-de-control-y-bucles"><img src="https://img.shields.io/badge/4.%20Sentencias%20de%20Control%20y%20Bucles-787a77"></a><br>
<a href="#41-sentencia-de-control-if"><img src="https://img.shields.io/badge/4.1.%20Sentencia%20if-96bf44"></a>
<a href="#42-sentencia-de-control-switch"><img src="https://img.shields.io/badge/4.2.%20Sentencia%20switch-96bf44"></a>
<a href="#43-bucle-for"><img src="https://img.shields.io/badge/4.3.%20Bucle%20for-96bf44"></a>
<a href="#44--bucle-while"><img src="https://img.shields.io/badge/4.4.%20Bucle%20while-96bf44"></a>
<a href="#45-bucle-dowhile"><img src="https://img.shields.io/badge/4.5.%20Bucle%20do/while-96bf44"></a>
<a href="#46-sentencias-de-control-break-y-continue-"><img src="https://img.shields.io/badge/4.6.%20Sentencias%20break%20y%20continue-96bf44"></a>

---

### üßµ **Arrays, Cadenas y Punteros**

<a href="#tema-5---arrays-cadenas-y-punteros"><img src="https://img.shields.io/badge/5.%20Arrays,%20Cadenas%20y%20Punteros-787a77"></a><br>
<a href="#51-arrays-y-cadenas"><img src="https://img.shields.io/badge/5.1.%20Arrays%20y%20Cadenas-96bf44"></a>
<a href="#52-punteros"><img src="https://img.shields.io/badge/5.2.%20Punteros-96bf44"></a>

---

### üõ†Ô∏è **Funciones**

<a href="#tema-6---funciones"><img src="https://img.shields.io/badge/6.%20Funciones-787a77"></a><br>
<a href="#61-la-sentencia-return"><img src="https://img.shields.io/badge/6.1.%20Sentencia%20return-96bf44"></a>
<a href="#62-argumentos-de-las-funciones-llamada-por-valor-y-por-referencia"><img src="https://img.shields.io/badge/6.2.%20Argumentos%20de%20Funciones-96bf44"></a>
<a href="#63-arrays-como-argumentos-de-funciones"><img src="https://img.shields.io/badge/6.3.%20Arrays%20como%20Argumentos-96bf44"></a>
<a href="#64-argumentos-de-la-funci√≥n-main"><img src="https://img.shields.io/badge/6.4.%20Argumentos%20de%20main()-96bf44"></a>
<a href="#65-recursividad"><img src="https://img.shields.io/badge/6.5.%20Recursividad-96bf44"></a>
<a href="#66punteros-a-funciones"><img src="https://img.shields.io/badge/6.6.%20Punteros%20a%20Funciones-96bf44"></a>
<a href="#67-el-modificador-de-almacenamiento-static-aplicado-a-funciones"><img src="https://img.shields.io/badge/6.7.%20static%20en%20Funciones-96bf44"></a>

---

### üß± **Estructuras y Tipos Compuestos**

<a href="#tema-7---estructuras-campos-de-bit-uniones-y"><img src="https://img.shields.io/badge/7.%20Estructuras,%20Campos%20de%20Bit,%20Uniones%20y%20Enumeraciones-787a77"></a><br>
<a href="#71-estructuras"><img src="https://img.shields.io/badge/7.1.%20Estructuras-96bf44"></a>
<a href="#72-campos-de-bit"><img src="https://img.shields.io/badge/7.2.%20Campos%20de%20Bit-96bf44"></a>
<a href="#73-uniones"><img src="https://img.shields.io/badge/7.3.%20Uniones-96bf44"></a>
<a href="#74enumeraciones"><img src="https://img.shields.io/badge/7.4.%20Enumeraciones-96bf44"></a>
<a href="#75la-palabra-reservada-typedef"><img src="https://img.shields.io/badge/7.5.%20typedef-96bf44"></a>

---

### ‚öôÔ∏è **Preprocesador**

<a href="#tema-8---el-preprocesador"><img src="https://img.shields.io/badge/8.%20El%20Preprocesador-787a77"></a><br>
<a href="#81-directiva-define"><img src="https://img.shields.io/badge/8.1.%20Directiva%20define-96bf44"></a>
<a href="#82-directiva-undef"><img src="https://img.shields.io/badge/8.2.%20Directiva%20undef-96bf44"></a>
<a href="#83-directiva-error"><img src="https://img.shields.io/badge/8.3.%20Directiva%20error-96bf447"></a>
<a href="#84-directiva-include"><img src="https://img.shields.io/badge/8.4.%20Directiva%20include-96bf44"></a>
<a href="#85-directivas-if-ifdef-ifndef-else-elif-endif"><img src="https://img.shields.io/badge/8.5.%20Directivas%20Condicionales-96bf44"></a>
<a href="#86-directiva-line"><img src="https://img.shields.io/badge/8.6.%20Directiva%20line-96bf44"></a>
<a href="#87-directiva-pragma"><img src="https://img.shields.io/badge/8.7.%20Directiva%20pragma-96bf447"></a>

---

### üì• **Entrada y Salida**

<a href="#tema-9---entrada-y-salida"><img src="https://img.shields.io/badge/9.%20Entrada%20y%20Salida-787a77"></a><br>
<a href="#91-entrada-y-salida-desde-consola"><img src="https://img.shields.io/badge/9.1.%20Entrada/Salida%20desde%20Consola-96bf44"></a>
<a href="#92-entrada-y-salida-desde-fichero"><img src="https://img.shields.io/badge/9.2.%20Entrada/Salida%20desde%20Fichero-96bf44"></a>

---

### üß† **Memoria Din√°mica**

<a href="#tema-10---asignaci√≥n-din√°mica-de-memoria"><img src="https://img.shields.io/badge/10.%20Asignaci√≥n%20Din√°mica%20de%20Memoria-787a77"></a><br>
<a href="#101-reserva-din√°mica-de-memoria"><img src="https://img.shields.io/badge/10.1.%20Reserva%20Din√°mica-96bf44"></a>
<a href="#102-liberaci√≥n-din√°mica-de-memoria"><img src="https://img.shields.io/badge/10.2.%20Liberaci√≥n%20Din√°mica-96bf44"></a>
<a href="#103-ejemplo-de-asignaci√≥n-y-liberaci√≥n-din√°mica-de-memoria"><img src="https://img.shields.io/badge/10.3.%20Ejemplo%20Pr√°ctico-96bf44"></a>

---

### üìå **Ap√©ndices**

<a href="#ap%C3%A9ndice-a---funciones-de-biblioteca-del"><img src="https://img.shields.io/badge/A.%20Ap√©ndices-787a77"></a><br>
<a href="#a1-funciones-de-entrada-y-salida-de-datos"><img src="https://img.shields.io/badge/A.1.%20Funciones%20de%20Biblioteca%20ANSI%20C-96bf44"></a>
<a href="#a2---funciones-de-caracteres-ctypeh"><img src="https://img.shields.io/badge/A.2.%20Funciones%20de%20caracteres-96bf44"></a>
<a href="#a3---funciones-de-cadenas-stringh"><img src="https://img.shields.io/badge/A.3.%20Funciones%20de%20cadenas%20(<string.h>)-96bf44"></a>
<a href="#a4---funciones-matem√°ticas"><img src="https://img.shields.io/badge/A.4.%20Funciones%20Matem√°ticas-96bf44"></a>
<a href="#a5---asignaci√≥n-din√°mica-de-memoria"><img src="https://img.shields.io/badge/A.5.%20Asignaci√≥n%20din√°mica%20de%20memoria-96bf44"></a>
<a href="#a6---funciones-varias"><img src="https://img.shields.io/badge/A.6.%20Funciones%20varias-96bf44"></a>

---


 
### **0 Lista de Palabras Reservadas en C (Est√°ndar ANSI C / ISO C)**

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

---

#### **1. Palabras Reservadas B√°sicas (32 en total)**
Estas son las palabras clave definidas por el est√°ndar C que **no pueden usarse como identificadores** (nombres de variables, funciones, etc.):

| Categor√≠a          | Palabras Reservadas                                                                 |
|--------------------|------------------------------------------------------------------------------------|
| **Tipos de datos** | `char`, `short`, `int`, `long`, `float`, `double`, `void`, `_Bool` (C99), `_Complex` (C99), `_Imaginary` (C99) |
| **Modificadores**  | `signed`, `unsigned`, `const`, `volatile`, `restrict` (C99)                        |
| **Estructuras**    | `struct`, `union`, `enum`                                                          |
| **Control**        | `if`, `else`, `switch`, `case`, `default`, `for`, `do`, `while`, `break`, `continue`, `goto` |
| **Funciones**      | `return`                                                                           |
| **Memoria**        | `auto`, `register`, `static`, `extern`                                             |
| **Operadores**     | `sizeof`, `typedef`                                                                |
| **Otros**          | `inline` (C99), `_Alignas` (C11), `_Alignof` (C11), `_Atomic` (C11), `_Generic` (C11), `_Noreturn` (C11), `_Static_assert` (C11), `_Thread_local` (C11) |

---

#### **2. Extensiones Espec√≠ficas del Compilador**
Algunos compiladores a√±aden palabras reservadas propias (no est√°ndar). Ejemplos comunes:

- **GCC/G++**:  
  `__asm__`, `__attribute__`, `__inline__`, `__volatile__`, `__restrict__`, `__extension__`.  
- **Microsoft Visual C**:  
  `__cdecl`, `__declspec`, `__int64`, `__fastcall`, `__inline`.  

---

#### **3. Macros Predefinidas (No son palabras reservadas, pero son especiales)**
Estas pueden redefinirse, pero es peligroso:  
`NULL`, `true`, `false` (C99), `__FILE__`, `__LINE__`, `__DATE__`, `__TIME__`, `__func__` (C99).

---

#### **4. Diferencias entre Est√°ndares**
- **C89/C90**: 32 palabras reservadas.  
- **C99**: A√±ade `_Bool`, `_Complex`, `_Imaginary`, `inline`, `restrict`.  
- **C11**: A√±ade `_Alignas`, `_Alignof`, `_Atomic`, `_Generic`, `_Noreturn`, `_Static_assert`, `_Thread_local`.  

---

### **Ejemplo de Uso Incorrecto**
```c
int float = 10;  // ¬°Error! "float" es palabra reservada.
```

### **Ejemplo de Uso Correcto**
```c
int numero = 10;  // Correcto ("numero" no es palabra reservada).
```

---
### **Malas pr√°cticas de Programaci√≥n**

**Usar nombre de funciones de C como variables**  
Ejemplo: `malloc` como `calloc` **no son palabras reservadas** en el est√°ndar C. Son **funciones de la biblioteca est√°ndar** (`stdlib.h`), pero t√©cnicamente **pueden reutilizarse como nombres de variables**. Sin embargo, hacerlo es **mala pr√°ctica** y puede causar problemas. Aqu√≠ los detalles:

---

### **1. Ejemplo de Uso (Compila, pero es arriesgado)**

```c
#include <stdio.h>

int main() {
    int malloc = 42;  // Compila, pero "oscurece" la funci√≥n malloc().
    printf("%d\n", malloc);  // Imprime 42.
    return 0;
}
```
**Funciona**, pero ahora no podr√°s usar `malloc()` para asignar memoria din√°mica en ese √°mbito.

---

### **2. Riesgos Clave**
- **P√©rdida de funcionalidad**: Si necesitas usar `malloc()` o `calloc` despu√©s, el compilador tratar√° tu variable como un identificador, no como la funci√≥n.  
  ```c
  int* arr = malloc(10 * sizeof(int));  // ¬°Error! "malloc" es una variable, no una funci√≥n.
  ```
- **C√≥digo confuso**: Otros programadores (o t√∫ en el futuro) podr√≠an no entender por qu√© `malloc` no funciona como se espera.

---

### **3. ¬øPor qu√© el compilador lo permite?**
- **C no tiene namespaces**: Las funciones de la biblioteca est√°ndar no est√°n protegidas contra sobrescritura.  
- **El linker resuelve s√≠mbolos**: Si no incluyes `stdlib.h`, el compilador ni siquiera sabe que `malloc` es una funci√≥n.

---

### **4. Buenas Pr√°cticas**
- **Evita reutilizar nombres de funciones est√°ndar**. Usa alternativas claras:  
  ```c
  int mi_malloc = 42;  // ¬°Mejor!
  ```
- **Si accidentalmente lo haces**, renombra tu variable o usa el operador de resoluci√≥n de √°mbito (en C++):  
  ```cpp
  int malloc = 42;
  int* arr = ::malloc(10 * sizeof(int));  // C++: fuerza el uso de la funci√≥n global.
  ```
  *(En C puro no hay soluci√≥n directa; hay que renombrar la variable).*

---

### **5. Casos donde s√≠ podr√≠as hacerlo**
- **Macros maliciosas**: Si alguien defini√≥ `#define malloc algo_riesgoso`, podr√≠as "protegerte" con una variable local.  
  *(Pero es mejor usar `#undef malloc` y luego incluir `stdlib.h`).*

---


## 1.- IDENTIFICADORES, TIPOS DE DATOS, VARIABLES...

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

 
```
<tipo de dato> <nombre de variable>;

int a;
```

## 1.1. - Tipos de datos



|**Tipo de dato**|**Descripci√≥n.**|
| - | - |
|**char**|Car√°cter o entero peque√±o (byte)|
|**int**|Entero|
|**float**|Punto flotante|
|**double**|Punto flotante (mayor rango que *float*)|
|**void**|Sin tipo (uso especial)|



**Modificadores de Tipos de datos**

|**Modificador**|**Tipos de actuaci√≥n**|**Descripci√≥n**||
| - | - | - | :- |
|**signed**|char|int|Con signo (por defecto)|
|**unsigned**|char|int|Sin signo|
|**long**|int|double|Largo|
|**short**|int|Corto||

```
unsigned char a;
long double b;
short int i;
```
**Doble modificador a un mismo tipo de datos**
As√≠, es posible definir una variable de tipo :

```
unsigned long int (entero largo sin signo).
```


||**Rango de valores posibles en (notaci√≥n matem√°tica)**|| 
| :- | - | :- |
|**Tipo de variable declarada**|**16 bits**|**32 bits**|
|char / signed char|[-128 , 127]|[-128 , 127]|
|unsigned char|[0 , 255]|[0 , 255]|
|int / signed int|[-32768 , 32767]|[-2147483647 , 2147483648]|
|unsigned int|[0 , 65535]|[0 , 4294967295]|
|short int / signed short int|[-32768 , 32767]|[-32768 , 32767]|
|unsigned short int|[0 , 65535]|[0 , 65535]|
|long int / signed long int|[-2147483647 , 2147483648]|[-2147483647 , 2147483648]|
|unsigned long int|[0 , 4294967295]|[0 , 4294967295]|
|float|[-3.4E+38 , -3.4E-38], 0 , [3.4E-38 , 3.4E+38]|[-3.4E+38 , -3.4E-38], 0 , [3.4E-38 , 3.4E+38]|
|double|[-1.7E+308 , -1.7E-308], 0 , [1.7E-308 , 1.7E+308]|[-1.7E+308 , -1.7E-308], 0 , [1.7E-308 , 1.7E+308]|
|long double|[-3.4E+4932 , -1.1E-4932], 0 , [3.4E-4932 , 1.1E+4932]|[-3.4E-4932 , -1.1E+4932], 0 , [3.4E-4932 , 1.1E+4932]|



**Modificadores de acceso.** 
Limitan  el  uso  que  puede  realizarse  de  las  variables declaradas. 



|**Modificador**|**Efecto**|
| - | - |
|const|Variable de valor constante|
|volatile|Variable  cuyo  valor  es  modificado externamente|

**const** asegura de que su valor no ser√° modificado por el programa, salvo en el momento de su declaraci√≥n asign√°ndole un valor inicial.

```
const int x = 650;
```

Si intentamos modificar el valor de **x**, tal como **x=x+10;**, producir√° un error en tiempo de compilaci√≥n.

**volatile**, indica al compilador que la variable puede modificarse por un *proceso externo* al propio programa (como la hora del sistema), y por ello, que no trate de optimizar dicha variable suponi√©ndole un valor constante, etc. Cada vez que se usa la variable, se realice una comprobaci√≥n de su valor.

**const** y **volatile** pueden usarse de forma conjunta en ciertos casos, por lo cual no son excluyentes el uno del otro. Ello es posible si se declara una variable que actualizara el reloj del sistema, (proceso externo al programa), y que no queremos pueda modificarse en el interior del programa. Por ello, podremos declarar:

```
volatile const unsigned long int hora;
```

## 1.2- Declaraci√≥n de variables y alcance.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Podemos declarar las variables en cuatro lugares del m√≥dulo del programa:

- Variables **globales** Fuera de todas las funciones del programa, accesibles desde cualquier parte del programa.
- Variables **locales** dentro de una funci√≥n, accesibles tan solo por la funci√≥n en las que se declaran.
- Variable como **par√°metros** a la funci√≥n, accesibles de igual forma que si se declararan dentro de la funci√≥n.
- Variable **local de bloque** del programa, accesible tan solo dentro del bloque donde se declara.

``` c
#include <stdio.h>
int add; /* Variable global, accesible desde cualquier parte del programa*/
void suma(int x) /* Variable local declarada como par√°metro, accesible solo por la funci√≥n suma*/
{
  add = add + x;
  return;
}
void intercambio(int *a, int *b)
{
  if (*a > *b)
  {
    int inter; /* Variable local, accesible solo dentro del bloque donde se declara*/
    inter= *a;
    *a = *b;
    *b = inter;
  }
return;
}
int main(void) /*Funci√≥n principal del programa\*
{
  int contador, a = 9, b = 0; /*Variables locales, accesibles solo por main*/
  add = 0;
  intercambio(&a, &b);
  for(contador=a; contador<=b; contador++) suma(contador); printf(‚Äú%d\n‚Äù ,add);
  return(0);
}
```
## 1.3.- Especificadores de almacenamiento de los tipos de datos.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Los especificadores de almacenamiento deben preceder a la declaraci√≥n del tipo de dato de la variable. Estos especificadores de almacenamiento son:



||**Especificador de almacenamiento**|**Efecto**|
| :- | :- | - |
|auto||Variable  local  (por defecto)|
|extern||Variable externa|
|static||Variable est√°tica|
|register||Variable registro|


**auto** se usa para declarar que una variable local existe dentro de la subrutina o bloque de programa donde se declara, es por defecto y no se suele usar.

**extern** se usa en programas compuestos por varios m√≥dulos, se usa sobre las variables globales del m√≥dulo, y el compilador no crea un almacenamiento para ella en memoria, sino que, tan solo tiene en cuenta que dicha variable ya ha sido declarada en otro modulo del programa y es del tipo de dato que se indica.

**static** act√∫a seg√∫n el alcance de la variable:

- Para variables locales, **static** indica que la variable local debe almacenarse de forma permanente en memoria, como si fuera una variable global, pero su alcance como variable local declarada en la subrutina o bloque,conservando su valor entre llamadas a la funci√≥n.
- Para variables globales, **static** indica que la variable global es local al m√≥dulo del programa donde se declara, y, no ser√° conocida por ning√∫n otro m√≥dulo del programa.

**register** se aplica solo a variables locales de tipo **char** e **int**, indicando al compilador, si es posible, mantenga esa variable en un registro de la CPU y no cree una variable en la memoria. Se pueden declarar cuantas variables se deseen, pues el compilador ignorara dicha  declaraci√≥n  caso  de  no  poder  ser  satisfecha.  Y permite colocar en registros de la CPU variables usadas, como contadores de bucles, etc.

Algunos ejemplos de uso de los especificadores de almacenamiento son:

```
register unsigned int a;

static float b;

extern int c;

static const unsigned long int d;
```

## 1.4.- Constantes.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Valores fijos que el programa no puede alterar:



|**Tipo de dato**|**Constantes de ejemplo**|
| - | - |
|char|‚Äòa‚Äô ‚Äò9‚Äô 'Q'|
|int|1 -34 21000|
|long int|-34 67856L 456|
|short int|10 -12 1500|



|unsigned int|45600U 345 3|
| - | - |
|float|12\.45 4.34e-3 -2.8e9|
|double|-34.657 -2.2e-7 1.0e100|


Otras constantes son las constantes hexadecimales y octales, las constantes de cadena, y las constantes de barra invertida.

Las constantes hexadecimales y octales son **constantes enteras**, pero definidas en base 16 (constantes hexadecimales) o en base 8 (constantes octales).

Las constantes de tipo hexadecimal comienzan por los caracteres *0x*** seguidas del n√∫mero deseado. 
Las constantes de tipo octal comienzan por un cero (*0*). Por ejemplo, son constantes hexadecimales *0x34* (52 decimal), *0xFFFF* (65535 decimal); y constantes octales *011* (9 decimal), *0173* (123 decimal)

Las constantes de cadena son conjuntos de caracteres que se encierran entre comillas dobles. *‚ÄúEsto es una constante de cadena‚Äù*

Las  constantes de caracteres de barra invertida (tales como retorno de carro, etc.). Estas constantes son proporcionadas por C para que sea posible introducir dichas caracteres como constantes en los programas en los cuales sea necesario:



|**C√≥digo**|**Significado**|
| - | - |
|\b|Retroceso|
|\f|Alimentaci√≥n de hoja|
|\n|Nueva l√≠nea|
|\r|Retorno de carro|
|\t|Tabulador horizontal|
|\‚Äù|Doble comilla|
|\‚Äô|Simple comilla|
|\0|Nulo|
|\\|Barra invertida|
|\v|Tabulador vertical|
|\a|Alerta|
|\o|Constante octal|
|\x|Constante hexadecimal|


Son igual que el de cualquier otro car√°cter, as√≠, si *ch* es una variable de tipo *char*, podemos hacer: *ch=‚Äò\t‚Äô*, o *ch=‚Äò\x20‚Äô* (car√°cter espacio), etc., de igual forma que realizar√≠amos con cualquier otra constante de car√°cter.

Las constantes de barra invertida pueden usarse en el interior de constantes de cadena como un car√°cter m√°s, por ello: *"Esto es una linea\n"*.

## 2. - Operadores aritm√©ticos, relaci√≥nales y l√≥gicos; operador asignaci√≥n; operador sizeof y operadores avanzados (operadores sobre bits y operador ?)

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

## 2.1.- Operadores aritm√©ticos.

Los operadores aritm√©ticos existentes en C son, ordenados de mayor a menor precedencia:



|**Operador**||**Operador**||**Operador**||
| - | :- | - | :- | - | :- |
|**++**|Incremento|**--**|Decremento|||
|**-**|Menos unario|||||
|**\*** |Multiplicaci√≥n.|**/**|Divisi√≥n|**%**|M√≥dulo|
|**+**|Suma|**-**|Resta|||

Los operadores ++, -- y % solo pueden usarse con datos de tipo *int* o *char*. El operador incremento (++), incrementa en una unidad el valor de la variable sobre la que se aplica, el operador decremento (--), decrementa en una unidad el valor de la variable, y el operador m√≥dulo (%), calcula el resto de una divisi√≥n de dos variables de tipo entero o car√°cter.

Un aspecto que conviene explicar es el hecho de que los operadores incremento y decremento pueden preceder o posceder a su operando, lo cual permite escribir, si *x* es una variable de tipo *int*, las expresiones ++*x* o *x*++. Usado de forma aislada no presenta ninguna diferencia, sin embargo, cuando se usa en una expresi√≥n existe una diferencia en el orden de ejecuci√≥n del mismo. Cuando el operador incremento (o decremento) precede al operando, C primero realiza el incremento (o decremento), y despu√©s usa el valor del operando, realiz√°ndose la operaci√≥n al contrario si el operador poscede al operando. As√≠, consid√©rense el siguiente c√≥digo de un programa:

int var1=10,var2;

var2=++var1; /\* Pone 11 en var2, pues primero incrementa var1,\*/              /\* y luego asigna su valor a var2 \*/

Mientras que el siguiente c√≥digo funciona de forma distinta:

int var1=10,var2;

var2=var1++; /\* Pone 10 en var2, pues primero asigna su valor \*/              /\* a var2, y luego incrementa var1 \*/

## 2.2- Operadores relaci√≥nales y l√≥gicos.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Los operadores relaci√≥nales y l√≥gicos de C:


| **Operador** | **Nombre**          | **Operador** | **Nombre**               | **Operador** | **Nombre**        | **Operador** | **Nombre**               |
|--------------|---------------------|--------------|--------------------------|--------------|-------------------|--------------|--------------------------|
| `!`          | NOT l√≥gico          | `>`          | Mayor que                | `<`          | Menor que         | `>=`         | Mayor o igual que        |
| `==`         | Igual que           | `!=`         | No igual                 | `&&`         | AND l√≥gico        | `\|\|`       | OR l√≥gico                |
| `&`          | AND bit a bit       | `\|`         | OR bit a bit             | `^`          | XOR bit a bit     | `~`          | NOT bit a bit            |
| `<<`         | Desplazamiento izquierda | `>>`    | Desplazamiento derecha   | `?:`         | Operador ternario | `=`          | Asignaci√≥n b√°sica        |
| `+=`         | Asignaci√≥n con suma | `-=`         | Asignaci√≥n con resta      | `*=`         | Asignaci√≥n con multiplicaci√≥n | `/=` | Asignaci√≥n con divisi√≥n |
| `++`         | Incremento          | `--`         | Decremento               | `->`         | Acceso a miembro de estructura | `.*` | Acceso a miembro por puntero |
| `&`          | Direcci√≥n de        | `*`          | Dereferencia             | `sizeof`     | Tama√±o de tipo    | `,`          | Operador coma            |


Los operadores relaci√≥nales y l√≥gicos tiene menor prioridad que los operadores aritm√©ticos antes descritos, as√≠ , escribir *10>3+9* es equivalente a escribir *10>(3+9)*.

## 2.3.- Operador asignaci√≥n.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


El lenguaje C, a diferencia de otros lenguajes tales como Pascal, no diferencia la asignaci√≥n de cualquier otro operador del lenguaje. Para C, la asignaci√≥n es un operador, el llamado operador asignaci√≥n (`=`), el cual posee la prioridad m√°s baja de todos los operadores. Es por ello que en C podemos escribir expresiones del tipo:

```c
if ((c = a * b) < 0)  /* if es la comprobaci√≥n condicional de C, que */
                       /* se ver√° con posterioridad */
````

Esta expresi√≥n asigna a la variable `c` el valor de `a * b` y devuelve su valor para compararlo con el valor constante 0. Los par√©ntesis son necesarios, pues el operador asignaci√≥n tiene la prioridad m√°s baja de todos los operadores.



## 2.4.- Operador sizeof.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


El operador **sizeof** es un operador en tiempo de compilaci√≥n. Devuelve el tama√±o de una variable o tipo de dato durante la compilaci√≥n, no durante la ejecuci√≥n del programa. Veamos algunos ejemplos:

```c
sizeof(int) //  devuelve el valor 2 en los sistemas operativos de 16 bits y 4 en los de 32 bits.
````

Si tenemos `char a[20]`, `sizeof(a)` devuelve el valor 20, y si tenemos `float a[6]`, `sizeof(a)` devuelve el valor 24 (4 \* 6).


## 2.5.- Operadores sobre bits.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

El lenguaje C posee operadores que act√∫an a nivel de bits sobre los datos, estos operadores son:



|**Operador**|**Nombre**|**Operaci√≥n**|
| - | - | - |
|~|Not|Complemento a uno (NOT)|
|<<|Desplazamiento izquierda|Desplazamiento izquierda|
|>>|Desplazamiento derecha|Desplazamiento derecha|
|&|And|Y|
|^|Xor|O exclusivo (XOR)|
|\|\||Or|O|


Los operadores &, | y** ^ act√∫an sobre dos operandos, mientras que ~ ,<< **y *>>*** act√∫an sobre un solo operando. Veamos su actuaci√≥n sobre dos valores cualquiera:



|**Operador**|**Operando 1**|**Operando 2**|**Resultado**|
| - | - | - | - |
|~|0xB2||0x4D|
|<<3|0xB2||0x90|
|>>2|0xB2||0x2C|
|&|0xB2|0x79|0x30|
|^|0xB2|0x79|0xCB|
|||0xB2|0x79|0xFB|


Donde los n√∫meros que acompa√±an a los operadores << y** >> indican cuantas posiciones se desplaza el operando. La prioridad de los operadores sobre bits es:

- El operador ~ tiene la misma prioridad que los operadores ++ y .**--**.
- Los operadores <<  y >>  tienen la prioridad situada entre los operadores aritm√©ticos y los operadores relaci√≥nales y l√≥gicos.
- Los operadores &, ^ y |  tienen la prioridad situada entre los operadores relaci√≥nales y los operadores l√≥gicos (&& y ||).
- 
## 2.6.- El operador ?.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


El operador `? :` se usa para reemplazar las sentencias `if/else` (que veremos con posterioridad) de formato general:

```c
if (condici√≥n)    expresi√≥n;
else
      expresi√≥n;
````

Donde `expresi√≥n` debe ser una expresi√≥n sencilla y no otra sentencia de C. El operador `?` es un operador ternario cuyo formato general es:

```c
Exp1 ? Exp2 : Exp3;
```

Donde **Exp1**, **Exp2** y **Exp3** son expresiones. El operador `?` eval√∫a la expresi√≥n **Exp1**, si es cierta se eval√∫a **Exp2** y si es falsa se eval√∫a **Exp3**. Veamos algunos ejemplos:

```c
int x, y;

y = (x > 10) ? 100 : 200;
```

Asignar√° el valor 100 a `y` si `x` es mayor de 10, y el valor 200 en caso contrario.

```c
int t;

(t) ? f1(t) + f2() : printf("t vale cero");
```

Ejecutar√° las funciones `f1()` y `f2()` si `t` es distinto de cero, y la funci√≥n `printf` si `t` vale cero.



## 3 - Conversi√≥n de tipos de datos.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

## 3.1.- Conversi√≥n autom√°tica de tipos de datos.


El lenguaje C permite que en una misma expresi√≥n aparezcan diferentes tipos de datos, encarg√°ndose el compilador de realizar las operaciones de forma correcta. El compilador del lenguaje C, cuando en una misma expresi√≥n aparecen dos o m√°s tipos de datos, convierte todos los operandos al tipo del operando m√°s grande existente de acuerdo con las dos reglas siguientes:

- Todos los `char` y `short int` se convierten a `int`.
- Todos los `float` a `double`.

Para todo par de operandos, lo siguiente ocurre en secuencia:

1. Si uno de los operandos es un `long double`, el otro se convierte en `long double`.
2. Si uno de los operandos es `double`, el otro se convierte a `double`.
3. Si uno de los operandos es `long`, el otro se convierte a `long`.
4. Si uno de los operandos es `unsigned`, el otro se convierte a `unsigned`.

Despu√©s de que el compilador aplique estas reglas de conversi√≥n, cada par de operandos ser√° del mismo tipo, y el resultado ser√° del tipo de los operandos. Veamos un ejemplo:

```c
char ch; int i; float f; double d;

( ch / i ) + ( f * d ) - ( f + i );
````

`char int float double float int`

Debido a que en la operaci√≥n existen diferentes tipos se aplica la primera conversi√≥n:

* `ch` de `char` pasa a `int`.
* `f` de `float` pasa a `double`.

```c
( ch / i ) + ( f * d ) - ( f + i );
```

`int int double double double int`

Al ser los dos operandos de igual tipo, realizamos la primera operaci√≥n, `(ch / i)`, y el resultado es de tipo `int`. De igual forma, para la segunda operaci√≥n, `(f * d)`, el resultado es de tipo `double`.

Para la tercera operaci√≥n, y dado que las variables no son del mismo tipo, se aplica la segunda regla, convirti√©ndose el `int` en `double`, realiz√°ndose la suma `(f + i)` como dos datos de tipo `double`, y siendo por tanto el resultado un `double`.

Ahora procedemos a realizar la suma de los dos primeros resultados `(ch / i) + (f * d)`, como uno de ellos es de tipo `int`, y el otro de tipo `double`, el `int` se convierte en `double` por la segunda regla, y el resultado es un `double`.

Y por √∫ltimo, realizamos la resta final, siendo los dos operandos de tipo `double` y el resultado final, por tanto, de tipo `double`.





## 3.2.- Conversi√≥n forzada de tipos datos.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

En C, existe, adem√°s, de la conversi√≥n autom√°tica de tipos de datos, la posibilidad de forzar la conversi√≥n de un tipo de datos en otro tipo de datos. Esta conversi√≥n de un tipo de datos en otro se llama ‚Äúcasts‚Äù, y su sintaxis es:

(tipo)expresi√≥n

Su utilidad queda claramente expresada en el ejemplo siguiente:

```
int a=3,b=2; float c; c=a/b;
```

La operaci√≥n asigna a *c* el valor *1.0* en vez de el valor *1.5*, ello se debe a que al ser *a* y *b* variables de tipo entero, se realiza una divisi√≥n entre enteros, y el resultado de *3/2* es *1*. A continuaci√≥n ese valor *1* se convierte a un valor en coma flotante para realizar la asignaci√≥n (valor *1.0*), y se asigna a *c*. Si lo que se desea es que la divisi√≥n se realice en punto flotante, debe escribirse la operaci√≥n de la siguiente forma:

```
c=(float)a/b;
```

Esta conversi√≥n forzada obliga a convertir la variable *a* en *float*, y entonces, aplicando las reglas de conversi√≥n autom√°tica de tipos, se realiza la divisi√≥n en coma flotante. Este proceso da lugar a que el resultado de la operaci√≥n sea *1.5*, y dicho valor sea el asignado a la variable *c*.!

## 4 - Sentencias de control y bucles.


[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

## 4.1. Sentencia de control if.

Antes de empezar a explicar las sentencias de control del lenguaje C, conviene explicar los conceptos de verdadero/falso y de sentencia que posee el lenguaje C.

El lenguaje C posee un concepto muy amplio de lo que es verdadero. Para C, cualquier valor que sea distinto de cero es verdadero, siendo por tanto falso solo si el valor es cero. Es por ello que una expresi√≥n del tipo `if(x)` ser√° verdad siempre que el valor de la variable `x` sea distinto de cero, sea cual sea el tipo de la variable `x`.

El concepto de sentencia en C es igual que el de otros muchos lenguajes. Por sentencia se entiende en C cualquier instrucci√≥n simple o bien, cualquier conjunto de instrucciones simples que se encuentren encerradas entre los caracteres `{` y `}`, que marcan respectivamente el comienzo y el final de una sentencia.

La forma general de la sentencia `if` es:

```c
if (condici√≥n)
    sentencia; 
else
    sentencia;
````

Siendo el `else` opcional. Si la condici√≥n es verdadera se ejecuta la sentencia asociada al `if`, en caso de que sea falsa la condici√≥n se ejecuta la sentencia asociada al `else` (si existe el `else`). Veamos algunos ejemplos de sentencias `if`:

```c
int a, b;

if (a > b)
{
    b--;
    a = a + 5;
}
else
{
    a++;
    b = b - 5;
}
if (b - a != 7)
    b = 5;
```

Las sentencias de control `if` pueden ir anidadas. Un `if` anidado es una sentencia `if` que es el objeto de otro `if` o `else`. Esta anidaci√≥n de `if/else` puede presentar la problem√°tica de decidir qu√© `else` va asociado a cada `if`. Considerese el siguiente ejemplo:

```c
if (x)
    if (y) 
        printf("1");
    else 
        printf("2");
```

¬øA qu√© `if` se refiere el `else`? C soluciona este problema asociando cada `else` al `if` m√°s cercano posible y que todav√≠a no tiene ning√∫n `else` asociado. Es por ello que en este caso el `if` asociado al `else` es el `if(y)`. Si queremos que el `else` est√© asociado al `if(x)`, deber√≠amos escribirlo de la siguiente forma:

```c
if (x)
{
    if (y)
        printf("1");
}
else
    printf("2");
```


## 4.2. Sentencia de control switch.

  [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


La forma general de la sentencia `switch` es:

```c
switch (variable) {
    case const1: 
        sentencia; 
        break;
    case const2: 
        sentencia; 
        break;
    default: 
        sentencia; 
}
````

Donde `variable` debe ser de tipo `char` o `int`, y donde `const1`, `const2`, ..., indican constantes de C del tipo de datos de la variable. Dichas constantes no pueden repetirse dentro del `switch`. El `default` es opcional y puede no aparecer, as√≠ como los `break` de los `case`. La sentencia `switch` se ejecuta comparando el valor de la variable con el valor de cada una de las constantes, realizando la comparaci√≥n desde arriba hacia abajo. En caso de que se encuentre una constante cuyo valor coincida con el valor de la variable, se empieza a ejecutar las sentencias hasta encontrar una sentencia `break`. En caso de que no se encuentre ning√∫n valor que coincida, se ejecuta el `default` (si existe). Veamos algunos ejemplos:

```c
int valor;
switch(valor)
{
  case 0: 
    cont++;
    break;
  case 5: 
    cont--;
    break;
  default: 
    cont = -10; /* Se ejecuta si valor no es 0 o 5 */ 
}
```

```c
char d;
int cont = 0;
switch(d)
{
  case '\r': 
    cont++; /* Si d es un retorno de carro, se ejecuta este cont++ y el siguiente */
  case '\x1B': 
    cont++;
    break;
  default: 
    cont = -1;
}
```

Las sentencias `switch` pueden aparecer unas dentro de otras, igual que suced√≠a con las sentencias `if`. Ve√°moslo con un ejemplo:

```c
char d, e;

switch (d) {
    case 'a':
    case 'A':
        switch (e) {
            case '1':
                d = 'z';
                e = '+';
                break;
            case '2':
                d = 'Z';
                e = '-';
        }
        break;

    case 'b':
    case 'B':
        switch (e) {
            case '0':
                d = '2';
            default:
                e = '+';
        }
}
```



## 4.3. Bucle for.


[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La forma general de la sentencia `for` es:

```c
for (inicializaci√≥n; condici√≥n; actualizaci√≥n) {
    sentencia;
}
````

Donde:

* `inicializaci√≥n` es una expresi√≥n que se ejecuta una vez al principio del ciclo.
* `condici√≥n` es una expresi√≥n que se eval√∫a antes de cada iteraci√≥n. Si es verdadera, se ejecuta la sentencia del ciclo; si es falsa, el ciclo termina.
* `actualizaci√≥n` es una expresi√≥n que se ejecuta despu√©s de cada iteraci√≥n, normalmente usada para cambiar el valor de las variables involucradas en la condici√≥n.

Veamos un ejemplo:

```c
int i;

for (i = 0; i < 10; i++) {
    printf("%d ", i);  // Imprime los n√∫meros del 0 al 9
}
```

En este ejemplo, la variable `i` se inicializa en 0. Mientras `i` sea menor que 10, se ejecutar√° la sentencia dentro del `for` (en este caso, imprimir el valor de `i`). Despu√©s de cada iteraci√≥n, `i` se incrementa en 1, hasta que la condici√≥n `i < 10` sea falsa.

El ciclo `for` puede tambi√©n ser usado sin que se especifiquen todos los componentes. Por ejemplo:

```c
int j = 0;

for (; j < 5;) {
    printf("%d ", j);
    j++;
}
```

Aqu√≠ se omiten tanto la inicializaci√≥n como la actualizaci√≥n en la cabecera del ciclo. Solo se mantiene la condici√≥n y la actualizaci√≥n ocurre dentro del ciclo.

Adem√°s, los ciclos `for` pueden ser anidados (uno dentro de otro). Veamos un ejemplo de un ciclo `for` anidado:

```c
int i, j;

for (i = 0; i < 3; i++) {
    for (j = 0; j < 2; j++) {
        printf("i = %d, j = %d\n", i, j);
    }
}
```

Este ciclo imprime combinaciones de los valores de `i` y `j`. En cada iteraci√≥n del ciclo exterior, el ciclo interior se ejecuta completamente.




## 4.4.  Bucle while.


 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La sintaxis del bucle `while` es:

```c
while (condici√≥n) 
    sentencia;
````

Donde la sentencia puede no existir (sentencia vac√≠a), pero siempre debe existir la condici√≥n. El bucle `while` se ejecuta mientras la condici√≥n sea verdad. Veamos algunos ejemplos de bucles `while`:

```c
int i = 1, suma = 0; 
while (i <= 100) {
    suma = suma + i;
    i++;
}
```

Este bucle suma los n√∫meros del 1 al 100 y almacena el resultado en `suma`.

```c
while (getc(stdin) != '\x1B'); /* Bucle que espera hasta que se */
                                /* pulse la tecla Esc */
```

Este bucle se ejecuta esperando que se presione la tecla `Esc` (representada por el valor `'\x1B'` en c√≥digo ASCII).

```c
while (1) /* Recordar que en C lo que no es cero es verdad */ {
    d = getc(stdin);
    printf("%c", d);
    if (d == '\x1B')
        break;
}
```

Este es un bucle infinito que lee caracteres desde la entrada est√°ndar (teclado) y los imprime en la pantalla. Si se presiona la tecla `Esc`, el bucle se interrumpe con la instrucci√≥n `break`.




## 4.5. Bucle do/while.


[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


Al contrario que los bucles `for` y `while` que comprueban la condici√≥n en lo alto de la misma, el bucle `do/while` comprueba la condici√≥n en la parte baja del mismo, lo cual provoca que el bucle se ejecute como m√≠nimo una vez. La sintaxis del bucle `do/while` es:

```c
do
    sentencia;
while (condici√≥n);
````

El bucle `do/while` se ejecuta mientras la `condici√≥n` sea verdad. Veamos algunos ejemplos de bucle `do/while`:

```c
int num;

do {
    scanf("%d", &num);
} while (num > 100);
```

En este ejemplo, el programa solicita al usuario que ingrese un n√∫mero. Si el n√∫mero es mayor que 100, seguir√° solicitando la entrada, asegurando que la condici√≥n se verifique al final de cada iteraci√≥n.

```c
int i, j;

do {
    scanf("%d", &i);
    scanf("%d", &j);
} while (i < j);
```

Este ejemplo solicita dos n√∫meros, `i` y `j`, y continuar√° solicitando la entrada mientras `i` sea menor que `j`. Al igual que en el caso anterior, la condici√≥n se eval√∫a despu√©s de la ejecuci√≥n de las sentencias dentro del `do`.




## 4.6 Sentencias de control break y continue .

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


Las sentencias de control `break` y `continue` permiten modificar y controlar la ejecuci√≥n de los bucles anteriormente descritos.

La sentencia `break` provoca la salida del bucle en el cual se encuentra y la ejecuci√≥n de la sentencia que se encuentra a continuaci√≥n del bucle.

La sentencia `continue` provoca que el programa vaya directamente a comprobar la condici√≥n del bucle en los bucles `while` y `do/while`, o bien, que ejecute el incremento y despu√©s compruebe la condici√≥n en el caso del bucle `for`.

Veamos algunos ejemplos de uso de `break` y de `continue`:

```c
int x;

for (x = 0; x < 10; x++) {
    for (;;) {
        if (getc(stdin) == '\x1B')
            break;  // Sale del bucle infinito cuando se presiona la tecla Esc
    }
    printf("Sal√≠ del bucle infinito, el valor de x es: %d\n", x);
}
````

En este ejemplo, el bucle interior es infinito, pero si se presiona la tecla `Esc`, el `break` provoca que salga de ese bucle, y luego el programa contin√∫a con el siguiente valor de `x`.

```c
int x;

for (x = 1; x <= 100; x++) {  /* Esta rutina imprime en pantalla los */
                               /* n√∫meros pares */
    if (x % 2)  // Si el n√∫mero es impar, se salta a la siguiente iteraci√≥n
        continue;
    printf("%d\n", x);  // Imprime el n√∫mero si es par
}
```

Aqu√≠, si el n√∫mero `x` es impar (es decir, si `x % 2` es distinto de 0), el `continue` provoca que se salte la ejecuci√≥n de la instrucci√≥n `printf` y pase a la siguiente iteraci√≥n del bucle.



## Tema 5 - Arrays, cadenas y punteros.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

## 5.1. Arrays y cadenas.

En C, un array unidimensional se declara como:

```c
tipo nombre[tama√±o];
````

En C, el primer elemento de un array es el que posee el √≠ndice 0, por lo tanto, un array de 20 elementos posee sus elementos numerados de 0 a 19. Veamos unos ejemplos de declaraci√≥n y manejo de algunos arrays:

```c
int x[100], i; 
for(i = 0; i < 100; i++)
    x[i] = i;
```

```c
char letras[256]; 
int i; 
for(i = 0; i < 256; i++)
    letras[i] = i;
```

```c
int x[10], i, suma;
for(i = 0; i < 10; i++) {
    printf("Introducir un n√∫mero: %d: ", i);
    scanf("%d", &x[i]);
}

for(suma = 0, i = 0; i < 10; i++)
    suma = suma + x[i];

printf("La suma es: %d", suma);
```

Sin embargo, el lenguaje C no comprueba el tama√±o de los arrays, por lo cual, es posible construir una rutina como la siguiente, la cual ocasionar√° un incorrecto funcionamiento del programa:

```c
float a[10];
int i;

for(i = 0; i < 100; i++) /* Este bucle es incorrecto */
    a[i] = i;
```

Es por ello, que es misi√≥n del programador comprobar que no se produzca el desbordamiento de los arrays.

### Cadenas (Strings)

Una cadena, tambi√©n llamada `string`, es un tipo especial de array unidimensional. Una cadena es un array de caracteres (`char`) que termina con un car√°cter especial (el car√°cter `'\0'`). Es por ello, que la declaraci√≥n de una cadena de caracteres se realiza exactamente igual que la declaraci√≥n de un array unidimensional de caracteres:

```c
char cadena[tama√±o];
```

Como toda cadena debe terminar en el car√°cter `'\0'`, es por ello que si se quiere usar una cadena de 20 caracteres, debe declararse de tama√±o 21 (20 caracteres + car√°cter terminador).

Por lo dem√°s, puede usarse una cadena como si fuera un array unidimensional, pues se puede referenciar uno cualquiera de sus elementos, etc. Para manejar las cadenas, existen un gran n√∫mero de funciones de biblioteca que proporciona el est√°ndar ANSI-C, para m√°s informaci√≥n, referirse al ap√©ndice A o a cualquier libro de C.

### Arrays Multidimensionales

La declaraci√≥n de arrays de m√°s de una dimensi√≥n se realiza de forma parecida a la de una dimensi√≥n. La sintaxis de la declaraci√≥n de un array multidimensional es:

```c
tipo nombre[tam1][tam2]...[tamN];
```

Y su indexaci√≥n, etc., se realiza de forma similar al array unidimensional. Veamos un ejemplo:

```c
float matriz[2][3];
int i, j;

for(i = 0; i < 2; i++) {
    for(j = 0; j < 3; j++) {
        printf("M[%d][%d]: ", i, j);
        scanf("%f", &matriz[i][j]);
    }
}
```

### Inicializaci√≥n de Arrays

Adem√°s, es posible inicializar los arrays en el momento de declararlos. Su sintaxis es:

```c
tipo nombre[tam1][tam2]...[tamN] = {lista_de_valores};
```

Por lo cual, podemos escribir:

```c
float vector[3] = {-3.0, 5.7, -7.5};
```

Tambi√©n es posible inicializar arrays sin ponerles el tama√±o, el compilador cuenta el n√∫mero de caracteres de inicializaci√≥n y reserva el tama√±o necesario de forma autom√°tica. Por ejemplo:

```c
float vector[] = {-3.0, 5.7, -7.5};
```

```c
char cadena[] = "Esto es una cadena";
```



## 5.2. Punteros.


[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


Los punteros son una de las poderosas herramientas que ofrece el lenguaje C a los programadores, sin embargo, son tambi√©n una de las m√°s peligrosas. El uso de punteros sin inicializar, etc., es una fuente frecuente de errores en los programas de C, y adem√°s, suele producir fallos muy dif√≠ciles de localizar y depurar.

Un puntero es una variable que contiene una direcci√≥n de memoria. Normalmente, esa direcci√≥n es una posici√≥n de memoria de otra variable, por lo cual se suele decir que el puntero ‚Äúapunta‚Äù a la otra variable.

### Declaraci√≥n de Punteros

La sintaxis de la declaraci√≥n de una variable puntero es:

```c
tipo *nombre;
````

El tipo base de la declaraci√≥n sirve para conocer el tipo de datos al que pertenece la variable a la cual apunta el puntero. Esto es fundamental para poder leer el valor que almacena la zona de memoria apuntada por la variable puntero y para poder realizar ciertas operaciones aritm√©ticas sobre los mismos.

Algunos ejemplos de declaraci√≥n de variables puntero son:

```c
int *a;
char *p;
float *f;
```

### Operadores de Punteros

Existen dos operadores especiales para los punteros, el operador `*&` y el operador `*`.

1. **El operador `&`**: Es un operador unario que devuelve la direcci√≥n de una variable de memoria. As√≠, si declaramos:

   ```c
   int *a, b;
   ```

   Y hacemos:

   ```c
   a = &b;
   ```

   La variable puntero `a` contendr√° la direcci√≥n de memoria de la variable `b`.

2. **El operador `*`**: Es un operador unario que devuelve el valor de la variable situada en la direcci√≥n que sigue. Ve√°moslo con un ejemplo:

   ```c
   int *a, b, c;
   b = 15;
   a = &b;
   c = *a;
   ```

   Entonces la variable `c` contendr√° el valor `15`, pues `*a` devuelve el valor de la direcci√≥n que sigue (la cual "apunta" el puntero `a`), y previamente hemos hecho que `a` contenga la direcci√≥n de memoria de `b`.

### Operaciones con Punteros

1. **Asignaci√≥n de punteros**: Es posible asignar el valor de una variable puntero a otra variable puntero. Por ejemplo:

   ```c
   int *a, *b, c;
   a = &c;
   b = a;
   ```

   Entonces, `b` contiene el valor de `a`, y por lo tanto, `b` tambi√©n "apunta" a la variable `c`.

2. **Aritm√©tica de punteros**: Se pueden realizar operaciones sobre las variables de tipo puntero usando los operadores `+`, `-`, `++`, `--`. Estos operadores incrementan o decrementan la posici√≥n de memoria a la que "apunta" el puntero. El incremento o decremento se realiza de acuerdo al tipo base de la variable puntero, por lo que el tipo del puntero es muy importante. Ejemplo:

   | **Operaci√≥n** | ++                   | --                  | +9   | -5   |
   | ------------- | -------------------- | ------------------- | ---- | ---- |
   | **Variable**  | **Direcci√≥n actual** | **Nueva direcci√≥n** |      |      |
   | int \*a;      | 3000                 | 3002                | 2998 | 3018 |
   | float \*b;    | 3000                 | 3004                | 2996 | 3036 |

   Por lo tanto, si tenemos:

   ```c
   tipo *a;
   a = a + num;
   ```

   La posici√≥n a la que apunta `a` se incrementa en `num * sizeof(tipo)`. Para la resta se decrementa de igual forma.

3. **Comparaciones de punteros**: Tambi√©n es posible realizar comparaciones entre punteros. Por ejemplo:

   ```c
   int *a, *b;
   if (a < b)
       printf("a apunta a una direcci√≥n m√°s baja que b");
   ```

### Relaci√≥n entre Punteros y Arrays

Existe una estrecha relaci√≥n entre los punteros y los arrays. Consideremos el siguiente fragmento de c√≥digo:

```c
char str[80], *p;
p = str;
```

Este fragmento de c√≥digo pone en la variable puntero `p` la direcci√≥n del primer elemento del array `str`. Entonces, es posible acceder al valor de la quinta posici√≥n del array mediante `str[4]` y `*(p + 4)` (recu√©rdese que los √≠ndices de los arrays comienzan en 0). Esta relaci√≥n entre arrays y punteros es muy evidente, ya que el nombre del array sin √≠ndice es la direcci√≥n de comienzo del array, y un puntero puede indexarse como un array unidimensional. Por lo cual, en el ejemplo anterior, podr√≠amos referenciar ese elemento como `p[4]`.

Es posible obtener la direcci√≥n de un elemento cualquiera del array de la siguiente forma:

```c
int str[80], *p;
p = &str[4];
```

Entonces, el puntero `p` contiene la direcci√≥n del quinto elemento del array `str`.

### Arrays de Punteros

Hasta ahora hemos declarado variables puntero aisladas. Es posible, como con cualquier otro tipo de datos, definir un array de variables puntero. La declaraci√≥n para un array de punteros `int` de tama√±o `10` es:

```c
int *a[10];
```

Para asignar una direcci√≥n de una variable entera, llamada `var`, al tercer elemento del array de punteros, se escribe:

```c
a[2] = &var;
```

Y para encontrar el valor de `var`:

```c
* a[2];
```

### Punteros a Punteros

Dado que un puntero es tambi√©n una variable, es posible definir un puntero a un puntero. Supongamos que tenemos lo siguiente:

```c
int a, *b, **c;
b = &a;
c = &b;
```

Y entonces, `**c` tiene el valor de la variable `a`, pues `c` es un puntero a una variable que ya es de tipo puntero.

Este concepto de puntero a puntero podr√≠a extenderse a punteros a punteros a punteros, etc., pero no nos ocuparemos de ello. Adem√°s, existe el concepto de puntero a una funci√≥n, al cual nos referiremos en el tema dedicado a las funciones.

---

## Tema 6 - Funciones

El formato general de una funci√≥n en C es:

```c
tipo nombre(lista de par√°metros) {
    cuerpo de la funci√≥n
}
```

Las funciones son similares a las de cualquier otro lenguaje, pero, tal como mencionamos en la introducci√≥n, al no ser un lenguaje estructurado por bloques, no es posible declarar funciones dentro de otras funciones.
   

## 6.1. La sentencia return.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

 
Antes de empezar la explicaci√≥n de las funciones, conviene explicar la sentencia `return`. La sentencia `return` permite, en primer lugar, salir de la funci√≥n desde cualquier punto de la misma, y en segundo lugar, devolver un valor del tipo de la funci√≥n, si ello es necesario (no se devuelve ning√∫n valor si la funci√≥n es de tipo `void`).

### Ejemplo con `return`

Veamos un ejemplo de una funci√≥n con varios puntos de retorno:

```c
int Comparacion(int a, int b) {
    if (a > b) return 1;    /* a es mayor que b */
    if (a < b) return -1;   /* a es menor que b */
    return 0;                /* a y b son iguales */
}
````

Como se observa en el ejemplo, una funci√≥n puede contener m√°s de una sentencia `return`. Esto permite la posibilidad de poder salir de la funci√≥n desde distintos puntos de la misma. Un aspecto que conviene resaltar es el hecho de que una funci√≥n tambi√©n termina su ejecuci√≥n si llega al final de la misma sin encontrar ninguna sentencia `return`. Esto es posible en toda funci√≥n de tipo `void`.

### Ejemplo de funci√≥n `void` sin `return`

Veamos un ejemplo de una funci√≥n `void` sin un `return` expl√≠cito:

```c
void A(int *a) {
    *a = 5;
}
```

Esta funci√≥n es equivalente a otra que tuviera como √∫ltima l√≠nea una sentencia `return`, y funcionar√≠a de igual forma:

```c
void A(int *a) {
    *a = 5;
    return;
}
```

En el caso de las funciones de tipo `void`, no es necesario devolver un valor, y el uso de `return` al final de la funci√≥n es opcional, ya que la funci√≥n termina autom√°ticamente al llegar al final de su cuerpo.

---

Las funciones son una de las caracter√≠sticas m√°s importantes del lenguaje C, ya que permiten dividir el programa en partes m√°s peque√±as y manejables. Adem√°s, al usar `return`, el flujo de control se puede modificar de forma m√°s precisa, y los valores de retorno facilitan la comunicaci√≥n entre las funciones y el programa principal.




## 6.2. Argumentos de las funciones, llamada por valor y por ![](Aspose.Words.ae55ca77-bd47-4be1-a802-7483922c91a3.005.png)"referencia".

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Una vez conocido el uso de la funci√≥n `return`, podemos introducirnos en la explicaci√≥n de las funciones. En primer lugar, si una funci√≥n usa argumentos, es necesario declarar variables que acepten los argumentos de la funci√≥n. Veamos un ejemplo:

### Ejemplo de funci√≥n con par√°metros

```c
int EstaEn(char *cad, char c) {  /* Devuelve 1 si el car√°cter c est√° en el string cad */
    while (*cad != '\0') {
        if (*cad == c)
            return 1;
        cad++;
    }
    return 0;
}
````

Esta funci√≥n, que busca un car√°cter en una cadena, podr√≠a ser llamada desde otra funci√≥n de la siguiente forma:

```c
char cadena[] = "Esta es una cadena de prueba";
if (EstaEn(cadena, 'a'))
    printf("Esta");
else
    printf("No esta");
```

### Paso de par√°metros en C

A diferencia de otros lenguajes, el lenguaje C solo permite pasar par√°metros a las funciones **por valor**. Esto significa que cuando una variable se pasa como argumento a una funci√≥n, se pasa una copia de su valor. Si se desea que los cambios efectuados en una funci√≥n sobre una variable afecten fuera del alcance de la funci√≥n, es posible simular un **paso por referencia** mediante el uso de **punteros**.

Si a una funci√≥n le pasamos como argumento la **direcci√≥n de una variable**, cualquier modificaci√≥n que se realice en esa direcci√≥n afectar√° al valor de la variable original. De esta manera, conseguimos el mismo efecto que un paso por referencia.

### Ejemplo con punteros (simulando paso por referencia)

```c
#include <stdio.h>

void Alfa(int *val, float pos) {
    *val = 5;  // Modifica el valor de la variable apuntada por val
    pos = 7.7; // Modifica la copia local de pos, no la original
    return;
}

void Beta(int val, float *pos) {
    val = 10;  // Modifica la copia local de val, no la original
    *pos = 14.7;  // Modifica el valor de la variable apuntada por pos
}

int main(void) {
    int a = 6;
    float b = 9.87;

    printf("Al principio valen a=%d b=%f\n", a, b);
    
    Alfa(&a, b);  // Pasa la direcci√≥n de a, pero b por valor

    printf("Despu√©s de Alfa valen a=%d b=%f\n", a, b);
    
    Beta(a, &b);  // Pasa a por valor, pero la direcci√≥n de b

    printf("Despu√©s de Beta valen a=%d b=%f\n", a, b);
}
```

### Resultado del programa:

```
Al principio valen a=6 b=9.87
Despu√©s de Alfa valen a=5 b=9.87
Despu√©s de Beta valen a=5 b=14.7
```

### Explicaci√≥n:

* En la funci√≥n `Alfa`, se pasa la direcci√≥n de la variable `a` (usando `&a`), lo que permite que cualquier cambio hecho en `*val` modifique directamente el valor de `a`. En cambio, la variable `b` se pasa por valor, por lo que la modificaci√≥n de `pos` no afecta el valor de `b` fuera de la funci√≥n.

* En la funci√≥n `Beta`, se pasa la variable `a` por valor, por lo que no se modifica fuera de la funci√≥n. Sin embargo, la variable `b` se pasa por referencia (mediante el puntero `&b`), por lo que cualquier cambio en `*pos` afectar√° directamente a `b` fuera de la funci√≥n.

---

Este mecanismo de paso de par√°metros es fundamental en C, especialmente cuando necesitamos modificar el estado de variables en funciones o trabajar con estructuras complejas sin copiar grandes cantidades de datos. Con los punteros, C permite un control muy preciso sobre la memoria y el flujo de datos.



## 6.3. Arrays como argumentos de funciones.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Un aspecto a tener muy en cuenta es que C no permite el paso de un array por valor a una funci√≥n. Un array es siempre pasado por "referencia", pues en la llamada, lo que se pasa es la direcci√≥n del primer elemento del array (recu√©rdese que el nombre de un array es un puntero al primer elemento). Por valor, tan solo es posible pasar por valor elementos individuales del array, pero no el array completo.

### Ejemplo de paso de un array por referencia

```c
#include <stdio.h>

void PasoValorReferencia(int *array, int valor) {
    array[5] = -8.6;  // Modifica el valor del elemento en la posici√≥n 5
    valor = 4;         // Modifica la copia local de valor, no la original
}

int main(void) {
    int array[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};  // Inicializa un array
    PasoValorReferencia(array, array[3]);  // Pasa el array por referencia

    // Imprime los valores modificados en el array
    printf("Array[5] vale: %d y array[3] vale: %d\n", array[5], array[3]);  
    return 0;
}
````

**Resultado en pantalla:**

```
Array[5] vale: -8 y array[3] vale: 0
```

En este ejemplo, vemos que el cambio realizado en `array[5]` se refleja correctamente en el array, porque el array se pasa por referencia. Sin embargo, el valor de `array[3]` no se modifica porque `valor` se pasa por valor y cualquier cambio sobre √©l no afecta la variable original.

---

## 6.4. Argumentos de la funci√≥n `main`

La funci√≥n `main()`, como toda funci√≥n de C, acepta argumentos. Los argumentos que acepta la funci√≥n `main()` son un entero (`int argc`), un array de punteros a strings (`char *argv[]`), y otro array de punteros a strings (`char *env[]`). Aunque los nombres de estos argumentos no tienen por qu√© ser `argc`, `argv`, y `env`, en toda la literatura de C se usan esos nombres y, por lo tanto, los respetaremos en este caso.

Los significados de los par√°metros `argc`, `argv` y `env` son los siguientes:

* El par√°metro `argc` contiene el n√∫mero de argumentos en la l√≠nea de √≥rdenes de la llamada al programa.
* El par√°metro `argv` contiene un puntero a cada uno de los argumentos (strings) de la l√≠nea de √≥rdenes de la llamada al programa.
* El par√°metro `env` contiene un puntero a cada una de las variables de ambiente (strings) del sistema operativo.

### Ejemplo de programa que usa argumentos de la l√≠nea de √≥rdenes

```c
#include <stdio.h>

int main(int argc, char *argv[], char *env[]) {
    int i;

    printf("El valor de argc es: %d\n", argc);

    for (i = 0; i < argc; i++)
        printf("El argumento %d es: %s\n", i, argv[i]);

    for (i = 0; env[i] != NULL; i++)
        printf("La variable de ambiente %d es: %s\n", i, env[i]);

    return 0;
}
```

### Ejecuci√≥n del programa:

Supongamos que el programa lo hemos llamado `prueba.exe`, y lo llamamos con la siguiente l√≠nea:

```
prueba.exe Este_es_el_argumento_1 Este_es_el_argumento_2
```

**Salida esperada:**

```
El valor de argc es: 3
El argumento 0 es: prueba.exe
El argumento 1 es: Este_es_el_argumento_1
El argumento 2 es: Este_es_el_argumento_2
La variable de ambiente 0 es: COMSPEC=C:\DOS\COMMAND.COM
La variable de ambiente 1 es: TEMP=C:\WINDOWS\TEMP
La variable de ambiente 2 es: PROMPT=$P$G
```

Como se observa, existen 3 argumentos, numerados de 0 a 2. El argumento 0 es siempre el nombre del programa, y el resto de los argumentos son los que se pasan en la l√≠nea de √≥rdenes. El n√∫mero y valor de las variables de ambiente depende del sistema operativo (MS-DOS, UNIX, etc.) y de la configuraci√≥n del procesador de comandos del sistema operativo.

Este ejemplo muestra c√≥mo se pueden gestionar y acceder tanto a los argumentos pasados en la l√≠nea de √≥rdenes como a las variables de ambiente del sistema operativo, lo cual es √∫til para programas que necesitan interactuar de manera din√°mica con su entorno.




## 6.5. Recursividad.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Una funci√≥n de C puede llamarse a s√≠ misma. Este proceso recibe el nombre de **recursividad**. Los ejemplos de recursividad son abundantes, siendo uno de los m√°s habituales la funci√≥n factorial:

```c
unsigned Factorial(unsigned num) {
    if (num == 0) return 1;
    return num * Factorial(num - 1);
}
```

La recursividad es una poderosa herramienta de programaci√≥n, sin embargo, presenta dos problemas:

1. La velocidad de ejecuci√≥n de un algoritmo programado de forma recursiva es mucho m√°s lento que el programado de forma iterativa.
2. La recursividad, si es excesiva, puede ocasionar el desbordamiento de la pila, y con ello, el fallo en la ejecuci√≥n del programa.

Sin embargo, el uso de la recursividad es frecuente en campos como la inteligencia artificial, etc., y en la implementaci√≥n de ciertos algoritmos tales como el algoritmo de ordenaci√≥n *QuickSort*, muy dif√≠cil de implementar de forma iterativa, pero relativamente sencillo de forma recursiva.

---


## 6.6.Punteros a funciones.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Al igual que cualquier otro tipo de dato, una **funci√≥n** ocupa una direcci√≥n de memoria, y por tanto, puede ser apuntada por un **puntero**. La declaraci√≥n de un **puntero a una funci√≥n** es:

```c
tipo de dato (*nombre de la variable)(prototipo);
```

Veamos algunos ejemplos:

```c
int (*a)(int, float);
void (*b)(void);
```

Generalmente, los punteros a funciones se usan en la programaci√≥n de bajo nivel, tales como:

* Modificaci√≥n de interrupciones.
* Creaci√≥n de controladores de dispositivos, etc.



## 6.7. El modificador de almacenamiento static aplicado a funciones.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Al igual que en el caso de las variables globales, es posible aplicar delante de una funci√≥n el modificador de almacenamiento *static*. Dicho modificador hace que la funci√≥n sobre la que se aplica sea local al m√≥dulo donde se encuentra, y no pueda ser conocida por los restantes m√≥dulos del programa, de igual forma a como suced√≠a con las variables globales. Esta modificaci√≥n del alcance de una funci√≥n permite realizar un mejor encapsulado del c√≥digo y simplificar la programaci√≥n en proyectos de gran envergadura.

## Tema 7 - Estructuras, campos de bit, uniones y

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

**enumeraciones.**

## 7.1. Estructuras.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)





Una **estructura** es un conjunto de variables que se referencian bajo el mismo nombre. La sintaxis de la declaraci√≥n de una estructura en lenguaje C es:

```c
struct nombre_estructura {
    tipo nombre_variable;    
    tipo nombre_variable;    
    ...
    tipo nombre_variable; 
} variables_estructura;
```

Es posible no poner el nombre de la estructura (`nombre_estructura`), o bien, no crear en el momento de declarar la estructura ninguna variable de la estructura (`variables_estructura`), pero no es posible eliminar la aparici√≥n de ambos elementos. Veamos algunos ejemplos de declaraci√≥n de estructuras:

```c
struct LISTA {
    int tam;
    char cadena[50];
} var_lista;

struct DATO {
    int tam;
    float vector[3];
    struct DATO *siguiente;
};

struct {
    float a, b;
    unsigned long i, j;
    char cadena[5];
} memo[10];

struct ALFA {
    int a;
    float b;
};

struct BETA {
    struct ALFA alfa;
    float c, d;
} variable;
```

Para referenciar un elemento de una estructura se realiza de la siguiente forma:

```c
variables_estructura.nombre_variable;
```

As√≠, pod√≠amos referenciar los elementos de las estructuras anteriores de la siguiente forma:

```c
var_lista.tam;
var_lista.cadena;
var_lista.cadena[7];
memo[2].a;
memo[6].cadena[3];
variable.alfa.a;
variable.c;
```

### Paso de estructuras como par√°metros a funciones

Un aspecto que es necesario aclarar es el **paso de estructuras** como par√°metros a las funciones. A una funci√≥n es posible pasarle:

* Un elemento de los que componen la estructura.
* Una estructura entera.
* Un array de estructuras.

En caso de pasarle un **elemento de la estructura**, el paso se hace siguiendo las reglas del tipo del cual sea ese elemento. En el caso de una **estructura entera**, C la pasa, a no ser que se le indique lo contrario, por valor. Y en el caso de un **array de estructuras**, como todo array, lo pasar√° por "referencia".

Conviene aclarar en este momento que si la estructura posee en su interior un **array de elementos**, la estructura puede ser pasada por valor a una funci√≥n, pero el array ser√° pasado siempre por referencia. En concreto, a la funci√≥n se le pasar√° por valor un puntero al primer elemento del array.

Veamos todo esto en un ejemplo:

```c
struct ALFA {
    int a;
    char b[20];
};

void PasoDeElementos(int val, char *cadena) {
    val = 15;
    cadena[7] = 'a';
}

void PasoDeLaEstructuraPorValor(struct ALFA a) {
    a.val = 14;
    a.cadena[6] = 'b';
}

void PasoDeLaEstructuraPorReferencia(struct ALFA *a) {
    *(a->val) = 13;
    *(a->cadena)[5] = 'c';
}

void PasoDeUnArrayDeEstructuras(struct ALFA *a) {
    a[4].val = 12;
    a[5].cadena[4] = 'd';
}

int main(void) {
    struct ALFA a, b[10];
    PasoDeElementos(a.val, a.b);
    PasoDeLaEstructuraPorValor(a);
    PasoDeLaEstructuraPorReferencia(&a);
    PasoDeUnArrayDeEstructuras(b);

    return 0;
}
```

En el paso de una estructura por **referencia**, se ha usado una construcci√≥n `*(variable_estructura.nombre_variable)`. Esta construcci√≥n asigna el valor que se desea a esa variable de la estructura, pues `variable_estructura.nombre_variable` es un puntero a la variable. El uso de los par√©ntesis es necesario, pues el operador `.` tiene menor prioridad que el operador `*`.

Es por ello que C introduce un nuevo operador, el operador `->`. Este operador es equivalente al otro, pero m√°s c√≥modo y f√°cil de escribir y de usar. Entonces, podr√≠amos haber escrito la funci√≥n de paso de una estructura por referencia de la forma siguiente:

```c
void PasoDeLaEstructuraPorReferencia(struct ALFA *a) {
    a->val = 13;
    a->cadena[5] = 'c';
}
```




## 7.2. Campos de bit.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Un **campo de bit** es un m√©todo predefinido por C para poder acceder a un bit de un byte. Aunque dicho acceso siempre es posible mediante operaciones con los operadores sobre bits, explicados con anterioridad, el uso de campos de bit puede a√±adir claridad al programa.

El m√©todo de declaraci√≥n de un **campo de bit** se basa en la estructura, pues un campo de bit no es m√°s que un tipo especial de estructura. El formato de declaraci√≥n de un campo de bit es:

```c
struct nombre_campo_bit {
    tipo nombre1 : longitud;
    tipo nombre2 : longitud;
    ...
    tipo nombreN : longitud;
} variables_campo_bit;
```

El **tipo** de un campo de bit debe declararse como `unsigned int` o `signed int`. Veamos un ejemplo de declaraci√≥n de un campo de bit:

```c
struct ALFA {
    unsigned a : 1;
    signed b : 2;
    unsigned : 4;   // Campo de bit sin nombre
    unsigned c : 1;
} campo;
```

En dicho ejemplo, se declara un campo de bit de tama√±o 4 al cual no se le da nombre. Eso es v√°lido, y su efecto es que esos cuatro bits no podr√≠an ser referenciados.

Es posible mezclar en la declaraci√≥n elementos normales de estructura con elementos de campo de bit. Veamos un ejemplo:

```c
struct EMP {
    char nombre[20], apellido[2][20];
    float sueldo;
    unsigned vacaciones : 1;
    unsigned enfermo : 1;
};
```



## 7.3. Uniones.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


En C, una **uni√≥n** es una posici√≥n de memoria que se usa por varias variables similares, que pueden ser de tipos diferentes. La definici√≥n de una uni√≥n es:

```c
union nombre_union {
    tipo nombre1;
    tipo nombre2;
    ...
    tipo nombreN;
} var_union;
```

Como puede observarse, su declaraci√≥n es parecida a la de una estructura. Sin embargo, en una uni√≥n, todos los tipos de datos comparten la misma direcci√≥n de memoria. As√≠, si declaramos:

```c
union ALFA {
    int a;
    char b;
} alfa;
```

Tendremos:

```
<------alfa.a------>  
Byte0    Byte1 <-alfa.b->
```

Por lo tanto, `b` tendr√° en com√∫n con `a` el byte m√°s bajo. Un ejemplo m√°s √∫til de una uni√≥n es el siguiente:

```c
union BETA {
    unsigned short a;
    char b[2];
} beta;
```

Entonces, `beta.b[0]` contendr√° el byte bajo de `beta.a`, y `beta.b[1]` contendr√° el byte alto de `beta.a`. Ello permite acceder a la parte alta o baja de dicho `unsigned short` sin necesidad de usar operadores sobre bits.



## 7.4.Enumeraciones.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)



Una **enumeraci√≥n** es un conjunto de constantes enteras con nombre que especifica todos los valores legales que pueden tener unas variables. Las enumeraciones se declaran de la siguiente forma:

```c
enum nombre_enum {
    lista_de_enumeraci√≥n
} lista_de_variables;
```

Donde, al igual que en las estructuras, puede no aparecer `nombre_enum` o `lista_de_variables`. Veamos un ejemplo de enumeraci√≥n:

```c
enum MONEDAS {
    peseta, duro, diez, cinco, cincuenta, cien, doscientas, quinientas
} monedas_espana;
```

Las enumeraciones asignan una constante entera a cada uno de los s√≠mbolos de la enumeraci√≥n, empezando por el valor `0`. Esto puede modificarse colocando en la declaraci√≥n el valor que deseamos tengan los elementos a partir de uno dado. Esto se realiza de la siguiente forma:

```c
enum CURSO {
    primero, segundo, tercero, cuarto_t = 100, quinto_t, cuarto_e = 200, quinto_e
};
```

En este caso, las constantes `primero`, `segundo` y `tercero` tienen los valores `0`, `1` y `2`, las constantes `cuarto_t` y `quinto_t` los valores `100` y `101`, y las constantes `cuarto_e` y `quinto_e` los valores `200` y `201`, respectivamente.



## 7.5.La palabra reservada typedef.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


El lenguaje C permite, mediante el uso de la palabra reservada `typedef`, definir nuevos nombres para los tipos de datos existentes. Esto no debe confundirse con la creaci√≥n de un nuevo tipo de datos. La palabra clave `typedef` permite solo asignarle un nuevo nombre a un tipo de datos ya existente. La sintaxis general de uso de `typedef` es:

```c
typedef tipo nombre;
```

Donde `tipo` es cualquier tipo de datos permitido, y `nombre` es el nuevo nombre que se desea que tenga ese tipo. Veamos algunos ejemplos:

```c
typedef int entero;

typedef struct {
    unsigned codigo;
    char nombre[40];
    char apellido[40];
} cliente;
```

Y entonces podr√≠an crearse nuevas variables de la forma:

```c
entero a;
cliente b, *c;
```



## Tema 8 - El preprocesador.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

En un programa escrito en C, es posible incluir diversas instrucciones para el compilador dentro del c√≥digo fuente del programa. Estas instrucciones dadas al compilador son llamadas directivas del preprocesador y, aunque realmente no son parte del lenguaje C, expanden el √°mbito del entorno de programaci√≥n de C.

El preprocesador, definido por el standard ANSI de C, contiene las siguientes directivas:



|#if|#ifdef|#ifndef|#else|
| - | - | - | - |
|#elif|#endif|#include|#define|
|#undef|#line|#error|#pragma|

*Tabla 9.1: Directivas del preprocesador en C.*


## 8.1. Directiva `#define`.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La directiva `#define` se usa para definir un identificador y una cadena que el compilador sustituir√° por el identificador cada vez que se encuentre en el archivo fuente. El est√°ndar ANSI llama al identificador "nombre de macro" y al proceso de sustituci√≥n "sustituci√≥n de macro". Por ejemplo:

```c
#define TRUE 1
#define FALSE 0
```

El compilador, cada vez que vea el identificador `TRUE`, lo sustituir√° por el valor `1`, e igual con `FALSE`.
El uso m√°s com√∫n de la directiva `#define` es la definici√≥n de valores constantes en el programa, tama√±os de arrays, etc.

Una caracter√≠stica que posee la directiva `#define` es que el "nombre de macro" puede contener argumentos.
Cada vez que el compilador encuentra el "nombre de macro", los argumentos reales encontrados en el programa reemplazan los argumentos asociados con el nombre de macro.
Veamos un ejemplo:

```c
#define MIN(a,b) (a<b) ? a : b
```

Si tenemos ahora en el programa:

```c
printf("El valor m√≠nimo es: %d\n", MIN(10,20));
```

El compilador sustituye el "nombre de macro" y sus argumentos en tiempo de compilaci√≥n, y ello equivale a haber escrito el c√≥digo:

```c
printf("El valor m√≠nimo es: %d\n", (10<20) ? 10 : 20);
```

---

## 8.2. Directiva `#undef`.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La directiva `#undef` permite quitar una definici√≥n de "nombre de macro" que se realiz√≥ con anterioridad.
Veamos un ejemplo:

```c
#define TAM 10
...
#undef TAM
```

A partir de `#undef TAM`, el "nombre de macro" `TAM` deja de existir.
Esto permite localizar los "nombres de macro" donde sea necesario.

---

## 8.3. Directiva `#error`.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La directiva `#error` fuerza a parar la compilaci√≥n del programa, a la vez que muestra un mensaje de error.
El mensaje de error no aparecer√° entre comillas dobles.
Veamos un ejemplo:

```c
#error Detenida compilaci√≥n
```

Su principal uso viene asociado a detener la compilaci√≥n en ciertas condiciones en asociaci√≥n con las directivas `#if`, etc., explicadas con posterioridad.

---

## 8.4. Directiva `#include`.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La directiva `#include` fuerza al compilador a incluir otro archivo fuente en el archivo que tiene la directiva `#include`, y a compilarlo.
El nombre del archivo fuente a incluir se colocar√° entre comillas dobles o entre par√©ntesis de √°ngulo.
Por ejemplo:

```c
#include <stdio.h>
#include "stdio.h"
```

Los archivos incluidos mediante `#include` pueden a su vez poseer otras directivas `#include`.

La diferencia existente entre encerrar el archivo entre par√©ntesis de √°ngulo o entre comillas dobles es que:

* En el primer caso (`<archivo>`), se busca el archivo en los directorios de la l√≠nea de √≥rdenes de compilaci√≥n y despu√©s en los directorios est√°ndar de C, **pero nunca** en el directorio de trabajo.
* En el segundo caso (`"archivo"`), el primer sitio donde se busca el archivo a incluir es en el **directorio actual de trabajo**, pas√°ndose, en caso de no haber sido encontrado, a buscar en los mismos sitios que en el caso anterior.


## 8.5. Directivas `#if`, `#ifdef`, `#ifndef`, `#else`, `#elif`, `#endif`.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Las directivas `#if`, `#ifdef`, `#ifndef`, `#else`, `#elif` y `#endif` son directivas condicionales de compilaci√≥n. Estas directivas permiten decirle al compilador qu√© partes del programa debe compilar bajo distintas condiciones.

La idea general de la directiva `#if` es que si es verdadera la expresi√≥n que se encuentra despu√©s del `#if`, se compilar√° el c√≥digo que figura entre el `#if` y el `#endif`.
La directiva `#else` funciona de igual forma que el `else` del lenguaje C.
La directiva `#elif` funciona como un escalonado de `if`.
La definici√≥n formal es:

```c
#if expresi√≥n1
    secuencia de sentencias
#elif expresi√≥n2
    secuencia de sentencias
...
#else
    secuencia de sentencias
#endif
```

Veamos algunos ejemplos:

```c
#define MEM 200

#if MEM > 100
    printf("MEM es mayor de 100");
#endif
```

```c
#define VALOR 0

#if VALOR == 0
    c = a * b / (VALOR + 1);
#else
    c = a * b / VALOR;
#endif
```

Compilar√° el c√≥digo para el caso de `VALOR == 0`.

```c
#define VALOR 15

#if VALOR < 0
    b = b / (-VALOR);
#elif VALOR == 0
    b = b / (VALOR + 1);
#else
    b = b / VALOR;
#endif
```

Compilar√° el c√≥digo para el √∫ltimo caso.

Las directivas `#ifdef` y `#ifndef` se usan tambi√©n para compilaci√≥n condicional, solo que no eval√∫an expresi√≥n alguna, √∫nicamente comprueban si est√° definido (`#ifdef`) o si no est√° definido (`#ifndef`) alg√∫n nombre de macro.
Su sintaxis general es:

```c
#ifdef nombre_de_macro
    secuencia de sentencias
#else
    secuencia de sentencias
#endif
```

E igual para `#ifndef`. Veamos algunos ejemplos:

```c
#define VAL 10

#ifdef VAL
    printf("VAL definido");
#else
    printf("VAL no definido");
#endif
```

```c
#ifndef NOVAL
    printf("NOVAL no definido");
#endif
```

Compilar√° el c√≥digo para el caso de `VAL` definido y, adem√°s, compilar√° el c√≥digo de `NOVAL`, al no estar definida dicha macro.
Como se observa, no se comprueba el valor de `VAL` o de `NOVAL`, solo se comprueba si est√°n definidos o no.

---

## 8.6. Directiva `#line`.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La directiva `#line` permite cambiar la cuenta de l√≠neas del compilador y el nombre del archivo.
Su sintaxis es:

```c
#line n√∫mero ["nombre de archivo"]
```

Veamos un ejemplo:

```c
#line 100 /* Inicializa el contador de l√≠neas a 100 */
/* 10 l√≠neas */
#error Detenida compilaci√≥n
```

Indicar√° el mensaje de error en la l√≠nea *110* del programa, y no en la que suceda realmente.

---

## 8.7. Directiva `#pragma`.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La directiva `#pragma` es una directiva que permite dar instrucciones al compilador sobre c√≥mo debe realizar la compilaci√≥n del c√≥digo fuente.
Su sintaxis es:

```c
#pragma nombre
```


## Tema 9 - Entrada y salida.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Antes de empezar a explicar la entrada y salida en C, es necesario realizar dos peque√±os comentarios:

En primer lugar, para el correcto funcionamiento de la entrada y salida en C, y dado que las funciones de E/S, estructuras de datos usadas por esas funciones, etc., se encuentran declaradas en el archivo de cabecera `<stdio.h>`, es necesario incluir dicho archivo mediante la directiva del preprocesador `#include`, para que la E/S funcione correctamente. En caso contrario, puede funcionar de forma incorrecta, e incluso, puede llegar a dar errores de compilaci√≥n.

En segundo lugar, aparte de la E/S por consola y la E/S de fichero mediante b√∫fer intermedio, que ser√°n explicadas en este tema, existe una E/S de fichero sin b√∫fer intermedio, proveniente de la primitiva implementaci√≥n de C en m√°quinas UNIX, y que el est√°ndar ANSI de C no ha estandarizado, por lo cual no es recomendable su uso. Por este motivo, y dada su similitud en la mayor√≠a de apartados con el sistema de E/S de fichero mediante b√∫fer intermedio, no ser√° explicada en el presente tema.

---

## 9.1. Entrada y salida desde consola.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La entrada y salida desde consola se refiere a las operaciones que se producen en el teclado y la pantalla del ordenador. Dichos dispositivos son autom√°ticamente abiertos y cerrados al comenzar y terminar el programa, por lo cual no deben ser abiertos ni cerrados por el propio programa.

Existen, b√°sicamente, seis funciones de entrada y salida desde consola: tres de entrada y tres de salida. Ve√°moslas:

---

### `getchar()`

La funci√≥n `getchar()` lee un car√°cter desde el teclado. Su definici√≥n es:

```c
int getchar(void);
```

Esta funci√≥n lee caracteres, de uno en uno, desde el teclado, esperando la pulsaci√≥n de un retorno de carro. Es posible escribir varios caracteres antes de que se lea alguno. Hace eco en pantalla del car√°cter le√≠do. En caso de error, devuelve `EOF`.

---

### `putchar()`

La funci√≥n `putchar()` escribe un car√°cter en pantalla. Su definici√≥n es:

```c
int putchar(int c);
```

Devuelve el car√°cter escrito si la operaci√≥n fue correcta. En caso de error, devuelve `EOF`.

**Ejemplo de uso de `getchar()` y `putchar()`:**

```c
#include <stdio.h>

int main(void) {
    char ch;
    do {
        ch = getchar();
        putchar(ch);
    } while (ch != 'e' && ch != 'E');

    return 0;
}
```

Este programa lee todas las teclas pulsadas hasta encontrar una `'e'` o una `'E'`.

---

### `gets()`

La funci√≥n `gets()` lee una cadena desde el teclado. Su definici√≥n es:

```c
char *gets(char *s);
```

Lee hasta que se pulsa retorno de carro. El retorno de carro es reemplazado autom√°ticamente por el car√°cter de fin de cadena (`'\0'`). Devuelve un puntero a `s` si tiene √©xito, o `NULL` en caso de error.

---

### `puts()`

La funci√≥n `puts()` escribe una cadena en pantalla. Su definici√≥n es:

```c
int puts(const char *s);
```

Escribe la cadena seguida de un retorno de carro. Devuelve un entero no negativo en caso de √©xito, o `EOF` si ocurre un error.

**Ejemplo de uso de `gets()` y `puts()`:**

```c
#include <stdio.h>
#define TAM 100

int main(void) {
    char cadena[TAM];

    puts("Introduce una cadena:");
    gets(cadena);

    return 0;
}
```

---

### `scanf()`

La funci√≥n `scanf()` se usa para leer datos desde el teclado y convertirlos autom√°ticamente al formato adecuado. Su definici√≥n es:

```c
int scanf(const char *formato[, direcci√≥n, ...]);
```

La cadena de formato puede incluir:

* **Especificadores de formato** (precedidos por `%`),
* **Espacios en blanco**,
* **Otros caracteres literales**.

**Especificadores v√°lidos:**

| Especificador | Descripci√≥n                           |
| :-----------: | ------------------------------------- |
|      `%c`     | Leer un √∫nico car√°cter                |
|      `%d`     | Leer un entero decimal                |
|      `%i`     | Leer un entero decimal                |
|      `%e`     | Leer n√∫mero en punto flotante         |
|      `%f`     | Leer n√∫mero en punto flotante         |
|      `%g`     | Leer n√∫mero en punto flotante         |
|      `%o`     | Leer n√∫mero octal                     |
|      `%s`     | Leer cadena de caracteres             |
|      `%x`     | Leer n√∫mero hexadecimal               |
|      `%p`     | Leer un puntero                       |
|      `%n`     | Recibe el n√∫mero de caracteres le√≠dos |
|      `%u`     | Leer entero sin signo                 |

*Tabla 9.1.1: Especificadores de formato de la funci√≥n scanf().*

**Modificadores:**

* `h`: *short int* o *unsigned short int*
* `l`: *long int* o *unsigned long int*, y tambi√©n *double* para `%f`, `%e`, `%g`
* `L`: *long double* para `%f`, `%e`, `%g`

**Nota:** Los argumentos deben pasarse por referencia (direcci√≥n de memoria).

**Uso del modificador `*`:**

```c
int x, y;
scanf("%d%*c%d", &x, &y);
```

Si la entrada es `10/20`, `x = 10`, se descarta `/`, y `y = 20`.

`scanf()` devuelve el n√∫mero de campos asignados correctamente. Devuelve `EOF` en caso de error.

---

### `printf()`

La funci√≥n `printf()` se usa para escribir cualquier tipo de dato en pantalla. Su definici√≥n es:

```c
int printf(const char *formato[, argumento, ...]);
```

La cadena de formato contiene:

* Texto literal,
* Especificadores de formato, iniciados por `%`.

**Especificadores v√°lidos:**

| Especificador | Descripci√≥n                                                 |
| :-----------: | ----------------------------------------------------------- |
|      `%c`     | Car√°cter                                                    |
|      `%d`     | Entero con signo                                            |
|      `%i`     | Entero con signo                                            |
|      `%e`     | Punto flotante (notaci√≥n cient√≠fica, 'e')                   |
|      `%E`     | Punto flotante (notaci√≥n cient√≠fica, 'E')                   |
|      `%f`     | Punto flotante                                              |
|      `%g`     | M√°s corto entre `%e` y `%f`                                 |
|      `%G`     | M√°s corto entre `%E` y `%f`                                 |
|      `%o`     | Octal sin signo                                             |
|      `%s`     | Cadena de caracteres                                        |
|      `%u`     | Entero sin signo                                            |
|      `%x`     | Hexadecimal sin signo (min√∫sculas)                          |
|      `%X`     | Hexadecimal sin signo (may√∫sculas)                          |
|      `%p`     | Direcci√≥n de puntero                                        |
|      `%n`     | Puntero a entero que recibe cantidad de caracteres impresos |
|      `%%`     | Imprime el s√≠mbolo `%`                                      |

*Tabla 9.1.2: Especificadores de formato de la funci√≥n printf().*

Igual que con `scanf()`, se pueden usar los modificadores `h`, `l`, y `L`.

`printf()` devuelve el n√∫mero de caracteres escritos o `EOF` en caso de error.

**Ejemplo de uso de `scanf()` y `printf()`:**

```c
#include <stdio.h>

int main(void) {
    int a, b;

    printf("\nIntroduce el valor de a: ");
    scanf("%d", &a);
    
    printf("\nIntroduce el valor de b: ");
    scanf("%d", &b);

    if (b != 0)
        printf("\nEl valor de %d dividido %d es: %f\n", a, b, (float)a / b);
    else
        printf("\nError, b vale 0\n");

    return 0;
}
```



## 9.2. Entrada y salida desde fichero.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


### Entrada y salida desde ficheros en C

Antes de explicar la entrada y salida desde fichero, conviene entender el tipo de dato `FILE *`. Este tipo representa un **puntero de fichero**, que en realidad es una estructura que contiene informaci√≥n como:

* Nombre del fichero abierto
* Modo de apertura (lectura, escritura, etc.)
* Estado del archivo, entre otros

Este puntero especifica el archivo que se est√° usando, permitiendo a las funciones de entrada/salida saber sobre qu√© archivo actuar.

---

### Apertura y cierre de archivos

Antes de usar un archivo, es **necesario abrirlo**, y tras su uso, **cerrarlo**. Esto se hace mediante las funciones `fopen()` y `fclose()`:

#### `FILE *fopen(char *nombre, char *modo);`

* `nombre`: nombre del archivo
* `modo`: modo de apertura

#### Modos de apertura:

| **Modo** | **Descripci√≥n**                               |
| -------- | --------------------------------------------- |
| r        | Abrir archivo para lectura                    |
| w        | Crear archivo para escritura                  |
| a        | Abrir archivo para a√±adir                     |
| rb       | Abrir archivo binario para lectura            |
| wb       | Crear archivo binario para escritura          |
| ab       | Abrir archivo binario para a√±adir             |
| rt       | Abrir archivo de texto para lectura           |
| wt       | Crear archivo de texto para escritura         |
| at       | Abrir archivo de texto para a√±adir            |
| r+       | Abrir archivo para lectura/escritura          |
| w+       | Crear archivo para lectura/escritura          |
| a+       | Abrir archivo para leer/a√±adir                |
| r+b      | Abrir archivo binario para lectura/escritura  |
| w+b      | Crear archivo binario para lectura/escritura  |
| a+b      | Abrir archivo binario para leer/a√±adir        |
| r+t      | Abrir archivo de texto para lectura/escritura |
| w+t      | Crear archivo de texto para lectura/escritura |
| a+t      | Abrir archivo de texto para leer/a√±adir       |

> **Nota**: Si no se especifica binario o texto, depender√° del sistema. Generalmente se abre en modo texto.

#### Diferencias entre modo texto y binario:

* En modo **texto**, las secuencias como `\r\n` se convierten a `\n` al leer.
* En modo **binario**, no hay conversiones. Se mantiene la informaci√≥n original.

#### Comprobaci√≥n de apertura:

```c
FILE *fp;
if ((fp = fopen("prueba", "w")) == NULL) {
    puts("\nNo puedo abrir el fichero\n");
    exit(1);
}
```

---

#### `int fclose(FILE *fp);`

Cierra el archivo, liberando:

* El **buffer** (guardando datos si es necesario)

* El **control de archivo**, permitiendo abrir otros archivos

* Devuelve `0` si se cerr√≥ correctamente.

* Devuelve otro valor en caso de error.

---

### Ejemplo de `fopen()` y `fclose()`:

```c
#include <stdio.h>

int main(int argc, char *argv[]) {
    FILE *fp;

    if (argc != 2) {
        puts("Nombre del fichero no pasado");
        return 0;
    }

    if ((fp = fopen(argv[1], "r")) == NULL) {
        printf("Error abriendo el fichero: %s\n", argv[1]);
        return 0;
    }

    if (fclose(fp)) {
        puts("Error cerrando el fichero");
        return 1;
    }

    return 0;
}
```

---

### Principales funciones de lectura/escritura:

```c
int getc(FILE *fp);
int putc(int ch, FILE *fp);
char *fgets(char *str, int n, FILE *fp);
int fputs(const char *str, FILE *fp);
int fscanf(FILE *fp, const char *formato [, direcci√≥n, ...]);
int fprintf(FILE *fp, const char *formato [, argumento, ...]);
int fread(void *memoria, int num, int cont, FILE *fp);
int fwrite(void *memoria, int num, int cont, FILE *fp);
```

#### Descripciones:

* **`getc()`**: Lee un car√°cter. Devuelve `EOF` al final del archivo.
* **`putc()`**: Escribe un car√°cter. Devuelve `EOF` en caso de error.
* **`fgets()`**: Lee hasta `n-1` caracteres o hasta salto de l√≠nea. Conserva el `\n`.
* **`fputs()`**: Escribe una cadena, sin a√±adir salto de l√≠nea.
* **`fscanf()` / `fprintf()`**: Lectura/escritura con formato, como `scanf()` y `printf()`.

---

### `fread()` y `fwrite()` (bloques de datos)

```c
int fread(void *memoria, int num, int cont, FILE *fp);
int fwrite(void *memoria, int num, int cont, FILE *fp);
```

* `memoria`: puntero a buffer de lectura/escritura
* `num`: tama√±o de cada bloque
* `cont`: n√∫mero de bloques
* `fp`: archivo asociado

> Devuelven el n√∫mero de **bloques** le√≠dos/escritos, no bytes.

> No realizan conversiones de texto ‚Üí se usan para archivos binarios.

#### Ejemplo de uso:

```c
#include <stdio.h>
#define TAM 1000

int main(int argc, char *argv[]) {
    FILE *f_inp, *f_out;
    char buffer[TAM];
    int num;

    if (argc != 3) return 0;

    if ((f_inp = fopen(argv[1], "rb")) == NULL) return 0;
    if ((f_out = fopen(argv[2], "wb")) == NULL) exit(1);

    while ((num = fread(buffer, sizeof(char), TAM, f_inp)) != 0)
        fwrite(buffer, sizeof(char), num, f_out);

    if (fclose(f_inp) || fclose(f_out))
        exit(1);

    return 0;
}
```

---

### Funciones adicionales

#### `int ferror(FILE *fp);`

* Devuelve 0 si no hay error, distinto de 0 si lo hubo.

#### `void rewind(FILE *fp);`

* Posiciona el puntero de archivo al **inicio**.

#### `int fseek(FILE *fp, long num, int origen);`

* Mueve el puntero de archivo.
* `num`: desplazamiento
* `origen`: posici√≥n base

| **Origen**           | **Constante** | **Valor** |
| -------------------- | ------------- | --------- |
| Comienzo del archivo | SEEK\_SET     | 0         |
| Posici√≥n actual      | SEEK\_CUR     | 1         |
| Final del archivo    | SEEK\_END     | 2         |

> **Nota**: Solo funciona correctamente en archivos **binarios**, no en modo texto.

#### Ejemplo de `fseek()`:

```c
#include <stdio.h>

int LeeCaracter(FILE *fp, long pos, int origen) {
    if (fseek(fp, pos, origen))
        return EOF;
    return getc(fp);
}
```

---

### Archivos est√°ndar

Se abren autom√°ticamente al iniciar el programa:

* **`stdin`** ‚Üí entrada est√°ndar (teclado)
* **`stdout`** ‚Üí salida est√°ndar (pantalla)
* **`stderr`** ‚Üí salida de error est√°ndar

Son de tipo `FILE *`, por lo que se pueden usar con funciones de fichero.

#### Ejemplo:

```c
char cadena[100];
fgets(cadena, 100, stdin);    // Leer desde teclado
fputs(cadena, stderr);        // Escribir en salida de error
```


## Tema 10 - Asignaci√≥n din√°mica de memoria.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Antes de empezar con el desarrollo del tema, es necesario aclarar que el mismo no pretende explicar las estructuras de datos din√°micas, sino tan solo dar unas ligeras nociones b√°sicas sobre la posibilidad de asignar memoria de forma din√°mica, esto es, en tiempo de ejecuci√≥n, y por tanto de crear nuevas variables.

Las funciones que realizan un manejo activo de la memoria del sistema requieren todas ellas para su correcto funcionamiento la inclusi√≥n, mediante la directiva del prepocesador **#include** del archivo de cabecera **<stdlib.h>**.


## 10.1. Reserva din√°mica de memoria

En C, la **reserva din√°mica de memoria** se realiza mediante funciones espec√≠ficas. Aunque existen varias (ver Ap√©ndice A), aqu√≠ se explicar√° √∫nicamente el uso de la funci√≥n `*malloc()*`.

La declaraci√≥n de `malloc()` es:

```c
void *malloc(unsigned num_bytes);
```

Donde `num_bytes` es el n√∫mero de bytes que se desean reservar. La funci√≥n devuelve un puntero de tipo `void *` (sin tipo), que debe convertirse expl√≠citamente al tipo de puntero deseado mediante *casting*. Por ejemplo:

```c
int *a;
a = (int *)malloc(sizeof(int));
*a = 3;
```

Si no se puede reservar la memoria (por falta de recursos, por ejemplo), `malloc()` devuelve `NULL`. Por tanto, siempre debe comprobarse su valor antes de utilizarlo. Ejemplos:

```c
float *a;
a = (float *)malloc(sizeof(float));
if (a == NULL) exit(0); // Salimos del programa

unsigned long int *b;
if ((b = (unsigned long int *)malloc(sizeof(unsigned long int))) == NULL)
    exit(0); // Salimos del programa

struct ALFA {
    unsigned a;
    float b;
    int *c;
} *d;

if ((d = (struct ALFA *)malloc(sizeof(struct ALFA))) == NULL)
    exit(0); // Salimos del programa
```

---

## 10.2. Liberaci√≥n din√°mica de memoria

La memoria reservada din√°micamente se libera autom√°ticamente al finalizar el programa. Sin embargo, puede ser necesario liberarla antes, durante la ejecuci√≥n. Para ello se usa la funci√≥n `free()`:

```c
void free(void *p);
```

Donde `p` es el puntero cuya memoria asociada se desea liberar. Ejemplo:

```c
int *a;
if ((a = (int *)malloc(sizeof(int))) == NULL)
    exit(0);

// ...

free(a);
```

> ‚ö†Ô∏è El puntero pasado a `free()` **no debe ser NULL**, ya que esto puede causar errores en tiempo de ejecuci√≥n. Por eso es tan importante comprobar siempre el retorno de `malloc()`.

---

## 10.3. Ejemplo de asignaci√≥n y liberaci√≥n din√°mica de memoria

Vamos a implementar una lista ligada (linked list) de forma din√°mica. Primero definimos la estructura:

```c
struct LISTA {
    tipo dato;
    struct LISTA *sig;
};
```

Donde `tipo` puede ser cualquier tipo v√°lido en C (`int`, `float`, etc.).

Variables necesarias:

```c
struct LISTA *cabeza = NULL, *p;
tipo dato;
```

### Funci√≥n para insertar un elemento por la cabeza:

```c
struct LISTA *CrearLista(struct LISTA *cabeza, tipo dato) {
    struct LISTA *p;
    if ((p = (struct LISTA *)malloc(sizeof(struct LISTA))) == NULL)
        exit(0); // Salimos del programa

    p->dato = dato;
    p->sig = cabeza;
    return p;
}
```

Llamada:

```c
cabeza = CrearLista(cabeza, dato);
```

---

### Funci√≥n para buscar un elemento:

```c
struct LISTA *BuscarLista(struct LISTA *p, tipo dato) {
    while (p != NULL && p->dato != dato)
        p = p->sig;
    return p;
}
```

Llamada:

```c
if ((p = BuscarLista(cabeza, dato)) != NULL)
    // El elemento ha sido encontrado
```

---

### Funci√≥n para liberar un nodo de la lista:

```c
struct LISTA *LiberarLista(struct LISTA *cabeza, tipo dato) {
    struct LISTA *p = cabeza, *q = NULL;

    if (p != NULL) {
        if (p->dato == dato) {
            cabeza = p->sig;
            free(p);
        } else {
            while (p != NULL && p->dato != dato) {
                q = p;
                p = p->sig;
            }

            if (p != NULL) {
                q->sig = p->sig;
                free(p);
            }
        }
    }
    return cabeza;
}
```

Llamada:

```c
cabeza = LiberarLista(cabeza, dato);
```


## Ap√©ndice A - Funciones de biblioteca del

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


Antes de comenzar a describir las funciones de biblioteca del est√°ndar ANSI de C, es importante tener en cuenta lo siguiente:

* Existen **muchas m√°s funciones** que las aqu√≠ descritas.
* Sin embargo, este conjunto representa una base **suficientemente amplia** para realizar todas las operaciones b√°sicas necesarias.
* Las funciones est√°n **clasificadas seg√∫n su prop√≥sito** (entrada/salida, manipulaci√≥n de memoria, etc.) para facilitar su consulta y uso.

### Estructura de presentaci√≥n de cada funci√≥n

Cada funci√≥n se presenta con la siguiente informaci√≥n:

* **Nombre de la funci√≥n:**
  *fclose*

* **Fichero de inclusi√≥n (`#include`) donde se encuentra su prototipo:**
  `#include <stdio.h>`

* **Formato de la funci√≥n (prototipo):**
  `int fclose(FILE *f);`

* **Descripci√≥n breve de la funci√≥n:**
  Cierra un archivo previamente abierto. Libera los recursos asociados y asegura que toda la informaci√≥n pendiente se haya escrito correctamente.


## A.1 Funciones de entrada y salida de datos

[![√çNDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

---

### `fclose`

```c
#include <stdio.h>
int fclose(FILE *f);
```

Cierra el archivo asociado a `f` y vuelca su buffer al disco. Devuelve 0 si tuvo √©xito, y distinto de cero en caso de error.

---

### `feof`

```c
#include <stdio.h>
int feof(FILE *f);
```

Comprueba si se alcanz√≥ el final del archivo. Devuelve un valor distinto de cero si es as√≠, 0 en caso contrario.

---

### `ferror`

```c
#include <stdio.h>
int ferror(FILE *f);
```

Detecta errores en operaciones sobre el archivo. Devuelve 0 si no hay errores, valor distinto de cero si existen errores.

---

### `fflush`

```c
#include <stdio.h>
int fflush(FILE *f);
```

Vuelca el contenido del buffer al archivo (si es de salida) o lo vac√≠a (si es de entrada). Devuelve 0 si tuvo √©xito.

---

### `fgetc`

```c
#include <stdio.h>
int fgetc(FILE *f);
```

Lee un car√°cter del archivo y lo devuelve como `int`.

---

### `fgets`

```c
#include <stdio.h>
char *fgets(char *cad, int num, FILE *f);
```

Lee hasta `num-1` caracteres o hasta nueva l√≠nea/EOF. Devuelve `cad` si tuvo √©xito, o `NULL` si hay error.

---

### `fopen`

```c
#include <stdio.h>
FILE *fopen(const char *nombre, const char *modo);
```

Abre un archivo y devuelve un puntero a `FILE`. Si falla, devuelve `NULL`.

#### Modos de apertura:

| Modo | Descripci√≥n                     |
| ---- | ------------------------------- |
| r    | Lectura                         |
| w    | Escritura (crea nuevo)          |
| a    | A√±adir                          |
| rb   | Binario - lectura               |
| wb   | Binario - escritura             |
| ab   | Binario - a√±adir                |
| r+   | Lectura/escritura               |
| w+   | Crear y leer/escribir           |
| a+   | Leer/a√±adir                     |
| r+b  | Binario lectura/escritura       |
| w+b  | Crear binario lectura/escritura |
| a+b  | Leer/a√±adir binario             |
| rt   | Texto lectura                   |
| wt   | Texto escritura                 |
| at   | Texto a√±adir                    |

---

### `fprintf`

```c
#include <stdio.h>
int fprintf(FILE *f, const char *formato, ...);
```

Escribe en el archivo `f` seg√∫n el formato especificado. Devuelve n√∫mero de caracteres escritos, o negativo en error.

---

### `fputc`

```c
#include <stdio.h>
int fputc(int c, FILE *f);
```

Escribe un car√°cter en el archivo. Devuelve `c` o `EOF` si falla.

---

### `fputs`

```c
#include <stdio.h>
int fputs(const char *cad, FILE *f);
```

Escribe la cadena `cad` en el archivo. No escribe el car√°cter nulo final.

---

### `fread`

```c
#include <stdio.h>
int fread(void *buf, size_t tam, size_t cuenta, FILE *f);
```

Lee `cuenta` elementos de `tam` bytes y los almacena en `buf`. Devuelve el n√∫mero de elementos realmente le√≠dos.

---

### `fscanf`

```c
#include <stdio.h>
int fscanf(FILE *f, const char *formato, ...);
```

Lee desde el archivo como `scanf()` lo hace desde teclado.

---

### `fseek`

```c
#include <stdio.h>
int fseek(FILE *f, long desp, int origen);
```

Mueve el cursor del archivo. `origen` puede ser:

| Origen               | Constante  | Valor |
| -------------------- | ---------- | ----- |
| Comienzo del archivo | `SEEK_SET` | 0     |
| Posici√≥n actual      | `SEEK_CUR` | 1     |
| Final del archivo    | `SEEK_END` | 2     |

---

### `ftell`

```c
#include <stdio.h>
long ftell(FILE *f);
```

Devuelve la posici√≥n actual del cursor en el archivo. Devuelve `-1L` en caso de error.

---

### `fwrite`

```c
#include <stdio.h>
int fwrite(const void *buf, size_t tam, size_t cuenta, FILE *f);
```

Escribe `cuenta` elementos de `tam` bytes desde `buf` en el archivo.

---

### `getc`

```c
#include <stdio.h>
int getc(FILE *f);
```

Lee el siguiente car√°cter del archivo. Devuelve `EOF` al final del archivo.

---

### `gets` (obsoleta/no recomendada)

```c
#include <stdio.h>
char *gets(char *cad);
```

Lee una l√≠nea desde `stdin` sin l√≠mite de longitud. Puede causar desbordamientos de buffer.

---

### `perror`

```c
#include <stdio.h>
int perror(const char *cad);
```

Muestra el mensaje de error asociado al valor de `errno`, precedido por `cad`.

---

### `printf`

```c
#include <stdio.h>
int printf(const char *formato, ...);
```

Imprime datos en `stdout` (pantalla). Devuelve n√∫mero de caracteres escritos, o valor negativo en error.

#### Especificadores de formato:

| C√≥digo | Significado                  |
| ------ | ---------------------------- |
| %c     | Car√°cter                     |
| %d/%i  | Entero con signo             |
| %e/%E  | Notaci√≥n cient√≠fica          |
| %f     | Punto flotante               |
| %g/%G  | M√°s corto entre `%e` y `%f`  |
| %o     | Octal sin signo              |
| %s     | Cadena de caracteres         |
| %u     | Entero sin signo             |
| %x/%X  | Hexadecimal sin signo        |
| %p     | Puntero                      |
| %n     | Escribe n√∫mero de caracteres |
| %%     | Imprime el s√≠mbolo `%`       |

Modificadores: `h` (short), `l` (long), `L` (long double)

---

### `putc`

```c
#include <stdio.h>
int putc(int c, FILE *f);
```

Escribe un car√°cter en el archivo. Devuelve el car√°cter escrito o `EOF`.

---

### `puts`

```c
#include <stdio.h>
int puts(char *cad);
```

Escribe la cadena `cad` en `stdout`, seguido de un salto de l√≠nea.

---

### `rewind`

```c
#include <stdio.h>
void rewind(FILE *f);
```

Reposiciona el archivo al inicio y limpia indicadores de error y EOF.

---

### `scanf`

```c
#include <stdio.h>
int scanf(const char *formato, ...);
```

Lee desde `stdin` seg√∫n el formato especificado. Similar a `printf()`, pero para entrada.

#### Especificadores de formato:

| C√≥digo   | Descripci√≥n                 |
| -------- | --------------------------- |
| %c       | Car√°cter                    |
| %d/%i    | Entero decimal              |
| %e/%f/%g | Punto flotante              |
| %o       | Octal                       |
| %x       | Hexadecimal                 |
| %s       | Cadena de caracteres        |
| %u       | Entero sin signo            |
| %p       | Puntero                     |
| %n       | N√∫mero de caracteres le√≠dos |



## A.2 - Funciones de caracteres (`<ctype.h>`)

[![√çNDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

### `isalnum`

```c
#include <ctype.h>
int isalnum(int ch);
```

Devuelve un valor distinto de cero si `ch` es una letra del alfabeto o un d√≠gito. En caso contrario, devuelve cero.

---

### `isalpha`

```c
#include <ctype.h>
int isalpha(int ch);
```

Devuelve un valor distinto de cero si `ch` es una letra del alfabeto. En cualquier otro caso, devuelve cero.

---

### `iscntrl`

```c
#include <ctype.h>
int iscntrl(int ch);
```

Devuelve un valor distinto de cero si `ch` est√° entre `0` y `0x1F` o si es igual a `0x7F` (tecla DEL). En cualquier otro caso, devuelve cero.

---

### `isdigit`

```c
#include <ctype.h>
int isdigit(int ch);
```

Devuelve un valor distinto de cero si `ch` es un d√≠gito (`0..9`). En cualquier otro caso, devuelve cero.

---

### `isgraph`

```c
#include <ctype.h>
int isgraph(int ch);
```

Devuelve un valor distinto de cero si `ch` es un car√°cter imprimible distinto del espacio. En caso contrario, devuelve cero.

---

### `islower`

```c
#include <ctype.h>
int islower(int ch);
```

Devuelve un valor distinto de cero si `ch` es una letra min√∫scula. En cualquier otro caso, devuelve cero.

---

### `isprint`

```c
#include <ctype.h>
int isprint(int ch);
```

Devuelve un valor distinto de cero si `ch` es un car√°cter imprimible, incluyendo el espacio. En cualquier otro caso, devuelve cero.

---

### `ispunct`

```c
#include <ctype.h>
int ispunct(int ch);
```

Devuelve un valor distinto de cero si `ch` es un car√°cter de puntuaci√≥n (excluye el espacio). En cualquier otro caso, devuelve cero.

---

### `isspace`

```c
#include <ctype.h>
int isspace(int ch);
```

Devuelve un valor distinto de cero si `ch` es un espacio, tabulador o car√°cter de salto de l√≠nea. En cualquier otro caso, devuelve cero.

---

### `isupper`

```c
#include <ctype.h>
int isupper(int ch);
```

Devuelve un valor distinto de cero si `ch` es una letra may√∫scula. En cualquier otro caso, devuelve cero.

---

### `isxdigit`

```c
#include <ctype.h>
int isxdigit(int ch);
```

Devuelve un valor distinto de cero si `ch` es un d√≠gito hexadecimal (`0..9`, `A..F`, `a..f`). En cualquier otro caso, devuelve cero.

---

### `tolower`

```c
#include <ctype.h>
int tolower(int ch);
```

Convierte `ch` a min√∫scula si es una letra may√∫scula. Si no, devuelve `ch` sin modificar.

---

### `toupper`

```c
#include <ctype.h>
int toupper(int ch);
```

Convierte `ch` a may√∫scula si es una letra min√∫scula. Si no, devuelve `ch` sin modificar.

---

## A.3 - Funciones de cadenas (`<string.h>`)

[![√çNDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

### `memchr`

```c
#include <string.h>
void *memchr(const void *buffer, int ch, size_t cuenta);
```

Busca la primera ocurrencia de `ch` en los primeros `cuenta` bytes de `buffer`. Devuelve un puntero a la ocurrencia o `NULL` si no se encuentra.

---

### `memcmp`

```c
#include <string.h>
int memcmp(const void *buf1, const void *buf2, size_t cuenta);
```

Compara los primeros `cuenta` bytes de `buf1` y `buf2`. Devuelve:

| Valor devuelto | Descripci√≥n                |
| -------------- | -------------------------- |
| `< 0`          | `buf1` es menor que `buf2` |
| `0`            | `buf1` es igual a `buf2`   |
| `> 0`          | `buf1` es mayor que `buf2` |

*Tabla A.3.1: Interpretaci√≥n del valor devuelto por `memcmp()`*

---

### `memcpy`

```c
#include <string.h>
void *memcpy(void *hacia, const void *desde, size_t cuenta);
```

Copia `cuenta` bytes desde `desde` hacia `hacia`. Si se solapan, el comportamiento es indefinido. Devuelve `hacia`.

---

### `memset`

```c
#include <string.h>
void *memset(void *buf, int ch, size_t cuenta);
```

Copia el byte menos significativo de `ch` en los primeros `cuenta` bytes de `buf`. Devuelve `buf`.

---

### `strcat`

```c
#include <string.h>
char *strcat(char *cad1, const char *cad2);
```

Concatena `cad2` al final de `cad1`. Devuelve `cad1`.

---

### `strchr`

```c
#include <string.h>
char *strchr(char *cad, int ch);
```

Devuelve un puntero a la primera ocurrencia de `ch` en `cad`, o `NULL` si no se encuentra.

---

### `strcmp`

```c
#include <string.h>
int strcmp(const char *cad1, const char *cad2);
```

Compara lexicogr√°ficamente `cad1` y `cad2`. Devuelve:

| Valor devuelto | Descripci√≥n      |
| -------------- | ---------------- |
| `< 0`          | `cad1` < `cad2`  |
| `0`            | `cad1` == `cad2` |
| `> 0`          | `cad1` > `cad2`  |

*Tabla A.3.2: Interpretaci√≥n del valor devuelto por `strcmp()`*

---

### `strcpy`

```c
#include <string.h>
char *strcpy(char *cad1, const char *cad2);
```

Copia `cad2` en `cad1`. Devuelve `cad1`.

---

### `strlen`

```c
#include <string.h>
unsigned int strlen(char *cad);
```

Devuelve el n√∫mero de caracteres de `cad`, sin contar el car√°cter nulo de fin.

---

### `strtok`

```c
#include <string.h>
char *strtok(char *cad1, const char *cad2);
```

Devuelve un puntero a la siguiente palabra de `cad1`, utilizando los caracteres de `cad2` como delimitadores. La primera llamada usa `cad1`, las siguientes `NULL`. Modifica `cad1`.



## A.4 - Funciones matem√°ticas

[![√çNDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

```c
#include <math.h>
double acos(double arg);
```

Devuelve el arcocoseno de `arg`. El argumento debe estar en el rango de -1 a 1. En caso contrario, se produce un error de dominio.

---

```c
double asin(double arg);
```

Devuelve el arcoseno de `arg`, con las mismas restricciones que `acos()`.

---

```c
double atan(double arg);
```

Devuelve el arcotangente de `arg`.

---

```c
double atan2(double y, double x);
```

Devuelve el arcotangente de `y/x`, considerando los signos de los argumentos para determinar el cuadrante.

---

```c
double ceil(double num);
```

Devuelve el menor entero mayor o igual a `num`. Ej.: `ceil(1.02)` ‚Üí `2.0`, `ceil(-1.02)` ‚Üí `-1.0`.

---

```c
double cos(double arg);
```

Devuelve el coseno de `arg` (en radianes).

---

```c
double cosh(double arg);
```

Devuelve el coseno hiperb√≥lico de `arg`.

---

```c
double exp(double arg);
```

Devuelve `e` elevado a `arg`.

---

```c
double fabs(double num);
```

Devuelve el valor absoluto de `num`.

---

```c
double floor(double num);
```

Devuelve el mayor entero menor o igual que `num`. Ej.: `floor(1.02)` ‚Üí `1.0`, `floor(-1.02)` ‚Üí `-2.0`.

---

```c
double fmod(double x, double y);
```

Devuelve el resto de la divisi√≥n `x/y`.

---

```c
double log(double num);
```

Devuelve el logaritmo neperiano de `num`. Error de dominio si `num` es negativo. Error de rango si es cero.

---

```c
double log10(double num);
```

Devuelve el logaritmo en base 10 de `num`.

---

```c
double pow(double base, double exp);
```

Devuelve `base` elevado a `exp`. Puede generar errores si `base` es 0 y `exp <= 0`, o si `base < 0` y `exp` no es entero.

---

```c
double sin(double arg);
```

Devuelve el seno de `arg` (en radianes).

---

```c
double sinh(double arg);
```

Devuelve el seno hiperb√≥lico de `arg`.

---

```c
double sqrt(double num);
```

Devuelve la ra√≠z cuadrada de `num`. Error de dominio si `num` es negativo.

---

```c
double tan(double arg);
```

Devuelve la tangente de `arg` (en radianes).

---

```c
double tanh(double arg);
```

Devuelve la tangente hiperb√≥lica de `arg`.

---

## A.5 - Asignaci√≥n din√°mica de memoria

[![√çNDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

```c
#include <stdlib.h>
void *calloc(size_t num, size_t tam);
```

Asigna memoria para un array de `num` elementos de tama√±o `tam`, inicializados a cero. Devuelve un puntero al inicio de la memoria asignada o `NULL` si falla.

---

```c
void free(void *ptr);
```

Libera la memoria apuntada por `ptr`, previamente reservada con `malloc()`, `calloc()` o `realloc()`.

---

```c
void *malloc(size_t tam);
```

Asigna `tam` bytes de memoria sin inicializar. Devuelve un puntero al bloque asignado o `NULL` si no hay memoria suficiente.

---

```c
void *realloc(void *ptr, size_t tam);
```

Redimensiona el bloque de memoria apuntado por `ptr` a `tam` bytes. Si es necesario, mueve el bloque a otra direcci√≥n y copia su contenido.

* Si `ptr` es `NULL`, se comporta como `malloc(tam)`.
* Si `tam` es cero, libera la memoria.
* Devuelve `NULL` si no hay suficiente memoria; el bloque original permanece intacto.




## A.6 - Funciones varias

[![√çNDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

---

```c
#include <stdlib.h>
int abs(int num);
```

Devuelve el valor absoluto del entero `num`.

---

```c
double atof(const char *cad);
```

Convierte la cadena apuntada por `cad` a un n√∫mero `double`. La cadena debe representar un n√∫mero en coma flotante v√°lido. Si no lo es, el resultado es indefinido.

> Ejemplo: `atof("100.00HOLA")` ‚Üí `100.00`.

---

```c
int atoi(const char *cad);
```

Convierte la cadena apuntada por `cad` a un n√∫mero entero (`int`). Si la cadena no representa un n√∫mero v√°lido, el resultado es indefinido (la mayor√≠a de implementaciones devuelven `0`).

> Ejemplo: `atoi("123.23")` ‚Üí `123`.

---

```c
long int atol(const char *cad);
```

Convierte la cadena apuntada por `cad` a un n√∫mero `long int`. Funciona como `atoi()`.

---

```c
void exit(int estado);
```

Finaliza inmediatamente el programa.

* Si `estado` es `0`, indica una terminaci√≥n normal.
* Un valor distinto puede se√±alar un error.

---

```c
long labs(long num);
```

Devuelve el valor absoluto de `num`.

---

```c
int system(const char *cad);
```

Ejecuta la cadena `cad` como un comando del sistema operativo.

* Si `cad` es `NULL`, devuelve distinto de cero si existe un int√©rprete de comandos.
* Si `cad` no es `NULL`, devuelve `0` si el comando fue exitoso; en otro caso, un valor distinto de cero.

---

## Ap√©ndice B: Ejemplos de programas en C

[![√çNDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Este ap√©ndice incluye algunos programas de ejemplo en lenguaje C. Son compatibles con compiladores para MS-DOS y UNIX sin modificaciones.

---

### B.1 `palindro.c`

**Descripci√≥n:** Programa que determina si una palabra es pal√≠ndroma (se lee igual de izquierda a derecha que de derecha a izquierda).

```c
#include <stdio.h>
#include <string.h>

#define TAM 100

// Rutina que calcula si una palabra es pal√≠ndroma.
// Par√°metros:
//   char *cadena: puntero al string con la palabra.
// Retorno:
//   int: 0 si no es pal√≠ndroma, distinto de 0 si lo es.
int Palindroma(char *cadena) {
    register int i, j;
    i = 0;
    j = strlen(cadena) - 1;
    while (i < j && cadena[i] == cadena[j]) {
        i++;
        j--;
    }
    return (i >= j);
}

int main(void) {
    char cadena[TAM];

    printf("\nIntroduce la palabra:\n");
    gets(cadena);

    printf("La palabra: %s %s pal√≠ndroma.\n",
           cadena,
           (Palindroma(cadena)) ? "es" : "no es");

    return 0;
}
```

‚ö†Ô∏è **Nota:** El uso de `gets()` no es seguro y est√° obsoleto. Se recomienda usar `fgets()`.

---


## B.2 `matriz.c`

[![√çNDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

**Descripci√≥n:** Programa que calcula el producto de dos matrices.

```c
#include <stdio.h>

#define TAM 10  // Tama√±o m√°ximo de las matrices
#define OK 0    // C√≥digo de √©xito
#define ERROR 1 // C√≥digo de error

// Estructura para representar una matriz
struct MATRIZ {
    unsigned fila, columna;
    float matriz[TAM][TAM];
};

// Funci√≥n que muestra el men√∫ y solicita una opci√≥n
char Menu(void) {
    register char d;
    printf("\nElige la opci√≥n deseada:\n");
    printf("\t0 -- Salir del programa.\n");
    printf("\t1 -- Cambiar la matriz A.\n");
    printf("\t2 -- Cambiar la matriz B.\n");
    printf("\t3 -- Calcular A*B\n");
    printf("\t4 -- Calcular B*A\n");
    while ((d = getchar()) < '0' || d > '4');
    return d;
}

// Funci√≥n que pide el n√∫mero de filas o columnas de una matriz
unsigned PedirTamano(const char *cadena) {
    unsigned valor;
    do {
        printf("%s", cadena);
        scanf("%u", &valor);
    } while (valor == 0 || valor > TAM);
    return valor;
}

// Funci√≥n que cambia los valores de una matriz
void PedirMatriz(struct MATRIZ *a) {
    register unsigned i, j;
    float valor;
    a->fila = PedirTamano("\nN√∫mero de filas de la matriz: ");
    a->columna = PedirTamano("\nN√∫mero de columnas de la matriz: \n");

    for (i = 0; i < a->fila; i++)
        for (j = 0; j < a->columna; j++) {
            printf("M[%u][%u]: ", i, j);
            scanf("%f", &valor);
            a->matriz[i][j] = valor;
        }
}

// Funci√≥n que multiplica dos matrices
int Multiplicar(const struct MATRIZ *a, const struct MATRIZ *b, struct MATRIZ *res) {
    register unsigned i, j, k;

    if (a->columna != b->fila) return ERROR;

    res->fila = a->fila;
    res->columna = b->columna;

    for (i = 0; i < a->fila; i++)
        for (j = 0; j < b->columna; j++) {
            res->matriz[i][j] = 0;
            for (k = 0; k < a->columna; k++) {
                res->matriz[i][j] += a->matriz[i][k] * b->matriz[k][j];
            }
        }
    return OK;
}

// Funci√≥n que muestra el resultado de la operaci√≥n de multiplicaci√≥n
void Mostrar(const struct MATRIZ *res) {
    register unsigned i, j;
    for (i = 0; i < res->fila; i++) {
        for (j = 0; j < res->columna; j++) {
            printf("Res[%u][%u]= %f\n", i, j, res->matriz[i][j]);
        }
        printf("\nPulsa Enter para continuar.\n");
        getchar();
    }
}

int main(void) {
    struct MATRIZ a, b, res;
    char d;

    // Inicializaci√≥n de matrices
    a.fila = a.columna = b.fila = b.columna = 1;
    a.matriz[0][0] = b.matriz[0][0] = 1.0;

    do {
        switch (d = Menu()) {
            case '0': break;
            case '1': PedirMatriz(&a); break;
            case '2': PedirMatriz(&b); break;
            case '3':
                if (Multiplicar(&a, &b, &res) == ERROR)
                    printf("\nNo es posible multiplicar A*B\n");
                else
                    Mostrar(&res);
                break;
            case '4':
                if (Multiplicar(&b, &a, &res) == ERROR)
                    printf("\nNo es posible multiplicar B*A\n");
                else
                    Mostrar(&res);
                break;
        }
    } while (d != '0');
    return 0;
}
```

---

## B.3 `ordenar.c`

[![√çNDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

**Descripci√≥n:** Programa que ordena un archivo de cualquier tama√±o usando el algoritmo **QuickSort**. El archivo contiene un n√∫mero **unsigned** como primer elemento, seguido de los elementos a ordenar.

```c
#include <stdio.h>
#include <stdlib.h>

// Funci√≥n que lee un archivo de datos y devuelve un puntero al array de la memoria reservada
float *LeerFichero(const char *nombre, unsigned *num) {
    FILE *fp;
    float *p;
    register unsigned i;

    if ((fp = fopen(nombre, "rt")) == NULL) {
        printf("\nError, no puedo abrir el fichero: %s\n", nombre);
        return NULL;
    }

    fscanf(fp, "%u\n", num);

    if ((p = (float *)calloc(*num, sizeof(float))) == NULL) {
        printf("\nError, memoria insuficiente.\n");
        fclose(fp);
        return NULL;
    }

    for (i = 0; i < *num; i++)
        fscanf(fp, "%f\n", &p[i]);

    fclose(fp);
    return p;
}

// Funci√≥n que guarda los datos ordenados en un archivo
void GuardarFichero(const char *nombre, const unsigned num, const float *p) {
    FILE *fp;
    register unsigned i;

    if ((fp = fopen(nombre, "wt")) == NULL) {
        printf("\nError, no puedo crear el fichero: %s\n", nombre);
        return;
    }

    fprintf(fp, "%u\n", num);
    for (i = 0; i < num; i++)
        fprintf(fp, "%f\n", p[i]);

    fclose(fp);
}

// Funci√≥n que ordena un array usando el algoritmo QuickSort
void QuickSort(float *p, unsigned izq, unsigned der) {
    register unsigned i = izq, j = der;
    float val, inter;

    val = p[(i + j) / 2];

    do {
        while (p[i] < val) i++;
        while (p[j] > val) j--;

        if (i <= j) {
            inter = p[i];
            p[i] = p[j];
            p[j] = inter;
            i++;
            j--;
        }
    } while (i <= j);

    if (izq < j) QuickSort(p, izq, j);
    if (i < der) QuickSort(p, i, der);
}

// Funci√≥n principal
int main(int argc, char *argv[]) {
    float *p;
    unsigned num;

    if (argc != 3) {
        printf("\nModo de uso: %s <fichero1> <fichero2>\n", argv[0]);
        return 1;
    }

    if ((p = LeerFichero(argv[1], &num)) == NULL)
        return 1;

    QuickSort(p, 0, num - 1);
    GuardarFichero(argv[2], num, p);

    free(p);
    return 0;
}
```


## B.4 fichero.c.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

```c
/* Programa que maneja una peque√±a base de datos directamente sobre el fichero */

#include <stdio.h>
#include <string.h>

/* Definicion de las constantes del programa */
#define TAM 30
#define TAM_BUFFER 10

/* Definicion de los codigos de error */
#define OK 0
#define ERROR 1

/* Definicion de las estructuras de datos del programa */
struct FICHA {
    unsigned long dni;
    char nombre[TAM];
    char apellido[2][TAM];
};

/* Rutina que muestra un menu en pantalla.
Parametros: Ninguno.
Return: char Opcion elegida. */
char Menu(void) {
    register char d;
    printf("\nElige una opcion:\n");
    printf("\t0 -- Salir del programa.\n");
    printf("\t1 -- Insertar un nuevo elemento.\n");
    printf("\t2 -- Buscar un elemento por su dni.\n");
    printf("\t3 -- Buscar un elemento por su apellido.\n");
    while ((d = getchar()) < '0' || d > '3');
    return d;
}

/* Rutina que muestra un elemento en pantalla.
Parametros: struct FICHA *ficha Puntero a la estructura con los datos a mostrar.
Return: Ninguno. */
void Mostrar(const struct FICHA *ficha) {
    printf("\n\nDNI: %lu\n", ficha->dni);
    printf("NOMBRE: %s\n", ficha->nombre);
    printf("PRIMER APELLIDO: %s\n", ficha->apellido[0]);
    printf("SEGUNDO APELLIDO: %s\n", ficha->apellido[1]);
    printf("\nPulsa Enter para continuar\n");
    getchar();
}

/* Rutina que busca un elemento dado su dni.
Parametros: FILE *fichero Puntero al fichero de trabajo.
           unsigned long dni Numero de dni a buscar.
           char opcion Opcion de ejecucion, 1 mostrar, 0 no mostrar.
Return: int Codigo de error. */
int BuscarDni(FILE *fichero, const unsigned long dni, const char opcion) {
    struct FICHA ficha;
    fseek(fichero, 0L, SEEK_SET);
    while (fread(&ficha, sizeof(struct FICHA), 1, fichero) == 1)
        if (dni == ficha.dni) {
            if (opcion) Mostrar(&ficha);
            return OK;
        }
    return ERROR;
}

/* Rutina que busca por apellidos.
Parametros: FILE *fichero Puntero al fichero de trabajo.
           char *apellido Apellido a buscar.
Return: int Codigo de error. */
int BuscarApellido(FILE *fichero, char *apellido) {
    struct FICHA ficha;
    char encontrado = 0;
    fseek(fichero, 0L, SEEK_SET);
    while (fread(&ficha, sizeof(struct FICHA), 1, fichero) == 1)
        if (!strcmp(apellido, ficha.apellido[0]) || !strcmp(apellido, ficha.apellido[1])) {
            Mostrar(&ficha);
            encontrado = 1;
        }
    return (encontrado) ? OK : ERROR;
}

/* Rutina que inserta un nuevo elemento en el fichero.
Parametros: FILE *fichero Puntero al fichero de trabajo.
           struct FICHA *ficha Puntero a la ficha a insertar.
Return: int Codigo de error. */
int Insertar(FILE *fichero, const struct FICHA *ficha) {
    if (BuscarDni(fichero, ficha->dni, 0) != ERROR)
        return ERROR;
    fseek(fichero, 0L, SEEK_END);
    fwrite(ficha, sizeof(struct FICHA), 1, fichero);
    return OK;
}

/* Rutina que pide los datos de una ficha.
Parametros: struct FICHA *ficha Puntero a la ficha que contendra los datos.
           char opcion Opcion de ejecucion (0..2).
Return: struct FICHA * Puntero a la ficha que contiene los datos. */
struct FICHA *PedirDatos(struct FICHA *ficha, const char opcion) {
    switch(opcion) {
        case 0:
            printf("\nDNI: ");
            scanf("%lu", &ficha->dni);
            fflush(stdin);
            break;
        case 1:
            fflush(stdin);
            printf("APELLIDO: ");
            strupr(gets(ficha->apellido[1]));
            break;
        case 2:
            printf("\nDNI: ");
            scanf("%lu", &ficha->dni);
            fflush(stdin);
            printf("NOMBRE: ");
            strupr(gets(ficha->nombre));
            printf("PRIMER APELLIDO: ");
            strupr(gets(ficha->apellido[0]));
            printf("SEGUNDO APELLIDO: ");
            strupr(gets(ficha->apellido[1]));
            break;
    }
    return ficha;
}

int main(int argc, char *argv[]) {
    FILE *fichero;
    struct FICHA ficha;
    register char d;

    if (argc != 2) {
        printf("\nModo de uso: %s <fichero>\n", argv[0]);
        return 1;
    }

    if ((fichero = fopen(argv[1], "a+b")) == NULL) {
        printf("\nError creando el fichero: %s\n", argv[1]);
        return 1;
    }

    if (setvbuf(fichero, NULL, _IOFBF, TAM_BUFFER * sizeof(struct FICHA)) != 0) {
        printf("\nError creando el buffer para %d elementos.\n", TAM_BUFFER);
        fclose(fichero);
        return 1;
    }

    do {
        switch(d = Menu()) {
            case '0': break;
            case '1':
                if (Insertar(fichero, PedirDatos(&ficha, 2)) == ERROR)
                    printf("\nNumero de dni duplicado.\n");
                break;
            case '2':
                PedirDatos(&ficha, 0);
                if (BuscarDni(fichero, ficha.dni, 1) == ERROR)
                    printf("\nDni no existente.\n");
                break;
            case '3':
                PedirDatos(&ficha, 1);
                if (BuscarApellido(fichero, ficha.apellido[1]) == ERROR)
                    printf("\nApellido inexistente.\n");
                break;
        }
    } while (d != '0');

    fclose(fichero);
    return 0;
}
```



## B.5 - arbol.c.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

```c

/* Programa que lee las palabras de un fichero y las almacena en un arbol binario */

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>

/* Definicion de la longitud maxima de una palabra */
#define TAM 30

/* Definicion de las estructuras de datos del programa */
struct ARBOL {
    char pal[TAM + 1];
    struct ARBOL *izq, *der;
};

/* Rutina que lee una palabra del fichero.
Parametros: 
    FILE *fichero Puntero al fichero de donde se leen las palabras.
    char *cadena Array de caracteres donde almacenar las palabras.
Return: 
    char * Puntero a la cadena con la palabra leida, NULL si error. */
char *LeerPalabra(FILE *fichero, char *cadena) {
    register char d, i = 0;

    while ((d = fgetc(fichero)) != EOF && !isalpha(d));

    if (d == EOF)
        return NULL;

    do
        cadena[i++] = d;
    while (i < TAM && (isalpha(d = fgetc(fichero)) || isdigit(d) || d == '_'));

    cadena[i] = '\0';

    return cadena;
}

/* Rutina que crea el arbol binario, leyendo para ello el fichero. 
Parametros: 
    char *nombre Nombre del fichero a leer.
Return: 
    struct ARBOL * Puntero a la raiz del arbol creado, NULL si error. */
struct ARBOL *LeerFichero(char *nombre) {
    FILE *fichero;
    char cadena[TAM + 1], insertado;
    int val;
    struct ARBOL *cab = NULL, *p, *q;

    if ((fichero = fopen(nombre, "rt")) == NULL) {
        printf("\nError, no puedo leer el fichero: %s\n", nombre);
        return NULL;
    }

    while (LeerPalabra(fichero, cadena) != NULL) {
        if ((q = (struct ARBOL *)malloc(sizeof(struct ARBOL))) == NULL) {
            printf("\nError reservando memoria.\n");
            fclose(fichero);
            return NULL;
        }

        strcpy(q->pal, cadena);
        q->izq = q->der = NULL;

        if (cab == NULL)
            cab = q;
        else {
            p = cab;
            insertado = 0;

            while (!insertado)
                if ((val = strcmp(cadena, p->pal)) < 0)
                    if (p->izq == NULL) {
                        p->izq = q;
                        insertado = 1;
                    } else
                        p = p->izq;
                else if (val > 0)
                    if (p->der == NULL) {
                        p->der = q;
                        insertado = 1;
                    } else
                        p = p->der;
                else
                    insertado = 1;
        }
    }

    fclose(fichero);
    return cab;
}

/* Rutina que muestra por pantalla el arbol ordenado a la vez que libera la memoria.
Parametros: 
    struct ARBOL *p Puntero al nodo a mostrar.
    unsigned *cont Puntero al contador de elementos para permitir parar la visualizacion.
Return: 
    Ninguno. */
void Mostrar(struct ARBOL *p, unsigned *cont) {
    if (p->izq != NULL)
        Mostrar(p->izq, cont);

    puts(p->pal);

    if (++*cont > 21) {
        *cont = 1;
        printf("\nPulsa Enter para continuar.\n");
        getchar();
    }

    if (p->der != NULL)
        Mostrar(p->der, cont);

    free(p);
}

int main(int argc, char *argv[]) {
    struct ARBOL *p;
    unsigned cont = 1;

    if (argc != 2) {
        printf("\nModo de uso: %s <fichero>\n", argv[0]);
        return 1;
    }

    if ((p = LeerFichero(argv[1])) == NULL)
        return 1;

    printf("\n\n\n\n\n\n");
    Mostrar(p, &cont);

    return 0;
}
```




## üîç **Uso de Valgrind para Depuraci√≥n de Memoria en C**

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Valgrind es una herramienta esencial para detectar **errores de memoria** (leaks, accesos inv√°lidos, etc.) en programas C. Su uso es especialmente cr√≠tico en proyectos como los de 42, donde la gesti√≥n manual de memoria es frecuente.

### üìå **Instalaci√≥n (Linux/macOS)**
```bash
# Ubuntu/Debian
sudo apt install valgrind

# macOS (via Homebrew)
brew install valgrind
```

### üî• **Comando B√°sico**
```bash
valgrind --leak-check=full ./tu_programa argumentos
```

### üõ†Ô∏è **Flags Recomendados para M√°xima Detecci√≥n**
| Flag | Descripci√≥n |
|------|-------------|
| `--leak-check=full` | Detalla el origen de *todos* los memory leaks |
| `--show-leak-kinds=all` | Muestra leaks definitivos, indirectos y posibles |
| `--track-origins=yes` | Rastrea or√≠genes de valores no inicializados |
| `--trace-children=yes` | Analiza procesos hijos (√∫til si usas `fork()` o `system()`) |
| `--error-exitcode=1` | Retorna error si hay problemas (ideal para CI/CD) |

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

### üéØ **Ejemplo Pr√°ctico**
Supongamos que tu programa `so_long` tiene un memory leak:
```bash
valgrind --leak-check=full --show-leak-kinds=all ./so_long map.ber
```
**Salida t√≠pica:**
```
==12345== 40 bytes in 1 blocks are definitely lost in loss record 1 of 2
==12345==    at 0x483877F: malloc (vg_replace_malloc.c:307)
==12345==    by 0x109234: crear_mapa (mapa.c:15)
==12345==    by 0x109567: main (main.c:28)
```
- **Interpretaci√≥n**: 40 bytes perdidos en `mapa.c`, l√≠nea 15. ¬°Debes liberarlos con `free()`!

### üìù **Errores Comunes que Detecta**
| Error | Causa | Soluci√≥n |
|-------|-------|----------|
| **Definitely lost** | Memoria nunca liberada | A√±ade `free()` donde corresponda |
| **Invalid read/write** | Acceso a memoria liberada o fuera de l√≠mites | Verifica √≠ndices y punteros |
| **Use of uninitialized values** | Variables no inicializadas | Inicializa siempre las variables |

### üö® **Supresi√≥n de Falsos Positivos (Ej: MiniLibX)**
Crea un archivo `mlx.supp`:
```xml
{
   <MLX_False_Positives>
   Memcheck:Leak
   ...
   fun:mlx_init
   ...
}
```
Y √∫salo con:
```bash
valgrind --suppressions=mlx.supp ./tu_programa
```

