# <img src="images/C_Logo.png"/> Programando en C - Material didáctico


<a href="https://github.com/fran-byte/Learn-C/blob/main/readme.md#0-lista-de-palabras-reservadas-en-c-est%C3%A1ndar-ansi-c--iso-c"><img src="https://img.shields.io/badge/0.%20Palabras%20reservadas%20en%20C-dedede"  width="34%"></a>

<a href="#1--identificadores-tipos-de-datos-variables"><img src="https://img.shields.io/badge/1.%20Identificadores,%20Tipos%20de%20Datos,%20Variables-dedede"  width="50%"></a><br>
<a href="#11---tipos-de-datos"><img src="https://img.shields.io/badge/1.1.%20Tipos%20de%20Datos-0b9000"></a>
<a href="#12--declaración-de-variables-y-alcance"><img src="https://img.shields.io/badge/1.2.%20Declaración%20de%20Variables%20y%20Alcance-0b9000"></a><br>
<a href="#13--especificadores-de-almacenamiento-de-los-tipos-de-datos"><img src="https://img.shields.io/badge/1.3.%20Especificadores%20de%20Almacenamiento-0b9000"></a>
<a href="#14--constantes"><img src="https://img.shields.io/badge/1.4.%20Constantes-0b9000"></a>



<a href="#2---operadores-aritm%C3%A9ticos-relaci%C3%B3nales-y-l%C3%B3gicos-operador-asignaci%C3%B3n-operador-sizeof-y-operadores-avanzados-operadores-sobre-bits-y-operador-"><img src="https://img.shields.io/badge/2.%20Operadores-dedede" width="18%"></a><br>
<a href="#21--operadores-aritm%C3%A9ticos"><img src="https://img.shields.io/badge/2.1.%20Operadores%20Aritm%C3%A9ticos-0b9000"></a>
<a href="#22--operadores-relaci%C3%B3nales-y-l%C3%B3gicos"><img src="https://img.shields.io/badge/2.2.%20Operadores%20Relacionales%20y%20L%C3%B3gicos-0b9000"></a>
<a href="#23--operador-asignaci%C3%B3n"><img src="https://img.shields.io/badge/2.3.%20Operador%20Asignaci%C3%B3n-0b9000"></a><br>
<a href="#24--operador-sizeof"><img src="https://img.shields.io/badge/2.4.%20Operador%20sizeof-0b9000"></a>
<a href="#25--operadores-sobre-bits"><img src="https://img.shields.io/badge/2.5.%20Operadores%20sobre%20Bits-0b9000"></a>
<a href="#26--el-operador-"><img src="https://img.shields.io/badge/2.6.%20Operador%20Ternario-0b9000"></a>


<a href="#3---conversi%C3%B3n-de-tipos-de-datos"><img src="https://img.shields.io/badge/3.%20Conversión%20de%20Tipos%20de%20Datos-dedede" width="38%"></a><br>
<a href="#31--conversi%C3%B3n-autom%C3%A1tica-de-tipos-de-datos"><img src="https://img.shields.io/badge/3.1.%20Conversión%20Automática-0b9000"></a>
<a href="#32--conversi%C3%B3n-forzada-de-tipos-datos"><img src="https://img.shields.io/badge/3.2.%20Conversión%20Forzada-0b9000"></a>

<a href="#4---sentencias-de-control-y-bucles"><img src="https://img.shields.io/badge/4.%20Sentencias%20de%20Control%20y%20Bucles-dedede" width="39%"></a><br>
<a href="#41-sentencia-de-control-if"><img src="https://img.shields.io/badge/4.1.%20Sentencia%20if-0b9000"></a>
<a href="#42-sentencia-de-control-switch"><img src="https://img.shields.io/badge/4.2.%20Sentencia%20switch-0b9000"></a>
<a href="#43-bucle-for"><img src="https://img.shields.io/badge/4.3.%20Bucle%20for-0b9000"></a><br>
<a href="#44--bucle-while"><img src="https://img.shields.io/badge/4.4.%20Bucle%20while-0b9000"></a>
<a href="#45-bucle-dowhile"><img src="https://img.shields.io/badge/4.5.%20Bucle%20do/while-0b9000"></a>
<a href="#46-sentencias-de-control-break-y-continue-"><img src="https://img.shields.io/badge/4.6.%20Sentencias%20break%20y%20continue-0b9000"></a>

<a href="#tema-5---arrays-cadenas-y-punteros"><img src="https://img.shields.io/badge/5.%20Arrays,%20Cadenas%20y%20Punteros-dedede" width="36%"></a><br>
<a href="#51-arrays-y-cadenas"><img src="https://img.shields.io/badge/5.1.%20Arrays%20y%20Cadenas-0b9000"></a>
<a href="#52-punteros"><img src="https://img.shields.io/badge/5.2.%20Punteros-0b9000"></a>

<a href="#tema-6---funciones"><img src="https://img.shields.io/badge/6.%20Funciones-dedede" width="16%"></a><br>
<a href="#61-la-sentencia-return"><img src="https://img.shields.io/badge/6.1.%20Sentencia%20return-0b9000"></a>
<a href="#62-argumentos-de-las-funciones-llamada-por-valor-y-por-referencia"><img src="https://img.shields.io/badge/6.2.%20Argumentos%20de%20Funciones-0b9000"></a>
<a href="#63-arrays-como-argumentos-de-funciones"><img src="https://img.shields.io/badge/6.3.%20Arrays%20como%20Argumentos-0b9000"></a><br>
<a href="#64-argumentos-de-la-función-main"><img src="https://img.shields.io/badge/6.4.%20Argumentos%20de%20main()-0b9000"></a>
<a href="#65-recursividad"><img src="https://img.shields.io/badge/6.5.%20Recursividad-0b9000"></a>
<a href="#66punteros-a-funciones"><img src="https://img.shields.io/badge/6.6.%20Punteros%20a%20Funciones-0b9000"></a>
<a href="#67-el-modificador-de-almacenamiento-static-aplicado-a-funciones"><img src="https://img.shields.io/badge/6.7.%20static%20en%20Funciones-0b9000"></a>

<a href="#tema-7---estructuras-campos-de-bit-uniones-y"><img src="https://img.shields.io/badge/7.%20Estructuras,%20Campos%20de%20Bit,%20Uniones%20y%20Enumeraciones-dedede" width="60%"></a><br>
<a href="#71-estructuras"><img src="https://img.shields.io/badge/7.1.%20Estructuras-0b9000"></a>
<a href="#72-campos-de-bit"><img src="https://img.shields.io/badge/7.2.%20Campos%20de%20Bit-0b9000"></a>
<a href="#73-uniones"><img src="https://img.shields.io/badge/7.3.%20Uniones-0b9000"></a><br>
<a href="#74enumeraciones"><img src="https://img.shields.io/badge/7.4.%20Enumeraciones-0b9000"></a>
<a href="#75la-palabra-reservada-typedef"><img src="https://img.shields.io/badge/7.5.%20typedef-0b9000"></a>

<a href="#tema-8---el-preprocesador"><img src="https://img.shields.io/badge/8.%20El%20Preprocesador-dedede" width="24%"></a><br>
<a href="#81-directiva-define"><img src="https://img.shields.io/badge/8.1.%20Directiva%20define-0b9000"></a>
<a href="#82-directiva-undef"><img src="https://img.shields.io/badge/8.2.%20Directiva%20undef-0b9000"></a>
<a href="#83-directiva-error"><img src="https://img.shields.io/badge/8.3.%20Directiva%20error-0b9000"></a>
<a href="#84-directiva-include"><img src="https://img.shields.io/badge/8.4.%20Directiva%20include-0b9000"></a><br>
<a href="#85-directivas-if-ifdef-ifndef-else-elif-endif"><img src="https://img.shields.io/badge/8.5.%20Directivas%20Condicionales-0b9000"></a>
<a href="#86-directiva-line"><img src="https://img.shields.io/badge/8.6.%20Directiva%20line-0b9000"></a>
<a href="#87-directiva-pragma"><img src="https://img.shields.io/badge/8.7.%20Directiva%20pragma-0b9000"></a>

<a href="#tema-9---entrada-y-salida"><img src="https://img.shields.io/badge/9.%20Entrada%20y%20Salida-dedede" width="23%"></a><br>
<a href="#91-entrada-y-salida-desde-consola"><img src="https://img.shields.io/badge/9.1.%20Entrada/Salida%20desde%20Consola-0b9000"></a>
<a href="#92-entrada-y-salida-desde-fichero"><img src="https://img.shields.io/badge/9.2.%20Entrada/Salida%20desde%20Fichero-0b9000"></a>


<a href="#tema-10---asignación-dinámica-de-memoria"><img src="https://img.shields.io/badge/10.%20Asignación%20Dinámica%20de%20Memoria-dedede" width="42%"></a><br>
<a href="#101-reserva-dinámica-de-memoria"><img src="https://img.shields.io/badge/10.1.%20Reserva%20Dinámica-0b9000"></a>
<a href="#102-liberación-dinámica-de-memoria"><img src="https://img.shields.io/badge/10.2.%20Liberación%20Dinámica-0b9000"></a>
<a href="#103-ejemplo-de-asignación-y-liberación-dinámica-de-memoria"><img src="https://img.shields.io/badge/10.3.%20Ejemplo%20Práctico-0b9000"></a>

<a href="#ap%C3%A9ndice-a---funciones-de-biblioteca-del-est%C3%A1ndar-ansi-de-c"><img src="https://img.shields.io/badge/A.%20Apéndices-dedede" width="17%"></a><br>
<a href="#a1-funciones-de-entrada-y-salida-de-datos"><img src="https://img.shields.io/badge/A.1.%20Funciones%20de%20Biblioteca%20ANSI%20C-0b9000"></a>
<a href="#a2---funciones-de-caracteres-ctypeh"><img src="https://img.shields.io/badge/A.2.%20Funciones%20de%20caracteres-0b9000"></a>
<a href="#a3---funciones-de-cadenas-stringh"><img src="https://img.shields.io/badge/A.3.%20Funciones%20de%20cadenas%20(<string.h>)-0b9000"></a><br>
<a href="#a4---funciones-matemáticas"><img src="https://img.shields.io/badge/A.4.%20Funciones%20Matemáticas-0b9000"></a>
<a href="#a5---asignación-dinámica-de-memoria"><img src="https://img.shields.io/badge/A.5.%20Asignación%20dinámica%20de%20memoria-0b9000"></a>
<a href="#a6---funciones-varias"><img src="https://img.shields.io/badge/A.6.%20Funciones%20varias-0b9000"></a><br><br>
<a href="#ap%C3%A9ndice-b-ejemplos-de-programas-en-c"><img src="https://img.shields.io/badge/B.%20Apéndices%20Ejemplos%20de%20programas-dedede" width="48%"></a><br>
<a href="#-uso-de-valgrind-para-depuraci%C3%B3n-de-memoria-en-c"><img src="https://img.shields.io/badge/Valgrind-FF5733" width="18%"></a><br>


---


 
### **0 Lista de Palabras Reservadas en C (Estándar ANSI C / ISO C)**

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

---

#### **1. Palabras Reservadas Básicas (32 en total)**
Estas son las palabras clave definidas por el estándar C que **no pueden usarse como identificadores** (nombres de variables, funciones, etc.):

| Categoría          | Palabras Reservadas                                                                 |
|--------------------|------------------------------------------------------------------------------------|
| **Tipos de datos** | `char`, `short`, `int`, `long`, `float`, `double`, `void`, `_Bool` (C99), `_Complex` (C99), `_Imaginary` (C99) |
| **Modificadores**  | `signed`, `unsigned`, `const`, `volatile`, `restrict` (C99)                        |
| **Estructuras**    | `struct`, `union`, `enum`                                                          |
| **Control**        | `if`, `else`, `switch`, `case`, `default`, `for`, `do`, `while`, `break`, `continue`, `goto` |
| **Funciones**      | `return`                                                                           |
| **Memoria**        | `auto`, `register`, `static`, `extern`                                             |
| **Operadores**     | `sizeof`, `typedef`                                                                |
| **Otros**          | `inline` (C99), `_Alignas` (C11), `_Alignof` (C11), `_Atomic` (C11), `_Generic` (C11), `_Noreturn` (C11), `_Static_assert` (C11), `_Thread_local` (C11) |

---

#### **2. Extensiones Específicas del Compilador**
Algunos compiladores añaden palabras reservadas propias (no estándar). Ejemplos comunes:

- **GCC/G++**:  
  `__asm__`, `__attribute__`, `__inline__`, `__volatile__`, `__restrict__`, `__extension__`.  
- **Microsoft Visual C**:  
  `__cdecl`, `__declspec`, `__int64`, `__fastcall`, `__inline`.  

---

#### **3. Macros Predefinidas (No son palabras reservadas, pero son especiales)**
Estas pueden redefinirse, pero es peligroso:  
`NULL`, `true`, `false` (C99), `__FILE__`, `__LINE__`, `__DATE__`, `__TIME__`, `__func__` (C99).

---

#### **4. Diferencias entre Estándares**
- **C89/C90**: 32 palabras reservadas.  
- **C99**: Añade `_Bool`, `_Complex`, `_Imaginary`, `inline`, `restrict`.  
- **C11**: Añade `_Alignas`, `_Alignof`, `_Atomic`, `_Generic`, `_Noreturn`, `_Static_assert`, `_Thread_local`.  

---

### **Ejemplo de Uso Incorrecto**
```c
int float = 10;  // ¡Error! "float" es palabra reservada.
```

### **Ejemplo de Uso Correcto**
```c
int numero = 10;  // Correcto ("numero" no es palabra reservada).
```

---
### **Malas prácticas de Programación**

**Usar nombre de funciones de C como variables**  
Ejemplo: `malloc` como `calloc` **no son palabras reservadas** en el estándar C. Son **funciones de la biblioteca estándar** (`stdlib.h`), pero técnicamente **pueden reutilizarse como nombres de variables**. Sin embargo, hacerlo es **mala práctica** y puede causar problemas. Aquí los detalles:

---

### **1. Ejemplo de Uso (Compila, pero es arriesgado)**

```c
#include <stdio.h>

int main() {
    int malloc = 42;  // Compila, pero "oscurece" la función malloc().
    printf("%d\n", malloc);  // Imprime 42.
    return 0;
}
```
**Funciona**, pero ahora no podrás usar `malloc()` para asignar memoria dinámica en ese ámbito.

---

### **2. Riesgos Clave**
- **Pérdida de funcionalidad**: Si necesitas usar `malloc()` o `calloc` después, el compilador tratará tu variable como un identificador, no como la función.  
  ```c
  int* arr = malloc(10 * sizeof(int));  // ¡Error! "malloc" es una variable, no una función.
  ```
- **Código confuso**: Otros programadores (o tú en el futuro) podrían no entender por qué `malloc` no funciona como se espera.

---

### **3. ¿Por qué el compilador lo permite?**
- **C no tiene namespaces**: Las funciones de la biblioteca estándar no están protegidas contra sobrescritura.  
- **El linker resuelve símbolos**: Si no incluyes `stdlib.h`, el compilador ni siquiera sabe que `malloc` es una función.

---

### **4. Buenas Prácticas**
- **Evita reutilizar nombres de funciones estándar**. Usa alternativas claras:  
  ```c
  int mi_malloc = 42;  // ¡Mejor!
  ```
- **Si accidentalmente lo haces**, renombra tu variable o usa el operador de resolución de ámbito (en C++):  
  ```cpp
  int malloc = 42;
  int* arr = ::malloc(10 * sizeof(int));  // C++: fuerza el uso de la función global.
  ```
  *(En C puro no hay solución directa; hay que renombrar la variable).*

---

### **5. Casos donde sí podrías hacerlo**
- **Macros maliciosas**: Si alguien definió `#define malloc algo_riesgoso`, podrías "protegerte" con una variable local.  
  *(Pero es mejor usar `#undef malloc` y luego incluir `stdlib.h`).*

---


## 1.- IDENTIFICADORES, TIPOS DE DATOS, VARIABLES...

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

 
```
<tipo de dato> <nombre de variable>;

int a;
```

## 1.1. - Tipos de datos

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

|**Tipo de dato**|**Descripción.**|
| - | - |
|**char**|Carácter o entero pequeño (byte)|
|**int**|Entero|
|**float**|Punto flotante|
|**double**|Punto flotante (mayor rango que *float*)|
|**void**|Sin tipo (uso especial)|



**Modificadores de Tipos de datos**

|**Modificador**|**Tipos de actuación**|**Descripción**||
| - | - | - | :- |
|**signed**|char|int|Con signo (por defecto)|
|**unsigned**|char|int|Sin signo|
|**long**|int|double|Largo|
|**short**|int|Corto||

```
unsigned char a;
long double b;
short int i;
```
**Doble modificador a un mismo tipo de datos**
Así, es posible definir una variable de tipo :

```
unsigned long int (entero largo sin signo).
```


||**Rango de valores posibles en (notación matemática)**|| 
| :- | - | :- |
|**Tipo de variable declarada**|**16 bits**|**32 bits**|
|char / signed char|[-128 , 127]|[-128 , 127]|
|unsigned char|[0 , 255]|[0 , 255]|
|int / signed int|[-32768 , 32767]|[-2147483647 , 2147483648]|
|unsigned int|[0 , 65535]|[0 , 4294967295]|
|short int / signed short int|[-32768 , 32767]|[-32768 , 32767]|
|unsigned short int|[0 , 65535]|[0 , 65535]|
|long int / signed long int|[-2147483647 , 2147483648]|[-2147483647 , 2147483648]|
|unsigned long int|[0 , 4294967295]|[0 , 4294967295]|
|float|[-3.4E+38 , -3.4E-38], 0 , [3.4E-38 , 3.4E+38]|[-3.4E+38 , -3.4E-38], 0 , [3.4E-38 , 3.4E+38]|
|double|[-1.7E+308 , -1.7E-308], 0 , [1.7E-308 , 1.7E+308]|[-1.7E+308 , -1.7E-308], 0 , [1.7E-308 , 1.7E+308]|
|long double|[-3.4E+4932 , -1.1E-4932], 0 , [3.4E-4932 , 1.1E+4932]|[-3.4E-4932 , -1.1E+4932], 0 , [3.4E-4932 , 1.1E+4932]|



**Modificadores de acceso.** 
Limitan  el  uso  que  puede  realizarse  de  las  variables declaradas. 



|**Modificador**|**Efecto**|
| - | - |
|const|Variable de valor constante|
|volatile|Variable  cuyo  valor  es  modificado externamente|

**const** asegura de que su valor no será modificado por el programa, salvo en el momento de su declaración asignándole un valor inicial.

```
const int x = 650;
```

Si intentamos modificar el valor de **x**, tal como **x=x+10;**, producirá un error en tiempo de compilación.

**volatile**, indica al compilador que la variable puede modificarse por un *proceso externo* al propio programa (como la hora del sistema), y por ello, que no trate de optimizar dicha variable suponiéndole un valor constante, etc. Cada vez que se usa la variable, se realice una comprobación de su valor.

**const** y **volatile** pueden usarse de forma conjunta en ciertos casos, por lo cual no son excluyentes el uno del otro. Ello es posible si se declara una variable que actualizara el reloj del sistema, (proceso externo al programa), y que no queremos pueda modificarse en el interior del programa. Por ello, podremos declarar:

```
volatile const unsigned long int hora;
```

## 1.2- Declaración de variables y alcance.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Podemos declarar las variables en cuatro lugares del módulo del programa:

- Variables **globales** Fuera de todas las funciones del programa, accesibles desde cualquier parte del programa.
- Variables **locales** dentro de una función, accesibles tan solo por la función en las que se declaran.
- Variable como **parámetros** a la función, accesibles de igual forma que si se declararan dentro de la función.
- Variable **local de bloque** del programa, accesible tan solo dentro del bloque donde se declara.

``` c
#include <stdio.h>
int add; /* Variable global, accesible desde cualquier parte del programa*/
void suma(int x) /* Variable local declarada como parámetro, accesible solo por la función suma*/
{
  add = add + x;
  return;
}
void intercambio(int *a, int *b)
{
  if (*a > *b)
  {
    int inter; /* Variable local, accesible solo dentro del bloque donde se declara*/
    inter= *a;
    *a = *b;
    *b = inter;
  }
return;
}
int main(void) /*Función principal del programa\*
{
  int contador, a = 9, b = 0; /*Variables locales, accesibles solo por main*/
  add = 0;
  intercambio(&a, &b);
  for(contador=a; contador<=b; contador++) suma(contador); printf(“%d\n” ,add);
  return(0);
}
```
## 1.3.- Especificadores de almacenamiento de los tipos de datos.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Los especificadores de almacenamiento deben preceder a la declaración del tipo de dato de la variable. Estos especificadores de almacenamiento son:



||**Especificador de almacenamiento**|**Efecto**|
| :- | :- | - |
|auto||Variable  local  (por defecto)|
|extern||Variable externa|
|static||Variable estática|
|register||Variable registro|


**auto** se usa para declarar que una variable local existe dentro de la subrutina o bloque de programa donde se declara, es por defecto y no se suele usar.

**extern** se usa en programas compuestos por varios módulos, se usa sobre las variables globales del módulo, y el compilador no crea un almacenamiento para ella en memoria, sino que, tan solo tiene en cuenta que dicha variable ya ha sido declarada en otro modulo del programa y es del tipo de dato que se indica.

**static** actúa según el alcance de la variable:

- Para variables locales, **static** indica que la variable local debe almacenarse de forma permanente en memoria, como si fuera una variable global, pero su alcance como variable local declarada en la subrutina o bloque,conservando su valor entre llamadas a la función.
- Para variables globales, **static** indica que la variable global es local al módulo del programa donde se declara, y, no será conocida por ningún otro módulo del programa.

**register** se aplica solo a variables locales de tipo **char** e **int**, indicando al compilador, si es posible, mantenga esa variable en un registro de la CPU y no cree una variable en la memoria. Se pueden declarar cuantas variables se deseen, pues el compilador ignorara dicha  declaración  caso  de  no  poder  ser  satisfecha.  Y permite colocar en registros de la CPU variables usadas, como contadores de bucles, etc.

Algunos ejemplos de uso de los especificadores de almacenamiento son:

```
register unsigned int a;

static float b;

extern int c;

static const unsigned long int d;
```

## 1.4.- Constantes.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Valores fijos que el programa no puede alterar:



|**Tipo de dato**|**Constantes de ejemplo**|
| - | - |
|char|‘a’ ‘9’ 'Q'|
|int|1 -34 21000|
|long int|-34 67856L 456|
|short int|10 -12 1500|



|unsigned int|45600U 345 3|
| - | - |
|float|12\.45 4.34e-3 -2.8e9|
|double|-34.657 -2.2e-7 1.0e100|


Otras constantes son las constantes hexadecimales y octales, las constantes de cadena, y las constantes de barra invertida.

Las constantes hexadecimales y octales son **constantes enteras**, pero definidas en base 16 (constantes hexadecimales) o en base 8 (constantes octales).

Las constantes de tipo hexadecimal comienzan por los caracteres *0x*** seguidas del número deseado. 
Las constantes de tipo octal comienzan por un cero (*0*). Por ejemplo, son constantes hexadecimales *0x34* (52 decimal), *0xFFFF* (65535 decimal); y constantes octales *011* (9 decimal), *0173* (123 decimal)

Las constantes de cadena son conjuntos de caracteres que se encierran entre comillas dobles. *“Esto es una constante de cadena”*

Las  constantes de caracteres de barra invertida (tales como retorno de carro, etc.). Estas constantes son proporcionadas por C para que sea posible introducir dichas caracteres como constantes en los programas en los cuales sea necesario:



|**Código**|**Significado**|
| - | - |
|\b|Retroceso|
|\f|Alimentación de hoja|
|\n|Nueva línea|
|\r|Retorno de carro|
|\t|Tabulador horizontal|
|\”|Doble comilla|
|\’|Simple comilla|
|\0|Nulo|
|\\|Barra invertida|
|\v|Tabulador vertical|
|\a|Alerta|
|\o|Constante octal|
|\x|Constante hexadecimal|


Son igual que el de cualquier otro carácter, así, si *ch* es una variable de tipo *char*, podemos hacer: *ch=‘\t’*, o *ch=‘\x20’* (carácter espacio), etc., de igual forma que realizaríamos con cualquier otra constante de carácter.

Las constantes de barra invertida pueden usarse en el interior de constantes de cadena como un carácter más, por ello: *"Esto es una linea\n"*.

## 2. - Operadores aritméticos, relaciónales y lógicos; operador asignación; operador sizeof y operadores avanzados (operadores sobre bits y operador ?)

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

## 2.1.- Operadores aritméticos.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Los operadores aritméticos existentes en C son, ordenados de mayor a menor precedencia:



|**Operador**||**Operador**||**Operador**||
| - | :- | - | :- | - | :- |
|**++**|Incremento|**--**|Decremento|||
|**-**|Menos unario|||||
|**\*** |Multiplicación.|**/**|División|**%**|Módulo|
|**+**|Suma|**-**|Resta|||

Los operadores ++, -- y % solo pueden usarse con datos de tipo *int* o *char*. El operador incremento (++), incrementa en una unidad el valor de la variable sobre la que se aplica, el operador decremento (--), decrementa en una unidad el valor de la variable, y el operador módulo (%), calcula el resto de una división de dos variables de tipo entero o carácter.

Un aspecto que conviene explicar es el hecho de que los operadores incremento y decremento pueden preceder o posceder a su operando, lo cual permite escribir, si *x* es una variable de tipo *int*, las expresiones ++*x* o *x*++. Usado de forma aislada no presenta ninguna diferencia, sin embargo, cuando se usa en una expresión existe una diferencia en el orden de ejecución del mismo. Cuando el operador incremento (o decremento) precede al operando, C primero realiza el incremento (o decremento), y después usa el valor del operando, realizándose la operación al contrario si el operador poscede al operando. Así, considérense el siguiente código de un programa:

int var1=10,var2;

var2=++var1; /\* Pone 11 en var2, pues primero incrementa var1,\*/              /\* y luego asigna su valor a var2 \*/

Mientras que el siguiente código funciona de forma distinta:

int var1=10,var2;

var2=var1++; /\* Pone 10 en var2, pues primero asigna su valor \*/              /\* a var2, y luego incrementa var1 \*/

## 2.2- Operadores relaciónales y lógicos.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Los operadores relaciónales y lógicos de C:


| **Operador** | **Nombre**          | **Operador** | **Nombre**               | **Operador** | **Nombre**        | **Operador** | **Nombre**               |
|--------------|---------------------|--------------|--------------------------|--------------|-------------------|--------------|--------------------------|
| `!`          | NOT lógico          | `>`          | Mayor que                | `<`          | Menor que         | `>=`         | Mayor o igual que        |
| `==`         | Igual que           | `!=`         | No igual                 | `&&`         | AND lógico        | `\|\|`       | OR lógico                |
| `&`          | AND bit a bit       | `\|`         | OR bit a bit             | `^`          | XOR bit a bit     | `~`          | NOT bit a bit            |
| `<<`         | Desplazamiento izquierda | `>>`    | Desplazamiento derecha   | `?:`         | Operador ternario | `=`          | Asignación básica        |
| `+=`         | Asignación con suma | `-=`         | Asignación con resta      | `*=`         | Asignación con multiplicación | `/=` | Asignación con división |
| `++`         | Incremento          | `--`         | Decremento               | `->`         | Acceso a miembro de estructura | `.*` | Acceso a miembro por puntero |
| `&`          | Dirección de        | `*`          | Dereferencia             | `sizeof`     | Tamaño de tipo    | `,`          | Operador coma            |


Los operadores relaciónales y lógicos tiene menor prioridad que los operadores aritméticos antes descritos, así , escribir *10>3+9* es equivalente a escribir *10>(3+9)*.

## 2.3.- Operador asignación.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


El lenguaje C, a diferencia de otros lenguajes tales como Pascal, no diferencia la asignación de cualquier otro operador del lenguaje. Para C, la asignación es un operador, el llamado operador asignación (`=`), el cual posee la prioridad más baja de todos los operadores. Es por ello que en C podemos escribir expresiones del tipo:

```c
if ((c = a * b) < 0)  /* if es la comprobación condicional de C, que */
                       /* se verá con posterioridad */
````

Esta expresión asigna a la variable `c` el valor de `a * b` y devuelve su valor para compararlo con el valor constante 0. Los paréntesis son necesarios, pues el operador asignación tiene la prioridad más baja de todos los operadores.



## 2.4.- Operador sizeof.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


El operador **sizeof** es un operador en tiempo de compilación. Devuelve el tamaño de una variable o tipo de dato durante la compilación, no durante la ejecución del programa. Veamos algunos ejemplos:

```c
sizeof(int) //  devuelve el valor 2 en los sistemas operativos de 16 bits y 4 en los de 32 bits.
````

Si tenemos `char a[20]`, `sizeof(a)` devuelve el valor 20, y si tenemos `float a[6]`, `sizeof(a)` devuelve el valor 24 (4 \* 6).


## 2.5.- Operadores sobre bits.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

El lenguaje C posee operadores que actúan a nivel de bits sobre los datos, estos operadores son:



|**Operador**|**Nombre**|**Operación**|
| - | - | - |
|~|Not|Complemento a uno (NOT)|
|<<|Desplazamiento izquierda|Desplazamiento izquierda|
|>>|Desplazamiento derecha|Desplazamiento derecha|
|&|And|Y|
|^|Xor|O exclusivo (XOR)|
|\|\||Or|O|


Los operadores &, | y** ^ actúan sobre dos operandos, mientras que ~ ,<< **y *>>*** actúan sobre un solo operando. Veamos su actuación sobre dos valores cualquiera:



|**Operador**|**Operando 1**|**Operando 2**|**Resultado**|
| - | - | - | - |
|~|0xB2||0x4D|
|<<3|0xB2||0x90|
|>>2|0xB2||0x2C|
|&|0xB2|0x79|0x30|
|^|0xB2|0x79|0xCB|
|||0xB2|0x79|0xFB|


Donde los números que acompañan a los operadores << y** >> indican cuantas posiciones se desplaza el operando. La prioridad de los operadores sobre bits es:

- El operador ~ tiene la misma prioridad que los operadores ++ y .**--**.
- Los operadores <<  y >>  tienen la prioridad situada entre los operadores aritméticos y los operadores relaciónales y lógicos.
- Los operadores &, ^ y |  tienen la prioridad situada entre los operadores relaciónales y los operadores lógicos (&& y ||).
- 
## 2.6.- El operador ?.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


El operador `? :` se usa para reemplazar las sentencias `if/else` (que veremos con posterioridad) de formato general:

```c
if (condición)    expresión;
else
      expresión;
````

Donde `expresión` debe ser una expresión sencilla y no otra sentencia de C. El operador `?` es un operador ternario cuyo formato general es:

```c
Exp1 ? Exp2 : Exp3;
```

Donde **Exp1**, **Exp2** y **Exp3** son expresiones. El operador `?` evalúa la expresión **Exp1**, si es cierta se evalúa **Exp2** y si es falsa se evalúa **Exp3**. Veamos algunos ejemplos:

```c
int x, y;

y = (x > 10) ? 100 : 200;
```

Asignará el valor 100 a `y` si `x` es mayor de 10, y el valor 200 en caso contrario.

```c
int t;

(t) ? f1(t) + f2() : printf("t vale cero");
```

Ejecutará las funciones `f1()` y `f2()` si `t` es distinto de cero, y la función `printf` si `t` vale cero.



## 3 - Conversión de tipos de datos.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

## 3.1.- Conversión automática de tipos de datos.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

El lenguaje C permite que en una misma expresión aparezcan diferentes tipos de datos, encargándose el compilador de realizar las operaciones de forma correcta. El compilador del lenguaje C, cuando en una misma expresión aparecen dos o más tipos de datos, convierte todos los operandos al tipo del operando más grande existente de acuerdo con las dos reglas siguientes:

- Todos los `char` y `short int` se convierten a `int`.
- Todos los `float` a `double`.

Para todo par de operandos, lo siguiente ocurre en secuencia:

1. Si uno de los operandos es un `long double`, el otro se convierte en `long double`.
2. Si uno de los operandos es `double`, el otro se convierte a `double`.
3. Si uno de los operandos es `long`, el otro se convierte a `long`.
4. Si uno de los operandos es `unsigned`, el otro se convierte a `unsigned`.

Después de que el compilador aplique estas reglas de conversión, cada par de operandos será del mismo tipo, y el resultado será del tipo de los operandos. Veamos un ejemplo:

```c
char ch; int i; float f; double d;

( ch / i ) + ( f * d ) - ( f + i );
````

`char int float double float int`

Debido a que en la operación existen diferentes tipos se aplica la primera conversión:

* `ch` de `char` pasa a `int`.
* `f` de `float` pasa a `double`.

```c
( ch / i ) + ( f * d ) - ( f + i );
```

`int int double double double int`

Al ser los dos operandos de igual tipo, realizamos la primera operación, `(ch / i)`, y el resultado es de tipo `int`. De igual forma, para la segunda operación, `(f * d)`, el resultado es de tipo `double`.

Para la tercera operación, y dado que las variables no son del mismo tipo, se aplica la segunda regla, convirtiéndose el `int` en `double`, realizándose la suma `(f + i)` como dos datos de tipo `double`, y siendo por tanto el resultado un `double`.

Ahora procedemos a realizar la suma de los dos primeros resultados `(ch / i) + (f * d)`, como uno de ellos es de tipo `int`, y el otro de tipo `double`, el `int` se convierte en `double` por la segunda regla, y el resultado es un `double`.

Y por último, realizamos la resta final, siendo los dos operandos de tipo `double` y el resultado final, por tanto, de tipo `double`.





## 3.2.- Conversión forzada de tipos datos.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

En C, existe, además, de la conversión automática de tipos de datos, la posibilidad de forzar la conversión de un tipo de datos en otro tipo de datos. Esta conversión de un tipo de datos en otro se llama **“casts”** Nosotros decimos comunmente **"casteos"**, y su sintaxis es:

(tipo)expresión

Su utilidad queda claramente expresada en el ejemplo siguiente:

```
int a=3,b=2; float c; c=a/b;
```

La operación asigna a *c* el valor *1.0* en vez de el valor *1.5*, ello se debe a que al ser *a* y *b* variables de tipo entero, se realiza una división entre enteros, y el resultado de *3/2* es *1*. A continuación ese valor *1* se convierte a un valor en coma flotante para realizar la asignación (valor *1.0*), y se asigna a *c*. Si lo que se desea es que la división se realice en punto flotante, debe escribirse la operación de la siguiente forma:

```
c=(float)a/b;
```

Esta conversión forzada obliga a convertir la variable *a* en *float*, y entonces, aplicando las reglas de conversión automática de tipos, se realiza la división en coma flotante. Este proceso da lugar a que el resultado de la operación sea *1.5*, y dicho valor sea el asignado a la variable *c*.!

## 4 - Sentencias de control y bucles.


[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

## 4.1. Sentencia de control if.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Antes de empezar a explicar las sentencias de control del lenguaje C, conviene explicar los conceptos de verdadero/falso y de sentencia que posee el lenguaje C.

El lenguaje C posee un concepto muy amplio de lo que es verdadero. Para C, cualquier valor que sea distinto de cero es verdadero, siendo por tanto falso solo si el valor es cero. Es por ello que una expresión del tipo `if(x)` será verdad siempre que el valor de la variable `x` sea distinto de cero, sea cual sea el tipo de la variable `x`.

El concepto de sentencia en C es igual que el de otros muchos lenguajes. Por sentencia se entiende en C cualquier instrucción simple o bien, cualquier conjunto de instrucciones simples que se encuentren encerradas entre los caracteres `{` y `}`, que marcan respectivamente el comienzo y el final de una sentencia.

La forma general de la sentencia `if` es:

```c
if (condición)
    sentencia; 
else
    sentencia;
````

Siendo el `else` opcional. Si la condición es verdadera se ejecuta la sentencia asociada al `if`, en caso de que sea falsa la condición se ejecuta la sentencia asociada al `else` (si existe el `else`). Veamos algunos ejemplos de sentencias `if`:

```c
int a, b;

if (a > b)
{
    b--;
    a = a + 5;
}
else
{
    a++;
    b = b - 5;
}
if (b - a != 7)
    b = 5;
```

Las sentencias de control `if` pueden ir anidadas. Un `if` anidado es una sentencia `if` que es el objeto de otro `if` o `else`. Esta anidación de `if/else` puede presentar la problemática de decidir qué `else` va asociado a cada `if`. Considerese el siguiente ejemplo:

```c
if (x)
    if (y) 
        printf("1");
    else 
        printf("2");
```

¿A qué `if` se refiere el `else`? C soluciona este problema asociando cada `else` al `if` más cercano posible y que todavía no tiene ningún `else` asociado. Es por ello que en este caso el `if` asociado al `else` es el `if(y)`. Si queremos que el `else` esté asociado al `if(x)`, deberíamos escribirlo de la siguiente forma:

```c
if (x)
{
    if (y)
        printf("1");
}
else
    printf("2");
```


## 4.2. Sentencia de control switch.

  [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


La forma general de la sentencia `switch` es:

```c
switch (variable) {
    case const1: 
        sentencia; 
        break;
    case const2: 
        sentencia; 
        break;
    default: 
        sentencia; 
}
````

Donde `variable` debe ser de tipo `char` o `int`, y donde `const1`, `const2`, ..., indican constantes de C del tipo de datos de la variable. Dichas constantes no pueden repetirse dentro del `switch`. El `default` es opcional y puede no aparecer, así como los `break` de los `case`. La sentencia `switch` se ejecuta comparando el valor de la variable con el valor de cada una de las constantes, realizando la comparación desde arriba hacia abajo. En caso de que se encuentre una constante cuyo valor coincida con el valor de la variable, se empieza a ejecutar las sentencias hasta encontrar una sentencia `break`. En caso de que no se encuentre ningún valor que coincida, se ejecuta el `default` (si existe). Veamos algunos ejemplos:

```c
int valor;
switch(valor)
{
  case 0: 
    cont++;
    break;
  case 5: 
    cont--;
    break;
  default: 
    cont = -10; /* Se ejecuta si valor no es 0 o 5 */ 
}
```

```c
char d;
int cont = 0;
switch(d)
{
  case '\r': 
    cont++; /* Si d es un retorno de carro, se ejecuta este cont++ y el siguiente */
  case '\x1B': 
    cont++;
    break;
  default: 
    cont = -1;
}
```

Las sentencias `switch` pueden aparecer unas dentro de otras, igual que sucedía con las sentencias `if`. Veámoslo con un ejemplo:

```c
char d, e;

switch (d) {
    case 'a':
    case 'A':
        switch (e) {
            case '1':
                d = 'z';
                e = '+';
                break;
            case '2':
                d = 'Z';
                e = '-';
        }
        break;

    case 'b':
    case 'B':
        switch (e) {
            case '0':
                d = '2';
            default:
                e = '+';
        }
}
```



## 4.3. Bucle for.


[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La forma general de la sentencia `for` es:

```c
for (inicialización; condición; actualización) {
    sentencia;
}
````

Donde:

* `inicialización` es una expresión que se ejecuta una vez al principio del ciclo.
* `condición` es una expresión que se evalúa antes de cada iteración. Si es verdadera, se ejecuta la sentencia del ciclo; si es falsa, el ciclo termina.
* `actualización` es una expresión que se ejecuta después de cada iteración, normalmente usada para cambiar el valor de las variables involucradas en la condición.

Veamos un ejemplo:

```c
int i;

for (i = 0; i < 10; i++) {
    printf("%d ", i);  // Imprime los números del 0 al 9
}
```

En este ejemplo, la variable `i` se inicializa en 0. Mientras `i` sea menor que 10, se ejecutará la sentencia dentro del `for` (en este caso, imprimir el valor de `i`). Después de cada iteración, `i` se incrementa en 1, hasta que la condición `i < 10` sea falsa.

El ciclo `for` puede también ser usado sin que se especifiquen todos los componentes. Por ejemplo:

```c
int j = 0;

for (; j < 5;) {
    printf("%d ", j);
    j++;
}
```

Aquí se omiten tanto la inicialización como la actualización en la cabecera del ciclo. Solo se mantiene la condición y la actualización ocurre dentro del ciclo.

Además, los ciclos `for` pueden ser anidados (uno dentro de otro). Veamos un ejemplo de un ciclo `for` anidado:

```c
int i, j;

for (i = 0; i < 3; i++) {
    for (j = 0; j < 2; j++) {
        printf("i = %d, j = %d\n", i, j);
    }
}
```

Este ciclo imprime combinaciones de los valores de `i` y `j`. En cada iteración del ciclo exterior, el ciclo interior se ejecuta completamente.




## 4.4.  Bucle while.


 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La sintaxis del bucle `while` es:

```c
while (condición) 
    sentencia;
````

Donde la sentencia puede no existir (sentencia vacía), pero siempre debe existir la condición. El bucle `while` se ejecuta mientras la condición sea verdad. Veamos algunos ejemplos de bucles `while`:

```c
int i = 1, suma = 0; 
while (i <= 100) {
    suma = suma + i;
    i++;
}
```

Este bucle suma los números del 1 al 100 y almacena el resultado en `suma`.

```c
while (getc(stdin) != '\x1B'); /* Bucle que espera hasta que se */
                                /* pulse la tecla Esc */
```

Este bucle se ejecuta esperando que se presione la tecla `Esc` (representada por el valor `'\x1B'` en código ASCII).

```c
while (1) /* Recordar que en C lo que no es cero es verdad */ {
    d = getc(stdin);
    printf("%c", d);
    if (d == '\x1B')
        break;
}
```

Este es un bucle infinito que lee caracteres desde la entrada estándar (teclado) y los imprime en la pantalla. Si se presiona la tecla `Esc`, el bucle se interrumpe con la instrucción `break`.




## 4.5. Bucle do/while.


[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


Al contrario que los bucles `for` y `while` que comprueban la condición en lo alto de la misma, el bucle `do/while` comprueba la condición en la parte baja del mismo, lo cual provoca que el bucle se ejecute como mínimo una vez. La sintaxis del bucle `do/while` es:

```c
do
    sentencia;
while (condición);
````

El bucle `do/while` se ejecuta mientras la `condición` sea verdad. Veamos algunos ejemplos de bucle `do/while`:

```c
int num;

do {
    scanf("%d", &num);
} while (num > 100);
```

En este ejemplo, el programa solicita al usuario que ingrese un número. Si el número es mayor que 100, seguirá solicitando la entrada, asegurando que la condición se verifique al final de cada iteración.

```c
int i, j;

do {
    scanf("%d", &i);
    scanf("%d", &j);
} while (i < j);
```

Este ejemplo solicita dos números, `i` y `j`, y continuará solicitando la entrada mientras `i` sea menor que `j`. Al igual que en el caso anterior, la condición se evalúa después de la ejecución de las sentencias dentro del `do`.




## 4.6 Sentencias de control break y continue .

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


Las sentencias de control `break` y `continue` permiten modificar y controlar la ejecución de los bucles anteriormente descritos.

La sentencia `break` provoca la salida del bucle en el cual se encuentra y la ejecución de la sentencia que se encuentra a continuación del bucle.

La sentencia `continue` provoca que el programa vaya directamente a comprobar la condición del bucle en los bucles `while` y `do/while`, o bien, que ejecute el incremento y después compruebe la condición en el caso del bucle `for`.

Veamos algunos ejemplos de uso de `break` y de `continue`:

```c
int x;

for (x = 0; x < 10; x++) {
    for (;;) {
        if (getc(stdin) == '\x1B')
            break;  // Sale del bucle infinito cuando se presiona la tecla Esc
    }
    printf("Salí del bucle infinito, el valor de x es: %d\n", x);
}
````

En este ejemplo, el bucle interior es infinito, pero si se presiona la tecla `Esc`, el `break` provoca que salga de ese bucle, y luego el programa continúa con el siguiente valor de `x`.

```c
int x;

for (x = 1; x <= 100; x++) {  /* Esta rutina imprime en pantalla los */
                               /* números pares */
    if (x % 2)  // Si el número es impar, se salta a la siguiente iteración
        continue;
    printf("%d\n", x);  // Imprime el número si es par
}
```

Aquí, si el número `x` es impar (es decir, si `x % 2` es distinto de 0), el `continue` provoca que se salte la ejecución de la instrucción `printf` y pase a la siguiente iteración del bucle.



## Tema 5 - Arrays, cadenas y punteros.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

## 5.1. Arrays y cadenas.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

En C, un array unidimensional se declara como:

```c
tipo nombre[tamaño];
````

En C, el primer elemento de un array es el que posee el índice 0, por lo tanto, un array de 20 elementos posee sus elementos numerados de 0 a 19. Veamos unos ejemplos de declaración y manejo de algunos arrays:

```c
int x[100], i; 
for(i = 0; i < 100; i++)
    x[i] = i;
```

```c
char letras[256]; 
int i; 
for(i = 0; i < 256; i++)
    letras[i] = i;
```

```c
int x[10], i, suma;
for(i = 0; i < 10; i++) {
    printf("Introducir un número: %d: ", i);
    scanf("%d", &x[i]);
}

for(suma = 0, i = 0; i < 10; i++)
    suma = suma + x[i];

printf("La suma es: %d", suma);
```

Sin embargo, el lenguaje C no comprueba el tamaño de los arrays, por lo cual, es posible construir una rutina como la siguiente, la cual ocasionará un incorrecto funcionamiento del programa:

```c
float a[10];
int i;

for(i = 0; i < 100; i++) /* Este bucle es incorrecto */
    a[i] = i;
```

Es por ello, que es misión del programador comprobar que no se produzca el desbordamiento de los arrays.

### Cadenas (Strings)

Una cadena, también llamada `string`, es un tipo especial de array unidimensional. Una cadena es un array de caracteres (`char`) que termina con un carácter especial (el carácter `'\0'`). Es por ello, que la declaración de una cadena de caracteres se realiza exactamente igual que la declaración de un array unidimensional de caracteres:

```c
char cadena[tamaño];
```

Como toda cadena debe terminar en el carácter `'\0'`, es por ello que si se quiere usar una cadena de 20 caracteres, debe declararse de tamaño 21 (20 caracteres + carácter terminador).

Por lo demás, puede usarse una cadena como si fuera un array unidimensional, pues se puede referenciar uno cualquiera de sus elementos, etc. Para manejar las cadenas, existen un gran número de funciones de biblioteca que proporciona el estándar ANSI-C, para más información, referirse al apéndice A o a cualquier libro de C.

### Arrays Multidimensionales

La declaración de arrays de más de una dimensión se realiza de forma parecida a la de una dimensión. La sintaxis de la declaración de un array multidimensional es:

```c
tipo nombre[tam1][tam2]...[tamN];
```

Y su indexación, etc., se realiza de forma similar al array unidimensional. Veamos un ejemplo:

```c
float matriz[2][3];
int i, j;

for(i = 0; i < 2; i++) {
    for(j = 0; j < 3; j++) {
        printf("M[%d][%d]: ", i, j);
        scanf("%f", &matriz[i][j]);
    }
}
```

### Inicialización de Arrays

Además, es posible inicializar los arrays en el momento de declararlos. Su sintaxis es:

```c
tipo nombre[tam1][tam2]...[tamN] = {lista_de_valores};
```

Por lo cual, podemos escribir:

```c
float vector[3] = {-3.0, 5.7, -7.5};
```

También es posible inicializar arrays sin ponerles el tamaño, el compilador cuenta el número de caracteres de inicialización y reserva el tamaño necesario de forma automática. Por ejemplo:

```c
float vector[] = {-3.0, 5.7, -7.5};
```

```c
char cadena[] = "Esto es una cadena";
```



## 5.2. Punteros.


[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


Los punteros son una de las poderosas herramientas que ofrece el lenguaje C a los programadores, sin embargo, son también una de las más peligrosas. El uso de punteros sin inicializar, etc., es una fuente frecuente de errores en los programas de C, y además, suele producir fallos muy difíciles de localizar y depurar.

Un puntero es una variable que contiene una dirección de memoria. Normalmente, esa dirección es una posición de memoria de otra variable, por lo cual se suele decir que el puntero “apunta” a la otra variable.

### Declaración de Punteros

La sintaxis de la declaración de una variable puntero es:

```c
tipo *nombre;
````

El tipo base de la declaración sirve para conocer el tipo de datos al que pertenece la variable a la cual apunta el puntero. Esto es fundamental para poder leer el valor que almacena la zona de memoria apuntada por la variable puntero y para poder realizar ciertas operaciones aritméticas sobre los mismos.

Algunos ejemplos de declaración de variables puntero son:

```c
int *a;
char *p;
float *f;
```

### Operadores de Punteros

Existen dos operadores especiales para los punteros, el operador `*&` y el operador `*`.

1. **El operador `&`**: Es un operador unario que devuelve la dirección de una variable de memoria. Así, si declaramos:

   ```c
   int *a, b;
   ```

   Y hacemos:

   ```c
   a = &b;
   ```

   La variable puntero `a` contendrá la dirección de memoria de la variable `b`.

2. **El operador `*`**: Es un operador unario que devuelve el valor de la variable situada en la dirección que sigue. Veámoslo con un ejemplo:

   ```c
   int *a, b, c;
   b = 15;
   a = &b;
   c = *a;
   ```

   Entonces la variable `c` contendrá el valor `15`, pues `*a` devuelve el valor de la dirección que sigue (la cual "apunta" el puntero `a`), y previamente hemos hecho que `a` contenga la dirección de memoria de `b`.

### Operaciones con Punteros

1. **Asignación de punteros**: Es posible asignar el valor de una variable puntero a otra variable puntero. Por ejemplo:

   ```c
   int *a, *b, c;
   a = &c;
   b = a;
   ```

   Entonces, `b` contiene el valor de `a`, y por lo tanto, `b` también "apunta" a la variable `c`.

2. **Aritmética de punteros**: Se pueden realizar operaciones sobre las variables de tipo puntero usando los operadores `+`, `-`, `++`, `--`. Estos operadores incrementan o decrementan la posición de memoria a la que "apunta" el puntero. El incremento o decremento se realiza de acuerdo al tipo base de la variable puntero, por lo que el tipo del puntero es muy importante. Ejemplo:

   | **Operación** | ++                   | --                  | +9   | -5   |
   | ------------- | -------------------- | ------------------- | ---- | ---- |
   | **Variable**  | **Dirección actual** | **Nueva dirección** |      |      |
   | int \*a;      | 3000                 | 3002                | 2998 | 3018 |
   | float \*b;    | 3000                 | 3004                | 2996 | 3036 |

   Por lo tanto, si tenemos:

   ```c
   tipo *a;
   a = a + num;
   ```

   La posición a la que apunta `a` se incrementa en `num * sizeof(tipo)`. Para la resta se decrementa de igual forma.

3. **Comparaciones de punteros**: También es posible realizar comparaciones entre punteros. Por ejemplo:

   ```c
   int *a, *b;
   if (a < b)
       printf("a apunta a una dirección más baja que b");
   ```

### Relación entre Punteros y Arrays

Existe una estrecha relación entre los punteros y los arrays. Consideremos el siguiente fragmento de código:

```c
char str[80], *p;
p = str;
```

Este fragmento de código pone en la variable puntero `p` la dirección del primer elemento del array `str`. Entonces, es posible acceder al valor de la quinta posición del array mediante `str[4]` y `*(p + 4)` (recuérdese que los índices de los arrays comienzan en 0). Esta relación entre arrays y punteros es muy evidente, ya que el nombre del array sin índice es la dirección de comienzo del array, y un puntero puede indexarse como un array unidimensional. Por lo cual, en el ejemplo anterior, podríamos referenciar ese elemento como `p[4]`.

Es posible obtener la dirección de un elemento cualquiera del array de la siguiente forma:

```c
int str[80], *p;
p = &str[4];
```

Entonces, el puntero `p` contiene la dirección del quinto elemento del array `str`.

### Arrays de Punteros

Hasta ahora hemos declarado variables puntero aisladas. Es posible, como con cualquier otro tipo de datos, definir un array de variables puntero. La declaración para un array de punteros `int` de tamaño `10` es:

```c
int *a[10];
```

Para asignar una dirección de una variable entera, llamada `var`, al tercer elemento del array de punteros, se escribe:

```c
a[2] = &var;
```

Y para encontrar el valor de `var`:

```c
* a[2];
```

### Punteros a Punteros

Dado que un puntero es también una variable, es posible definir un puntero a un puntero. Supongamos que tenemos lo siguiente:

```c
int a, *b, **c;
b = &a;
c = &b;
```

Y entonces, `**c` tiene el valor de la variable `a`, pues `c` es un puntero a una variable que ya es de tipo puntero.

Este concepto de puntero a puntero podría extenderse a punteros a punteros a punteros, etc., pero no nos ocuparemos de ello. Además, existe el concepto de puntero a una función, al cual nos referiremos en el tema dedicado a las funciones.

---

## Tema 6 - Funciones

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

El formato general de una función en C es:

```c
tipo nombre(lista de parámetros) {
    cuerpo de la función
}
```

Las funciones son similares a las de cualquier otro lenguaje, pero, tal como mencionamos en la introducción, al no ser un lenguaje estructurado por bloques, no es posible declarar funciones dentro de otras funciones.
   

## 6.1. La sentencia return.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

 
Antes de empezar la explicación de las funciones, conviene explicar la sentencia `return`. La sentencia `return` permite, en primer lugar, salir de la función desde cualquier punto de la misma, y en segundo lugar, devolver un valor del tipo de la función, si ello es necesario (no se devuelve ningún valor si la función es de tipo `void`).

### Ejemplo con `return`

Veamos un ejemplo de una función con varios puntos de retorno:

```c
int Comparacion(int a, int b) {
    if (a > b) return 1;    /* a es mayor que b */
    if (a < b) return -1;   /* a es menor que b */
    return 0;                /* a y b son iguales */
}
````

Como se observa en el ejemplo, una función puede contener más de una sentencia `return`. Esto permite la posibilidad de poder salir de la función desde distintos puntos de la misma. Un aspecto que conviene resaltar es el hecho de que una función también termina su ejecución si llega al final de la misma sin encontrar ninguna sentencia `return`. Esto es posible en toda función de tipo `void`.

### Ejemplo de función `void` sin `return`

Veamos un ejemplo de una función `void` sin un `return` explícito:

```c
void A(int *a) {
    *a = 5;
}
```

Esta función es equivalente a otra que tuviera como última línea una sentencia `return`, y funcionaría de igual forma:

```c
void A(int *a) {
    *a = 5;
    return;
}
```

En el caso de las funciones de tipo `void`, no es necesario devolver un valor, y el uso de `return` al final de la función es opcional, ya que la función termina automáticamente al llegar al final de su cuerpo.

---

Las funciones son una de las características más importantes del lenguaje C, ya que permiten dividir el programa en partes más pequeñas y manejables. Además, al usar `return`, el flujo de control se puede modificar de forma más precisa, y los valores de retorno facilitan la comunicación entre las funciones y el programa principal.




## 6.2. Argumentos de las funciones, llamada por valor y por ![](Aspose.Words.ae55ca77-bd47-4be1-a802-7483922c91a3.005.png)"referencia".

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Una vez conocido el uso de la función `return`, podemos introducirnos en la explicación de las funciones. En primer lugar, si una función usa argumentos, es necesario declarar variables que acepten los argumentos de la función. Veamos un ejemplo:

### Ejemplo de función con parámetros

```c
int EstaEn(char *cad, char c) {  /* Devuelve 1 si el carácter c está en el string cad */
    while (*cad != '\0') {
        if (*cad == c)
            return 1;
        cad++;
    }
    return 0;
}
````

Esta función, que busca un carácter en una cadena, podría ser llamada desde otra función de la siguiente forma:

```c
char cadena[] = "Esta es una cadena de prueba";
if (EstaEn(cadena, 'a'))
    printf("Esta");
else
    printf("No esta");
```

### Paso de parámetros en C

A diferencia de otros lenguajes, el lenguaje C solo permite pasar parámetros a las funciones **por valor**. Esto significa que cuando una variable se pasa como argumento a una función, se pasa una copia de su valor. Si se desea que los cambios efectuados en una función sobre una variable afecten fuera del alcance de la función, es posible simular un **paso por referencia** mediante el uso de **punteros**.

Si a una función le pasamos como argumento la **dirección de una variable**, cualquier modificación que se realice en esa dirección afectará al valor de la variable original. De esta manera, conseguimos el mismo efecto que un paso por referencia.

### Ejemplo con punteros (simulando paso por referencia)

```c
#include <stdio.h>

void Alfa(int *val, float pos) {
    *val = 5;  // Modifica el valor de la variable apuntada por val
    pos = 7.7; // Modifica la copia local de pos, no la original
    return;
}

void Beta(int val, float *pos) {
    val = 10;  // Modifica la copia local de val, no la original
    *pos = 14.7;  // Modifica el valor de la variable apuntada por pos
}

int main(void) {
    int a = 6;
    float b = 9.87;

    printf("Al principio valen a=%d b=%f\n", a, b);
    
    Alfa(&a, b);  // Pasa la dirección de a, pero b por valor

    printf("Después de Alfa valen a=%d b=%f\n", a, b);
    
    Beta(a, &b);  // Pasa a por valor, pero la dirección de b

    printf("Después de Beta valen a=%d b=%f\n", a, b);
}
```

### Resultado del programa:

```
Al principio valen a=6 b=9.87
Después de Alfa valen a=5 b=9.87
Después de Beta valen a=5 b=14.7
```

### Explicación:

* En la función `Alfa`, se pasa la dirección de la variable `a` (usando `&a`), lo que permite que cualquier cambio hecho en `*val` modifique directamente el valor de `a`. En cambio, la variable `b` se pasa por valor, por lo que la modificación de `pos` no afecta el valor de `b` fuera de la función.

* En la función `Beta`, se pasa la variable `a` por valor, por lo que no se modifica fuera de la función. Sin embargo, la variable `b` se pasa por referencia (mediante el puntero `&b`), por lo que cualquier cambio en `*pos` afectará directamente a `b` fuera de la función.

---

Este mecanismo de paso de parámetros es fundamental en C, especialmente cuando necesitamos modificar el estado de variables en funciones o trabajar con estructuras complejas sin copiar grandes cantidades de datos. Con los punteros, C permite un control muy preciso sobre la memoria y el flujo de datos.



## 6.3. Arrays como argumentos de funciones.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Un aspecto a tener muy en cuenta es que C no permite el paso de un array por valor a una función. Un array es siempre pasado por "referencia", pues en la llamada, lo que se pasa es la dirección del primer elemento del array (recuérdese que el nombre de un array es un puntero al primer elemento). Por valor, tan solo es posible pasar por valor elementos individuales del array, pero no el array completo.

### Ejemplo de paso de un array por referencia

```c
#include <stdio.h>

void PasoValorReferencia(int *array, int valor) {
    array[5] = -8.6;  // Modifica el valor del elemento en la posición 5
    valor = 4;         // Modifica la copia local de valor, no la original
}

int main(void) {
    int array[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};  // Inicializa un array
    PasoValorReferencia(array, array[3]);  // Pasa el array por referencia

    // Imprime los valores modificados en el array
    printf("Array[5] vale: %d y array[3] vale: %d\n", array[5], array[3]);  
    return 0;
}
````

**Resultado en pantalla:**

```
Array[5] vale: -8 y array[3] vale: 0
```

En este ejemplo, vemos que el cambio realizado en `array[5]` se refleja correctamente en el array, porque el array se pasa por referencia. Sin embargo, el valor de `array[3]` no se modifica porque `valor` se pasa por valor y cualquier cambio sobre él no afecta la variable original.

---

## 6.4. Argumentos de la función `main`

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La función `main()`, como toda función de C, acepta argumentos. Los argumentos que acepta la función `main()` son un entero (`int argc`), un array de punteros a strings (`char *argv[]`), y otro array de punteros a strings (`char *env[]`). Aunque los nombres de estos argumentos no tienen por qué ser `argc`, `argv`, y `env`, en toda la literatura de C se usan esos nombres y, por lo tanto, los respetaremos en este caso.

Los significados de los parámetros `argc`, `argv` y `env` son los siguientes:

* El parámetro `argc` contiene el número de argumentos en la línea de órdenes de la llamada al programa.
* El parámetro `argv` contiene un puntero a cada uno de los argumentos (strings) de la línea de órdenes de la llamada al programa.
* El parámetro `env` contiene un puntero a cada una de las variables de ambiente (strings) del sistema operativo.

### Ejemplo de programa que usa argumentos de la línea de órdenes

```c
#include <stdio.h>

int main(int argc, char *argv[], char *env[]) {
    int i;

    printf("El valor de argc es: %d\n", argc);

    for (i = 0; i < argc; i++)
        printf("El argumento %d es: %s\n", i, argv[i]);

    for (i = 0; env[i] != NULL; i++)
        printf("La variable de ambiente %d es: %s\n", i, env[i]);

    return 0;
}
```

### Ejecución del programa:

Supongamos que el programa lo hemos llamado `prueba.exe`, y lo llamamos con la siguiente línea:

```
prueba.exe Este_es_el_argumento_1 Este_es_el_argumento_2
```

**Salida esperada:**

```
El valor de argc es: 3
El argumento 0 es: prueba.exe
El argumento 1 es: Este_es_el_argumento_1
El argumento 2 es: Este_es_el_argumento_2
La variable de ambiente 0 es: COMSPEC=C:\DOS\COMMAND.COM
La variable de ambiente 1 es: TEMP=C:\WINDOWS\TEMP
La variable de ambiente 2 es: PROMPT=$P$G
```

Como se observa, existen 3 argumentos, numerados de 0 a 2. El argumento 0 es siempre el nombre del programa, y el resto de los argumentos son los que se pasan en la línea de órdenes. El número y valor de las variables de ambiente depende del sistema operativo (MS-DOS, UNIX, etc.) y de la configuración del procesador de comandos del sistema operativo.

Este ejemplo muestra cómo se pueden gestionar y acceder tanto a los argumentos pasados en la línea de órdenes como a las variables de ambiente del sistema operativo, lo cual es útil para programas que necesitan interactuar de manera dinámica con su entorno.




## 6.5. Recursividad.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Una función de C puede llamarse a sí misma. Este proceso recibe el nombre de **recursividad**. Los ejemplos de recursividad son abundantes, siendo uno de los más habituales la función factorial:

```c
unsigned Factorial(unsigned num) {
    if (num == 0) return 1;
    return num * Factorial(num - 1);
}
```

La recursividad es una poderosa herramienta de programación, sin embargo, presenta dos problemas:

1. La velocidad de ejecución de un algoritmo programado de forma recursiva es mucho más lento que el programado de forma iterativa.
2. La recursividad, si es excesiva, puede ocasionar el desbordamiento de la pila, y con ello, el fallo en la ejecución del programa.

Sin embargo, el uso de la recursividad es frecuente en campos como la inteligencia artificial, etc., y en la implementación de ciertos algoritmos tales como el algoritmo de ordenación *QuickSort*, muy difícil de implementar de forma iterativa, pero relativamente sencillo de forma recursiva.

---


## 6.6.Punteros a funciones.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Al igual que cualquier otro tipo de dato, una **función** ocupa una dirección de memoria, y por tanto, puede ser apuntada por un **puntero**. La declaración de un **puntero a una función** es:

```c
tipo de dato (*nombre de la variable)(prototipo);
```

Veamos algunos ejemplos:

```c
int (*a)(int, float);
void (*b)(void);
```

Generalmente, los punteros a funciones se usan en la programación de bajo nivel, tales como:

* Modificación de interrupciones.
* Creación de controladores de dispositivos, etc.



## 6.7. El modificador de almacenamiento static aplicado a funciones.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Al igual que en el caso de las variables globales, es posible aplicar delante de una función el modificador de almacenamiento *static*. Dicho modificador hace que la función sobre la que se aplica sea local al módulo donde se encuentra, y no pueda ser conocida por los restantes módulos del programa, de igual forma a como sucedía con las variables globales. Esta modificación del alcance de una función permite realizar un mejor encapsulado del código y simplificar la programación en proyectos de gran envergadura.

## Tema 7 - Estructuras, campos de bit, uniones y

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

**enumeraciones.**

## 7.1. Estructuras.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)





Una **estructura** es un conjunto de variables que se referencian bajo el mismo nombre. La sintaxis de la declaración de una estructura en lenguaje C es:

```c
struct nombre_estructura {
    tipo nombre_variable;    
    tipo nombre_variable;    
    ...
    tipo nombre_variable; 
} variables_estructura;
```

Es posible no poner el nombre de la estructura (`nombre_estructura`), o bien, no crear en el momento de declarar la estructura ninguna variable de la estructura (`variables_estructura`), pero no es posible eliminar la aparición de ambos elementos. Veamos algunos ejemplos de declaración de estructuras:

```c
struct LISTA {
    int tam;
    char cadena[50];
} var_lista;

struct DATO {
    int tam;
    float vector[3];
    struct DATO *siguiente;
};

struct {
    float a, b;
    unsigned long i, j;
    char cadena[5];
} memo[10];

struct ALFA {
    int a;
    float b;
};

struct BETA {
    struct ALFA alfa;
    float c, d;
} variable;
```

Para referenciar un elemento de una estructura se realiza de la siguiente forma:

```c
variables_estructura.nombre_variable;
```

Así, podíamos referenciar los elementos de las estructuras anteriores de la siguiente forma:

```c
var_lista.tam;
var_lista.cadena;
var_lista.cadena[7];
memo[2].a;
memo[6].cadena[3];
variable.alfa.a;
variable.c;
```

### Paso de estructuras como parámetros a funciones

Un aspecto que es necesario aclarar es el **paso de estructuras** como parámetros a las funciones. A una función es posible pasarle:

* Un elemento de los que componen la estructura.
* Una estructura entera.
* Un array de estructuras.

En caso de pasarle un **elemento de la estructura**, el paso se hace siguiendo las reglas del tipo del cual sea ese elemento. En el caso de una **estructura entera**, C la pasa, a no ser que se le indique lo contrario, por valor. Y en el caso de un **array de estructuras**, como todo array, lo pasará por "referencia".

Conviene aclarar en este momento que si la estructura posee en su interior un **array de elementos**, la estructura puede ser pasada por valor a una función, pero el array será pasado siempre por referencia. En concreto, a la función se le pasará por valor un puntero al primer elemento del array.

Veamos todo esto en un ejemplo:

```c
struct ALFA {
    int a;
    char b[20];
};

void PasoDeElementos(int val, char *cadena) {
    val = 15;
    cadena[7] = 'a';
}

void PasoDeLaEstructuraPorValor(struct ALFA a) {
    a.val = 14;
    a.cadena[6] = 'b';
}

void PasoDeLaEstructuraPorReferencia(struct ALFA *a) {
    *(a->val) = 13;
    *(a->cadena)[5] = 'c';
}

void PasoDeUnArrayDeEstructuras(struct ALFA *a) {
    a[4].val = 12;
    a[5].cadena[4] = 'd';
}

int main(void) {
    struct ALFA a, b[10];
    PasoDeElementos(a.val, a.b);
    PasoDeLaEstructuraPorValor(a);
    PasoDeLaEstructuraPorReferencia(&a);
    PasoDeUnArrayDeEstructuras(b);

    return 0;
}
```

En el paso de una estructura por **referencia**, se ha usado una construcción `*(variable_estructura.nombre_variable)`. Esta construcción asigna el valor que se desea a esa variable de la estructura, pues `variable_estructura.nombre_variable` es un puntero a la variable. El uso de los paréntesis es necesario, pues el operador `.` tiene menor prioridad que el operador `*`.

Es por ello que C introduce un nuevo operador, el operador `->`. Este operador es equivalente al otro, pero más cómodo y fácil de escribir y de usar. Entonces, podríamos haber escrito la función de paso de una estructura por referencia de la forma siguiente:

```c
void PasoDeLaEstructuraPorReferencia(struct ALFA *a) {
    a->val = 13;
    a->cadena[5] = 'c';
}
```




## 7.2. Campos de bit.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Un **campo de bit** es un método predefinido por C para poder acceder a un bit de un byte. Aunque dicho acceso siempre es posible mediante operaciones con los operadores sobre bits, explicados con anterioridad, el uso de campos de bit puede añadir claridad al programa.

El método de declaración de un **campo de bit** se basa en la estructura, pues un campo de bit no es más que un tipo especial de estructura. El formato de declaración de un campo de bit es:

```c
struct nombre_campo_bit {
    tipo nombre1 : longitud;
    tipo nombre2 : longitud;
    ...
    tipo nombreN : longitud;
} variables_campo_bit;
```

El **tipo** de un campo de bit debe declararse como `unsigned int` o `signed int`. Veamos un ejemplo de declaración de un campo de bit:

```c
struct ALFA {
    unsigned a : 1;
    signed b : 2;
    unsigned : 4;   // Campo de bit sin nombre
    unsigned c : 1;
} campo;
```

En dicho ejemplo, se declara un campo de bit de tamaño 4 al cual no se le da nombre. Eso es válido, y su efecto es que esos cuatro bits no podrían ser referenciados.

Es posible mezclar en la declaración elementos normales de estructura con elementos de campo de bit. Veamos un ejemplo:

```c
struct EMP {
    char nombre[20], apellido[2][20];
    float sueldo;
    unsigned vacaciones : 1;
    unsigned enfermo : 1;
};
```



## 7.3. Uniones.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


En C, una **unión** es una posición de memoria que se usa por varias variables similares, que pueden ser de tipos diferentes. La definición de una unión es:

```c
union nombre_union {
    tipo nombre1;
    tipo nombre2;
    ...
    tipo nombreN;
} var_union;
```

Como puede observarse, su declaración es parecida a la de una estructura. Sin embargo, en una unión, todos los tipos de datos comparten la misma dirección de memoria. Así, si declaramos:

```c
union ALFA {
    int a;
    char b;
} alfa;
```

Tendremos:

```
<------alfa.a------>  
Byte0    Byte1 <-alfa.b->
```

Por lo tanto, `b` tendrá en común con `a` el byte más bajo. Un ejemplo más útil de una unión es el siguiente:

```c
union BETA {
    unsigned short a;
    char b[2];
} beta;
```

Entonces, `beta.b[0]` contendrá el byte bajo de `beta.a`, y `beta.b[1]` contendrá el byte alto de `beta.a`. Ello permite acceder a la parte alta o baja de dicho `unsigned short` sin necesidad de usar operadores sobre bits.



## 7.4.Enumeraciones.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)



Una **enumeración** es un conjunto de constantes enteras con nombre que especifica todos los valores legales que pueden tener unas variables. Las enumeraciones se declaran de la siguiente forma:

```c
enum nombre_enum {
    lista_de_enumeración
} lista_de_variables;
```

Donde, al igual que en las estructuras, puede no aparecer `nombre_enum` o `lista_de_variables`. Veamos un ejemplo de enumeración:

```c
enum MONEDAS {
    peseta, duro, diez, cinco, cincuenta, cien, doscientas, quinientas
} monedas_espana;
```

Las enumeraciones asignan una constante entera a cada uno de los símbolos de la enumeración, empezando por el valor `0`. Esto puede modificarse colocando en la declaración el valor que deseamos tengan los elementos a partir de uno dado. Esto se realiza de la siguiente forma:

```c
enum CURSO {
    primero, segundo, tercero, cuarto_t = 100, quinto_t, cuarto_e = 200, quinto_e
};
```

En este caso, las constantes `primero`, `segundo` y `tercero` tienen los valores `0`, `1` y `2`, las constantes `cuarto_t` y `quinto_t` los valores `100` y `101`, y las constantes `cuarto_e` y `quinto_e` los valores `200` y `201`, respectivamente.



## 7.5.La palabra reservada typedef.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


El lenguaje C permite, mediante el uso de la palabra reservada `typedef`, definir nuevos nombres para los tipos de datos existentes. Esto no debe confundirse con la creación de un nuevo tipo de datos. La palabra clave `typedef` permite solo asignarle un nuevo nombre a un tipo de datos ya existente. La sintaxis general de uso de `typedef` es:

```c
typedef tipo nombre;
```

Donde `tipo` es cualquier tipo de datos permitido, y `nombre` es el nuevo nombre que se desea que tenga ese tipo. Veamos algunos ejemplos:

```c
typedef int entero;

typedef struct {
    unsigned codigo;
    char nombre[40];
    char apellido[40];
} cliente;
```

Y entonces podrían crearse nuevas variables de la forma:

```c
entero a;
cliente b, *c;
```



## Tema 8 - El preprocesador.

 [![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

En un programa escrito en C, es posible incluir diversas instrucciones para el compilador dentro del código fuente del programa. Estas instrucciones dadas al compilador son llamadas directivas del preprocesador y, aunque realmente no son parte del lenguaje C, expanden el ámbito del entorno de programación de C.

El preprocesador, definido por el standard ANSI de C, contiene las siguientes directivas:



|#if|#ifdef|#ifndef|#else|
| - | - | - | - |
|#elif|#endif|#include|#define|
|#undef|#line|#error|#pragma|

*Tabla 9.1: Directivas del preprocesador en C.*


## 8.1. Directiva `#define`.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La directiva `#define` se usa para definir un identificador y una cadena que el compilador sustituirá por el identificador cada vez que se encuentre en el archivo fuente. El estándar ANSI llama al identificador "nombre de macro" y al proceso de sustitución "sustitución de macro". Por ejemplo:

```c
#define TRUE 1
#define FALSE 0
```

El compilador, cada vez que vea el identificador `TRUE`, lo sustituirá por el valor `1`, e igual con `FALSE`.
El uso más común de la directiva `#define` es la definición de valores constantes en el programa, tamaños de arrays, etc.

Una característica que posee la directiva `#define` es que el "nombre de macro" puede contener argumentos.
Cada vez que el compilador encuentra el "nombre de macro", los argumentos reales encontrados en el programa reemplazan los argumentos asociados con el nombre de macro.
Veamos un ejemplo:

```c
#define MIN(a,b) (a<b) ? a : b
```

Si tenemos ahora en el programa:

```c
printf("El valor mínimo es: %d\n", MIN(10,20));
```

El compilador sustituye el "nombre de macro" y sus argumentos en tiempo de compilación, y ello equivale a haber escrito el código:

```c
printf("El valor mínimo es: %d\n", (10<20) ? 10 : 20);
```

---

## 8.2. Directiva `#undef`.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La directiva `#undef` permite quitar una definición de "nombre de macro" que se realizó con anterioridad.
Veamos un ejemplo:

```c
#define TAM 10
...
#undef TAM
```

A partir de `#undef TAM`, el "nombre de macro" `TAM` deja de existir.
Esto permite localizar los "nombres de macro" donde sea necesario.

---

## 8.3. Directiva `#error`.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La directiva `#error` fuerza a parar la compilación del programa, a la vez que muestra un mensaje de error.
El mensaje de error no aparecerá entre comillas dobles.
Veamos un ejemplo:

```c
#error Detenida compilación
```

Su principal uso viene asociado a detener la compilación en ciertas condiciones en asociación con las directivas `#if`, etc., explicadas con posterioridad.

---

## 8.4. Directiva `#include`.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La directiva `#include` fuerza al compilador a incluir otro archivo fuente en el archivo que tiene la directiva `#include`, y a compilarlo.
El nombre del archivo fuente a incluir se colocará entre comillas dobles o entre paréntesis de ángulo.
Por ejemplo:

```c
#include <stdio.h>
#include "stdio.h"
```

Los archivos incluidos mediante `#include` pueden a su vez poseer otras directivas `#include`.

La diferencia existente entre encerrar el archivo entre paréntesis de ángulo o entre comillas dobles es que:

* En el primer caso (`<archivo>`), se busca el archivo en los directorios de la línea de órdenes de compilación y después en los directorios estándar de C, **pero nunca** en el directorio de trabajo.
* En el segundo caso (`"archivo"`), el primer sitio donde se busca el archivo a incluir es en el **directorio actual de trabajo**, pasándose, en caso de no haber sido encontrado, a buscar en los mismos sitios que en el caso anterior.


## 8.5. Directivas `#if`, `#ifdef`, `#ifndef`, `#else`, `#elif`, `#endif`.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Las directivas `#if`, `#ifdef`, `#ifndef`, `#else`, `#elif` y `#endif` son directivas condicionales de compilación. Estas directivas permiten decirle al compilador qué partes del programa debe compilar bajo distintas condiciones.

La idea general de la directiva `#if` es que si es verdadera la expresión que se encuentra después del `#if`, se compilará el código que figura entre el `#if` y el `#endif`.
La directiva `#else` funciona de igual forma que el `else` del lenguaje C.
La directiva `#elif` funciona como un escalonado de `if`.
La definición formal es:

```c
#if expresión1
    secuencia de sentencias
#elif expresión2
    secuencia de sentencias
...
#else
    secuencia de sentencias
#endif
```

Veamos algunos ejemplos:

```c
#define MEM 200

#if MEM > 100
    printf("MEM es mayor de 100");
#endif
```

```c
#define VALOR 0

#if VALOR == 0
    c = a * b / (VALOR + 1);
#else
    c = a * b / VALOR;
#endif
```

Compilará el código para el caso de `VALOR == 0`.

```c
#define VALOR 15

#if VALOR < 0
    b = b / (-VALOR);
#elif VALOR == 0
    b = b / (VALOR + 1);
#else
    b = b / VALOR;
#endif
```

Compilará el código para el último caso.

Las directivas `#ifdef` y `#ifndef` se usan también para compilación condicional, solo que no evalúan expresión alguna, únicamente comprueban si está definido (`#ifdef`) o si no está definido (`#ifndef`) algún nombre de macro.
Su sintaxis general es:

```c
#ifdef nombre_de_macro
    secuencia de sentencias
#else
    secuencia de sentencias
#endif
```

E igual para `#ifndef`. Veamos algunos ejemplos:

```c
#define VAL 10

#ifdef VAL
    printf("VAL definido");
#else
    printf("VAL no definido");
#endif
```

```c
#ifndef NOVAL
    printf("NOVAL no definido");
#endif
```

Compilará el código para el caso de `VAL` definido y, además, compilará el código de `NOVAL`, al no estar definida dicha macro.
Como se observa, no se comprueba el valor de `VAL` o de `NOVAL`, solo se comprueba si están definidos o no.

---

## 8.6. Directiva `#line`.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La directiva `#line` permite cambiar la cuenta de líneas del compilador y el nombre del archivo.
Su sintaxis es:

```c
#line número ["nombre de archivo"]
```

Veamos un ejemplo:

```c
#line 100 /* Inicializa el contador de líneas a 100 */
/* 10 líneas */
#error Detenida compilación
```

Indicará el mensaje de error en la línea *110* del programa, y no en la que suceda realmente.

---

## 8.7. Directiva `#pragma`.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La directiva `#pragma` es una directiva que permite dar instrucciones al compilador sobre cómo debe realizar la compilación del código fuente.
Su sintaxis es:

```c
#pragma nombre
```


## Tema 9 - Entrada y salida.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Antes de empezar a explicar la entrada y salida en C, es necesario realizar dos pequeños comentarios:

En primer lugar, para el correcto funcionamiento de la entrada y salida en C, y dado que las funciones de E/S, estructuras de datos usadas por esas funciones, etc., se encuentran declaradas en el archivo de cabecera `<stdio.h>`, es necesario incluir dicho archivo mediante la directiva del preprocesador `#include`, para que la E/S funcione correctamente. En caso contrario, puede funcionar de forma incorrecta, e incluso, puede llegar a dar errores de compilación.

En segundo lugar, aparte de la E/S por consola y la E/S de fichero mediante búfer intermedio, que serán explicadas en este tema, existe una E/S de fichero sin búfer intermedio, proveniente de la primitiva implementación de C en máquinas UNIX, y que el estándar ANSI de C no ha estandarizado, por lo cual no es recomendable su uso. Por este motivo, y dada su similitud en la mayoría de apartados con el sistema de E/S de fichero mediante búfer intermedio, no será explicada en el presente tema.

---

## 9.1. Entrada y salida desde consola.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La entrada y salida desde consola se refiere a las operaciones que se producen en el teclado y la pantalla del ordenador. Dichos dispositivos son automáticamente abiertos y cerrados al comenzar y terminar el programa, por lo cual no deben ser abiertos ni cerrados por el propio programa.

Existen, básicamente, seis funciones de entrada y salida desde consola: tres de entrada y tres de salida. Veámoslas:

---

### `getchar()`

La función `getchar()` lee un carácter desde el teclado. Su definición es:

```c
int getchar(void);
```

Esta función lee caracteres, de uno en uno, desde el teclado, esperando la pulsación de un retorno de carro. Es posible escribir varios caracteres antes de que se lea alguno. Hace eco en pantalla del carácter leído. En caso de error, devuelve `EOF`.

---

### `putchar()`

La función `putchar()` escribe un carácter en pantalla. Su definición es:

```c
int putchar(int c);
```

Devuelve el carácter escrito si la operación fue correcta. En caso de error, devuelve `EOF`.

**Ejemplo de uso de `getchar()` y `putchar()`:**

```c
#include <stdio.h>

int main(void) {
    char ch;
    do {
        ch = getchar();
        putchar(ch);
    } while (ch != 'e' && ch != 'E');

    return 0;
}
```

Este programa lee todas las teclas pulsadas hasta encontrar una `'e'` o una `'E'`.

---

### `gets()`

La función `gets()` lee una cadena desde el teclado. Su definición es:

```c
char *gets(char *s);
```

Lee hasta que se pulsa retorno de carro. El retorno de carro es reemplazado automáticamente por el carácter de fin de cadena (`'\0'`). Devuelve un puntero a `s` si tiene éxito, o `NULL` en caso de error.

---

### `puts()`

La función `puts()` escribe una cadena en pantalla. Su definición es:

```c
int puts(const char *s);
```

Escribe la cadena seguida de un retorno de carro. Devuelve un entero no negativo en caso de éxito, o `EOF` si ocurre un error.

**Ejemplo de uso de `gets()` y `puts()`:**

```c
#include <stdio.h>
#define TAM 100

int main(void) {
    char cadena[TAM];

    puts("Introduce una cadena:");
    gets(cadena);

    return 0;
}
```

---

### `scanf()`

La función `scanf()` se usa para leer datos desde el teclado y convertirlos automáticamente al formato adecuado. Su definición es:

```c
int scanf(const char *formato[, dirección, ...]);
```

La cadena de formato puede incluir:

* **Especificadores de formato** (precedidos por `%`),
* **Espacios en blanco**,
* **Otros caracteres literales**.

**Especificadores válidos:**

| Especificador | Descripción                           |
| :-----------: | ------------------------------------- |
|      `%c`     | Leer un único carácter                |
|      `%d`     | Leer un entero decimal                |
|      `%i`     | Leer un entero decimal                |
|      `%e`     | Leer número en punto flotante         |
|      `%f`     | Leer número en punto flotante         |
|      `%g`     | Leer número en punto flotante         |
|      `%o`     | Leer número octal                     |
|      `%s`     | Leer cadena de caracteres             |
|      `%x`     | Leer número hexadecimal               |
|      `%p`     | Leer un puntero                       |
|      `%n`     | Recibe el número de caracteres leídos |
|      `%u`     | Leer entero sin signo                 |

*Tabla 9.1.1: Especificadores de formato de la función scanf().*

**Modificadores:**

* `h`: *short int* o *unsigned short int*
* `l`: *long int* o *unsigned long int*, y también *double* para `%f`, `%e`, `%g`
* `L`: *long double* para `%f`, `%e`, `%g`

**Nota:** Los argumentos deben pasarse por referencia (dirección de memoria).

**Uso del modificador `*`:**

```c
int x, y;
scanf("%d%*c%d", &x, &y);
```

Si la entrada es `10/20`, `x = 10`, se descarta `/`, y `y = 20`.

`scanf()` devuelve el número de campos asignados correctamente. Devuelve `EOF` en caso de error.

---

### `printf()`

La función `printf()` se usa para escribir cualquier tipo de dato en pantalla. Su definición es:

```c
int printf(const char *formato[, argumento, ...]);
```

La cadena de formato contiene:

* Texto literal,
* Especificadores de formato, iniciados por `%`.

**Especificadores válidos:**

| Especificador | Descripción                                                 |
| :-----------: | ----------------------------------------------------------- |
|      `%c`     | Carácter                                                    |
|      `%d`     | Entero con signo                                            |
|      `%i`     | Entero con signo                                            |
|      `%e`     | Punto flotante (notación científica, 'e')                   |
|      `%E`     | Punto flotante (notación científica, 'E')                   |
|      `%f`     | Punto flotante                                              |
|      `%g`     | Más corto entre `%e` y `%f`                                 |
|      `%G`     | Más corto entre `%E` y `%f`                                 |
|      `%o`     | Octal sin signo                                             |
|      `%s`     | Cadena de caracteres                                        |
|      `%u`     | Entero sin signo                                            |
|      `%x`     | Hexadecimal sin signo (minúsculas)                          |
|      `%X`     | Hexadecimal sin signo (mayúsculas)                          |
|      `%p`     | Dirección de puntero                                        |
|      `%n`     | Puntero a entero que recibe cantidad de caracteres impresos |
|      `%%`     | Imprime el símbolo `%`                                      |

*Tabla 9.1.2: Especificadores de formato de la función printf().*

Igual que con `scanf()`, se pueden usar los modificadores `h`, `l`, y `L`.

`printf()` devuelve el número de caracteres escritos o `EOF` en caso de error.

**Ejemplo de uso de `scanf()` y `printf()`:**

```c
#include <stdio.h>

int main(void) {
    int a, b;

    printf("\nIntroduce el valor de a: ");
    scanf("%d", &a);
    
    printf("\nIntroduce el valor de b: ");
    scanf("%d", &b);

    if (b != 0)
        printf("\nEl valor de %d dividido %d es: %f\n", a, b, (float)a / b);
    else
        printf("\nError, b vale 0\n");

    return 0;
}
```



## 9.2. Entrada y salida desde fichero.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


### Entrada y salida desde ficheros en C

Antes de explicar la entrada y salida desde fichero, conviene entender el tipo de dato `FILE *`. Este tipo representa un **puntero de fichero**, que en realidad es una estructura que contiene información como:

* Nombre del fichero abierto
* Modo de apertura (lectura, escritura, etc.)
* Estado del archivo, entre otros

Este puntero especifica el archivo que se está usando, permitiendo a las funciones de entrada/salida saber sobre qué archivo actuar.

---

### Apertura y cierre de archivos

Antes de usar un archivo, es **necesario abrirlo**, y tras su uso, **cerrarlo**. Esto se hace mediante las funciones `fopen()` y `fclose()`:

#### `FILE *fopen(char *nombre, char *modo);`

* `nombre`: nombre del archivo
* `modo`: modo de apertura

#### Modos de apertura:

| **Modo** | **Descripción**                               |
| -------- | --------------------------------------------- |
| r        | Abrir archivo para lectura                    |
| w        | Crear archivo para escritura                  |
| a        | Abrir archivo para añadir                     |
| rb       | Abrir archivo binario para lectura            |
| wb       | Crear archivo binario para escritura          |
| ab       | Abrir archivo binario para añadir             |
| rt       | Abrir archivo de texto para lectura           |
| wt       | Crear archivo de texto para escritura         |
| at       | Abrir archivo de texto para añadir            |
| r+       | Abrir archivo para lectura/escritura          |
| w+       | Crear archivo para lectura/escritura          |
| a+       | Abrir archivo para leer/añadir                |
| r+b      | Abrir archivo binario para lectura/escritura  |
| w+b      | Crear archivo binario para lectura/escritura  |
| a+b      | Abrir archivo binario para leer/añadir        |
| r+t      | Abrir archivo de texto para lectura/escritura |
| w+t      | Crear archivo de texto para lectura/escritura |
| a+t      | Abrir archivo de texto para leer/añadir       |

> **Nota**: Si no se especifica binario o texto, dependerá del sistema. Generalmente se abre en modo texto.

#### Diferencias entre modo texto y binario:

* En modo **texto**, las secuencias como `\r\n` se convierten a `\n` al leer.
* En modo **binario**, no hay conversiones. Se mantiene la información original.

#### Comprobación de apertura:

```c
FILE *fp;
if ((fp = fopen("prueba", "w")) == NULL) {
    puts("\nNo puedo abrir el fichero\n");
    exit(1);
}
```

---

#### `int fclose(FILE *fp);`

Cierra el archivo, liberando:

* El **buffer** (guardando datos si es necesario)

* El **control de archivo**, permitiendo abrir otros archivos

* Devuelve `0` si se cerró correctamente.

* Devuelve otro valor en caso de error.

---

### Ejemplo de `fopen()` y `fclose()`:

```c
#include <stdio.h>

int main(int argc, char *argv[]) {
    FILE *fp;

    if (argc != 2) {
        puts("Nombre del fichero no pasado");
        return 0;
    }

    if ((fp = fopen(argv[1], "r")) == NULL) {
        printf("Error abriendo el fichero: %s\n", argv[1]);
        return 0;
    }

    if (fclose(fp)) {
        puts("Error cerrando el fichero");
        return 1;
    }

    return 0;
}
```

---

### Principales funciones de lectura/escritura:

```c
int getc(FILE *fp);
int putc(int ch, FILE *fp);
char *fgets(char *str, int n, FILE *fp);
int fputs(const char *str, FILE *fp);
int fscanf(FILE *fp, const char *formato [, dirección, ...]);
int fprintf(FILE *fp, const char *formato [, argumento, ...]);
int fread(void *memoria, int num, int cont, FILE *fp);
int fwrite(void *memoria, int num, int cont, FILE *fp);
```

#### Descripciones:

* **`getc()`**: Lee un carácter. Devuelve `EOF` al final del archivo.
* **`putc()`**: Escribe un carácter. Devuelve `EOF` en caso de error.
* **`fgets()`**: Lee hasta `n-1` caracteres o hasta salto de línea. Conserva el `\n`.
* **`fputs()`**: Escribe una cadena, sin añadir salto de línea.
* **`fscanf()` / `fprintf()`**: Lectura/escritura con formato, como `scanf()` y `printf()`.

---

### `fread()` y `fwrite()` (bloques de datos)

```c
int fread(void *memoria, int num, int cont, FILE *fp);
int fwrite(void *memoria, int num, int cont, FILE *fp);
```

* `memoria`: puntero a buffer de lectura/escritura
* `num`: tamaño de cada bloque
* `cont`: número de bloques
* `fp`: archivo asociado

> Devuelven el número de **bloques** leídos/escritos, no bytes.

> No realizan conversiones de texto → se usan para archivos binarios.

#### Ejemplo de uso:

```c
#include <stdio.h>
#define TAM 1000

int main(int argc, char *argv[]) {
    FILE *f_inp, *f_out;
    char buffer[TAM];
    int num;

    if (argc != 3) return 0;

    if ((f_inp = fopen(argv[1], "rb")) == NULL) return 0;
    if ((f_out = fopen(argv[2], "wb")) == NULL) exit(1);

    while ((num = fread(buffer, sizeof(char), TAM, f_inp)) != 0)
        fwrite(buffer, sizeof(char), num, f_out);

    if (fclose(f_inp) || fclose(f_out))
        exit(1);

    return 0;
}
```

---

### Funciones adicionales

#### `int ferror(FILE *fp);`

* Devuelve 0 si no hay error, distinto de 0 si lo hubo.

#### `void rewind(FILE *fp);`

* Posiciona el puntero de archivo al **inicio**.

#### `int fseek(FILE *fp, long num, int origen);`

* Mueve el puntero de archivo.
* `num`: desplazamiento
* `origen`: posición base

| **Origen**           | **Constante** | **Valor** |
| -------------------- | ------------- | --------- |
| Comienzo del archivo | SEEK\_SET     | 0         |
| Posición actual      | SEEK\_CUR     | 1         |
| Final del archivo    | SEEK\_END     | 2         |

> **Nota**: Solo funciona correctamente en archivos **binarios**, no en modo texto.

#### Ejemplo de `fseek()`:

```c
#include <stdio.h>

int LeeCaracter(FILE *fp, long pos, int origen) {
    if (fseek(fp, pos, origen))
        return EOF;
    return getc(fp);
}
```

---

### Archivos estándar

Se abren automáticamente al iniciar el programa:

* **`stdin`** → entrada estándar (teclado)
* **`stdout`** → salida estándar (pantalla)
* **`stderr`** → salida de error estándar

Son de tipo `FILE *`, por lo que se pueden usar con funciones de fichero.

#### Ejemplo:

```c
char cadena[100];
fgets(cadena, 100, stdin);    // Leer desde teclado
fputs(cadena, stderr);        // Escribir en salida de error
```


## Tema 10 - Asignación dinámica de memoria.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Antes de empezar con el desarrollo del tema, es necesario aclarar que el mismo no pretende explicar las estructuras de datos dinámicas, sino tan solo dar unas ligeras nociones básicas sobre la posibilidad de asignar memoria de forma dinámica, esto es, en tiempo de ejecución, y por tanto de crear nuevas variables.

Las funciones que realizan un manejo activo de la memoria del sistema requieren todas ellas para su correcto funcionamiento la inclusión, mediante la directiva del prepocesador **#include** del archivo de cabecera **<stdlib.h>**.


## 10.1. Reserva dinámica de memoria

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

En C, la **reserva dinámica de memoria** se realiza mediante funciones específicas. Aunque existen varias (ver Apéndice A), aquí se explicará únicamente el uso de la función `*malloc()*`.

La declaración de `malloc()` es:

```c
void *malloc(unsigned num_bytes);
```

Donde `num_bytes` es el número de bytes que se desean reservar. La función devuelve un puntero de tipo `void *` (sin tipo), que debe convertirse explícitamente al tipo de puntero deseado mediante *casting*. Por ejemplo:

```c
int *a;
a = (int *)malloc(sizeof(int));
*a = 3;
```

Si no se puede reservar la memoria (por falta de recursos, por ejemplo), `malloc()` devuelve `NULL`. Por tanto, siempre debe comprobarse su valor antes de utilizarlo. Ejemplos:

```c
float *a;
a = (float *)malloc(sizeof(float));
if (a == NULL) exit(0); // Salimos del programa

unsigned long int *b;
if ((b = (unsigned long int *)malloc(sizeof(unsigned long int))) == NULL)
    exit(0); // Salimos del programa

struct ALFA {
    unsigned a;
    float b;
    int *c;
} *d;

if ((d = (struct ALFA *)malloc(sizeof(struct ALFA))) == NULL)
    exit(0); // Salimos del programa
```

---

## 10.2. Liberación dinámica de memoria

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

La memoria reservada dinámicamente se libera automáticamente al finalizar el programa. Sin embargo, puede ser necesario liberarla antes, durante la ejecución. Para ello se usa la función `free()`:

```c
void free(void *p);
```

Donde `p` es el puntero cuya memoria asociada se desea liberar. Ejemplo:

```c
int *a;
if ((a = (int *)malloc(sizeof(int))) == NULL)
    exit(0);

// ...

free(a);
```

> ⚠️ El puntero pasado a `free()` **no debe ser NULL**, ya que esto puede causar errores en tiempo de ejecución. Por eso es tan importante comprobar siempre el retorno de `malloc()`.

---

## 10.3. Ejemplo de asignación y liberación dinámica de memoria

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Vamos a implementar una lista ligada (linked list) de forma dinámica. Primero definimos la estructura:

```c
struct LISTA {
    tipo dato;
    struct LISTA *sig;
};
```

Donde `tipo` puede ser cualquier tipo válido en C (`int`, `float`, etc.).

Variables necesarias:

```c
struct LISTA *cabeza = NULL, *p;
tipo dato;
```

### Función para insertar un elemento por la cabeza:

```c
struct LISTA *CrearLista(struct LISTA *cabeza, tipo dato) {
    struct LISTA *p;
    if ((p = (struct LISTA *)malloc(sizeof(struct LISTA))) == NULL)
        exit(0); // Salimos del programa

    p->dato = dato;
    p->sig = cabeza;
    return p;
}
```

Llamada:

```c
cabeza = CrearLista(cabeza, dato);
```

---

### Función para buscar un elemento:

```c
struct LISTA *BuscarLista(struct LISTA *p, tipo dato) {
    while (p != NULL && p->dato != dato)
        p = p->sig;
    return p;
}
```

Llamada:

```c
if ((p = BuscarLista(cabeza, dato)) != NULL)
    // El elemento ha sido encontrado
```

---

### Función para liberar un nodo de la lista:

```c
struct LISTA *LiberarLista(struct LISTA *cabeza, tipo dato) {
    struct LISTA *p = cabeza, *q = NULL;

    if (p != NULL) {
        if (p->dato == dato) {
            cabeza = p->sig;
            free(p);
        } else {
            while (p != NULL && p->dato != dato) {
                q = p;
                p = p->sig;
            }

            if (p != NULL) {
                q->sig = p->sig;
                free(p);
            }
        }
    }
    return cabeza;
}
```

Llamada:

```c
cabeza = LiberarLista(cabeza, dato);
```


## Apéndice A - Funciones de biblioteca del estándar ANSI de C

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)


⚠️ A tener en cuenta lo siguiente:

* Existen **muchas más funciones** que las aquí descritas.
* Sin embargo, este conjunto representa una base **suficientemente amplia** para realizar todas las operaciones básicas necesarias.
* Las funciones están **clasificadas según su propósito** (entrada/salida, manipulación de memoria, etc.) para facilitar su consulta y uso.

### Estructura de presentación de cada función

Cada función se presenta con la siguiente información:

* **Nombre de la función:**
  *fclose*

* **Fichero de inclusión (`#include`) donde se encuentra su prototipo:**
  `#include <stdio.h>`

* **Formato de la función (prototipo):**
  `int fclose(FILE *f);`

* **Descripción breve de la función:**
  Cierra un archivo previamente abierto. Libera los recursos asociados y asegura que toda la información pendiente se haya escrito correctamente.
  
---

## A.1 Funciones de entrada y salida de datos

[![ÍNDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

---

### `fclose`

```c
#include <stdio.h>
int fclose(FILE *f);
```

Cierra el archivo asociado a `f` y vuelca su buffer al disco. Devuelve 0 si tuvo éxito, y distinto de cero en caso de error.

---

### `feof`

```c
#include <stdio.h>
int feof(FILE *f);
```

Comprueba si se alcanzó el final del archivo. Devuelve un valor distinto de cero si es así, 0 en caso contrario.

---

### `ferror`

```c
#include <stdio.h>
int ferror(FILE *f);
```

Detecta errores en operaciones sobre el archivo. Devuelve 0 si no hay errores, valor distinto de cero si existen errores.

---

### `fflush`

```c
#include <stdio.h>
int fflush(FILE *f);
```

Vuelca el contenido del buffer al archivo (si es de salida) o lo vacía (si es de entrada). Devuelve 0 si tuvo éxito.

---

### `fgetc`

```c
#include <stdio.h>
int fgetc(FILE *f);
```

Lee un carácter del archivo y lo devuelve como `int`.

---

### `fgets`

```c
#include <stdio.h>
char *fgets(char *cad, int num, FILE *f);
```

Lee hasta `num-1` caracteres o hasta nueva línea/EOF. Devuelve `cad` si tuvo éxito, o `NULL` si hay error.

---

### `fopen`

```c
#include <stdio.h>
FILE *fopen(const char *nombre, const char *modo);
```

Abre un archivo y devuelve un puntero a `FILE`. Si falla, devuelve `NULL`.

#### Modos de apertura:

| Modo | Descripción                     |
| ---- | ------------------------------- |
| r    | Lectura                         |
| w    | Escritura (crea nuevo)          |
| a    | Añadir                          |
| rb   | Binario - lectura               |
| wb   | Binario - escritura             |
| ab   | Binario - añadir                |
| r+   | Lectura/escritura               |
| w+   | Crear y leer/escribir           |
| a+   | Leer/añadir                     |
| r+b  | Binario lectura/escritura       |
| w+b  | Crear binario lectura/escritura |
| a+b  | Leer/añadir binario             |
| rt   | Texto lectura                   |
| wt   | Texto escritura                 |
| at   | Texto añadir                    |

---

### `fprintf`

```c
#include <stdio.h>
int fprintf(FILE *f, const char *formato, ...);
```

Escribe en el archivo `f` según el formato especificado. Devuelve número de caracteres escritos, o negativo en error.

---

### `fputc`

```c
#include <stdio.h>
int fputc(int c, FILE *f);
```

Escribe un carácter en el archivo. Devuelve `c` o `EOF` si falla.

---

### `fputs`

```c
#include <stdio.h>
int fputs(const char *cad, FILE *f);
```

Escribe la cadena `cad` en el archivo. No escribe el carácter nulo final.

---

### `fread`

```c
#include <stdio.h>
int fread(void *buf, size_t tam, size_t cuenta, FILE *f);
```

Lee `cuenta` elementos de `tam` bytes y los almacena en `buf`. Devuelve el número de elementos realmente leídos.

---

### `fscanf`

```c
#include <stdio.h>
int fscanf(FILE *f, const char *formato, ...);
```

Lee desde el archivo como `scanf()` lo hace desde teclado.

---

### `fseek`

```c
#include <stdio.h>
int fseek(FILE *f, long desp, int origen);
```

Mueve el cursor del archivo. `origen` puede ser:

| Origen               | Constante  | Valor |
| -------------------- | ---------- | ----- |
| Comienzo del archivo | `SEEK_SET` | 0     |
| Posición actual      | `SEEK_CUR` | 1     |
| Final del archivo    | `SEEK_END` | 2     |

---

### `ftell`

```c
#include <stdio.h>
long ftell(FILE *f);
```

Devuelve la posición actual del cursor en el archivo. Devuelve `-1L` en caso de error.

---

### `fwrite`

```c
#include <stdio.h>
int fwrite(const void *buf, size_t tam, size_t cuenta, FILE *f);
```

Escribe `cuenta` elementos de `tam` bytes desde `buf` en el archivo.

---

### `getc`

```c
#include <stdio.h>
int getc(FILE *f);
```

Lee el siguiente carácter del archivo. Devuelve `EOF` al final del archivo.

---

### `gets` (obsoleta/no recomendada)

```c
#include <stdio.h>
char *gets(char *cad);
```

Lee una línea desde `stdin` sin límite de longitud. Puede causar desbordamientos de buffer.

---

### `perror`

```c
#include <stdio.h>
int perror(const char *cad);
```

Muestra el mensaje de error asociado al valor de `errno`, precedido por `cad`.

---

### `printf`

```c
#include <stdio.h>
int printf(const char *formato, ...);
```

Imprime datos en `stdout` (pantalla). Devuelve número de caracteres escritos, o valor negativo en error.

#### Especificadores de formato:

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

| Código | Significado                  |
| ------ | ---------------------------- |
| %c     | Carácter                     |
| %d/%i  | Entero con signo             |
| %e/%E  | Notación científica          |
| %f     | Punto flotante               |
| %g/%G  | Más corto entre `%e` y `%f`  |
| %o     | Octal sin signo              |
| %s     | Cadena de caracteres         |
| %u     | Entero sin signo             |
| %x/%X  | Hexadecimal sin signo        |
| %p     | Puntero                      |
| %n     | Escribe número de caracteres |
| %%     | Imprime el símbolo `%`       |

Modificadores: `h` (short), `l` (long), `L` (long double)

---

### `putc`

```c
#include <stdio.h>
int putc(int c, FILE *f);
```

Escribe un carácter en el archivo. Devuelve el carácter escrito o `EOF`.

---

### `puts`

```c
#include <stdio.h>
int puts(char *cad);
```

Escribe la cadena `cad` en `stdout`, seguido de un salto de línea.

---

### `rewind`

```c
#include <stdio.h>
void rewind(FILE *f);
```

Reposiciona el archivo al inicio y limpia indicadores de error y EOF.

---

### `scanf`

```c
#include <stdio.h>
int scanf(const char *formato, ...);
```

Lee desde `stdin` según el formato especificado. Similar a `printf()`, pero para entrada.

#### Especificadores de formato:

| Código   | Descripción                 |
| -------- | --------------------------- |
| %c       | Carácter                    |
| %d/%i    | Entero decimal              |
| %e/%f/%g | Punto flotante              |
| %o       | Octal                       |
| %x       | Hexadecimal                 |
| %s       | Cadena de caracteres        |
| %u       | Entero sin signo            |
| %p       | Puntero                     |
| %n       | Número de caracteres leídos |



## A.2 - Funciones de caracteres (`<ctype.h>`)

[![ÍNDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

### `isalnum`

```c
#include <ctype.h>
int isalnum(int ch);
```

Devuelve un valor distinto de cero si `ch` es una letra del alfabeto o un dígito. En caso contrario, devuelve cero.

---

### `isalpha`

```c
#include <ctype.h>
int isalpha(int ch);
```

Devuelve un valor distinto de cero si `ch` es una letra del alfabeto. En cualquier otro caso, devuelve cero.

---

### `iscntrl`

```c
#include <ctype.h>
int iscntrl(int ch);
```

Devuelve un valor distinto de cero si `ch` está entre `0` y `0x1F` o si es igual a `0x7F` (tecla DEL). En cualquier otro caso, devuelve cero.

---

### `isdigit`

```c
#include <ctype.h>
int isdigit(int ch);
```

Devuelve un valor distinto de cero si `ch` es un dígito (`0..9`). En cualquier otro caso, devuelve cero.

---

### `isgraph`

```c
#include <ctype.h>
int isgraph(int ch);
```

Devuelve un valor distinto de cero si `ch` es un carácter imprimible distinto del espacio. En caso contrario, devuelve cero.

---

### `islower`

```c
#include <ctype.h>
int islower(int ch);
```

Devuelve un valor distinto de cero si `ch` es una letra minúscula. En cualquier otro caso, devuelve cero.

---

### `isprint`

```c
#include <ctype.h>
int isprint(int ch);
```

Devuelve un valor distinto de cero si `ch` es un carácter imprimible, incluyendo el espacio. En cualquier otro caso, devuelve cero.

---

### `ispunct`

```c
#include <ctype.h>
int ispunct(int ch);
```

Devuelve un valor distinto de cero si `ch` es un carácter de puntuación (excluye el espacio). En cualquier otro caso, devuelve cero.

---

### `isspace`

```c
#include <ctype.h>
int isspace(int ch);
```

Devuelve un valor distinto de cero si `ch` es un espacio, tabulador o carácter de salto de línea. En cualquier otro caso, devuelve cero.

---

### `isupper`

```c
#include <ctype.h>
int isupper(int ch);
```

Devuelve un valor distinto de cero si `ch` es una letra mayúscula. En cualquier otro caso, devuelve cero.

---

### `isxdigit`

```c
#include <ctype.h>
int isxdigit(int ch);
```

Devuelve un valor distinto de cero si `ch` es un dígito hexadecimal (`0..9`, `A..F`, `a..f`). En cualquier otro caso, devuelve cero.

---

### `tolower`

```c
#include <ctype.h>
int tolower(int ch);
```

Convierte `ch` a minúscula si es una letra mayúscula. Si no, devuelve `ch` sin modificar.

---

### `toupper`

```c
#include <ctype.h>
int toupper(int ch);
```

Convierte `ch` a mayúscula si es una letra minúscula. Si no, devuelve `ch` sin modificar.

---

## A.3 - Funciones de cadenas (`<string.h>`)

[![ÍNDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

### `memchr`

```c
#include <string.h>
void *memchr(const void *buffer, int ch, size_t cuenta);
```

Busca la primera ocurrencia de `ch` en los primeros `cuenta` bytes de `buffer`. Devuelve un puntero a la ocurrencia o `NULL` si no se encuentra.

---

### `memcmp`

```c
#include <string.h>
int memcmp(const void *buf1, const void *buf2, size_t cuenta);
```

Compara los primeros `cuenta` bytes de `buf1` y `buf2`. Devuelve:

| Valor devuelto | Descripción                |
| -------------- | -------------------------- |
| `< 0`          | `buf1` es menor que `buf2` |
| `0`            | `buf1` es igual a `buf2`   |
| `> 0`          | `buf1` es mayor que `buf2` |

*Tabla A.3.1: Interpretación del valor devuelto por `memcmp()`*

---

### `memcpy`

```c
#include <string.h>
void *memcpy(void *hacia, const void *desde, size_t cuenta);
```

Copia `cuenta` bytes desde `desde` hacia `hacia`. Si se solapan, el comportamiento es indefinido. Devuelve `hacia`.

---

### `memset`

```c
#include <string.h>
void *memset(void *buf, int ch, size_t cuenta);
```

Copia el byte menos significativo de `ch` en los primeros `cuenta` bytes de `buf`. Devuelve `buf`.

---

### `strcat`

```c
#include <string.h>
char *strcat(char *cad1, const char *cad2);
```

Concatena `cad2` al final de `cad1`. Devuelve `cad1`.

---

### `strchr`

```c
#include <string.h>
char *strchr(char *cad, int ch);
```

Devuelve un puntero a la primera ocurrencia de `ch` en `cad`, o `NULL` si no se encuentra.

---

### `strcmp`

```c
#include <string.h>
int strcmp(const char *cad1, const char *cad2);
```

Compara lexicográficamente `cad1` y `cad2`. Devuelve:

| Valor devuelto | Descripción      |
| -------------- | ---------------- |
| `< 0`          | `cad1` < `cad2`  |
| `0`            | `cad1` == `cad2` |
| `> 0`          | `cad1` > `cad2`  |

*Tabla A.3.2: Interpretación del valor devuelto por `strcmp()`*

---

### `strcpy`

```c
#include <string.h>
char *strcpy(char *cad1, const char *cad2);
```

Copia `cad2` en `cad1`. Devuelve `cad1`.

---

### `strlen`

```c
#include <string.h>
unsigned int strlen(char *cad);
```

Devuelve el número de caracteres de `cad`, sin contar el carácter nulo de fin.

---

### `strtok`

```c
#include <string.h>
char *strtok(char *cad1, const char *cad2);
```

Devuelve un puntero a la siguiente palabra de `cad1`, utilizando los caracteres de `cad2` como delimitadores. La primera llamada usa `cad1`, las siguientes `NULL`. Modifica `cad1`.



## A.4 - Funciones matemáticas

[![ÍNDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

```c
#include <math.h>
double acos(double arg);
```

Devuelve el arcocoseno de `arg`. El argumento debe estar en el rango de -1 a 1. En caso contrario, se produce un error de dominio.

---

```c
double asin(double arg);
```

Devuelve el arcoseno de `arg`, con las mismas restricciones que `acos()`.

---

```c
double atan(double arg);
```

Devuelve el arcotangente de `arg`.

---

```c
double atan2(double y, double x);
```

Devuelve el arcotangente de `y/x`, considerando los signos de los argumentos para determinar el cuadrante.

---

```c
double ceil(double num);
```

Devuelve el menor entero mayor o igual a `num`. Ej.: `ceil(1.02)` → `2.0`, `ceil(-1.02)` → `-1.0`.

---

```c
double cos(double arg);
```

Devuelve el coseno de `arg` (en radianes).

---

```c
double cosh(double arg);
```

Devuelve el coseno hiperbólico de `arg`.

---

```c
double exp(double arg);
```

Devuelve `e` elevado a `arg`.

---

```c
double fabs(double num);
```

Devuelve el valor absoluto de `num`.

---

```c
double floor(double num);
```

Devuelve el mayor entero menor o igual que `num`. Ej.: `floor(1.02)` → `1.0`, `floor(-1.02)` → `-2.0`.

---

```c
double fmod(double x, double y);
```

Devuelve el resto de la división `x/y`.

---

```c
double log(double num);
```

Devuelve el logaritmo neperiano de `num`. Error de dominio si `num` es negativo. Error de rango si es cero.

---

```c
double log10(double num);
```

Devuelve el logaritmo en base 10 de `num`.

---

```c
double pow(double base, double exp);
```

Devuelve `base` elevado a `exp`. Puede generar errores si `base` es 0 y `exp <= 0`, o si `base < 0` y `exp` no es entero.

---

```c
double sin(double arg);
```

Devuelve el seno de `arg` (en radianes).

---

```c
double sinh(double arg);
```

Devuelve el seno hiperbólico de `arg`.

---

```c
double sqrt(double num);
```

Devuelve la raíz cuadrada de `num`. Error de dominio si `num` es negativo.

---

```c
double tan(double arg);
```

Devuelve la tangente de `arg` (en radianes).

---

```c
double tanh(double arg);
```

Devuelve la tangente hiperbólica de `arg`.

---

## A.5 - Asignación dinámica de memoria

[![ÍNDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

```c
#include <stdlib.h>
void *calloc(size_t num, size_t tam);
```

Asigna memoria para un array de `num` elementos de tamaño `tam`, inicializados a cero. Devuelve un puntero al inicio de la memoria asignada o `NULL` si falla.

---

```c
void free(void *ptr);
```

Libera la memoria apuntada por `ptr`, previamente reservada con `malloc()`, `calloc()` o `realloc()`.

---

```c
void *malloc(size_t tam);
```

Asigna `tam` bytes de memoria sin inicializar. Devuelve un puntero al bloque asignado o `NULL` si no hay memoria suficiente.

---

```c
void *realloc(void *ptr, size_t tam);
```

Redimensiona el bloque de memoria apuntado por `ptr` a `tam` bytes. Si es necesario, mueve el bloque a otra dirección y copia su contenido.

* Si `ptr` es `NULL`, se comporta como `malloc(tam)`.
* Si `tam` es cero, libera la memoria.
* Devuelve `NULL` si no hay suficiente memoria; el bloque original permanece intacto.




## A.6 - Funciones varias

[![ÍNDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

---

```c
#include <stdlib.h>
int abs(int num);
```

Devuelve el valor absoluto del entero `num`.

---

```c
double atof(const char *cad);
```

Convierte la cadena apuntada por `cad` a un número `double`. La cadena debe representar un número en coma flotante válido. Si no lo es, el resultado es indefinido.

> Ejemplo: `atof("100.00HOLA")` → `100.00`.

---

```c
int atoi(const char *cad);
```

Convierte la cadena apuntada por `cad` a un número entero (`int`). Si la cadena no representa un número válido, el resultado es indefinido (la mayoría de implementaciones devuelven `0`).

> Ejemplo: `atoi("123.23")` → `123`.

---

```c
long int atol(const char *cad);
```

Convierte la cadena apuntada por `cad` a un número `long int`. Funciona como `atoi()`.

---

```c
void exit(int estado);
```

Finaliza inmediatamente el programa.

* Si `estado` es `0`, indica una terminación normal.
* Un valor distinto puede señalar un error.

---

```c
long labs(long num);
```

Devuelve el valor absoluto de `num`.

---

```c
int system(const char *cad);
```

Ejecuta la cadena `cad` como un comando del sistema operativo.

* Si `cad` es `NULL`, devuelve distinto de cero si existe un intérprete de comandos.
* Si `cad` no es `NULL`, devuelve `0` si el comando fue exitoso; en otro caso, un valor distinto de cero.

---

## Apéndice B: Ejemplos de programas en C

[![ÍNDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Este apéndice incluye algunos programas de ejemplo en lenguaje C. Son compatibles con compiladores para MS-DOS y UNIX sin modificaciones.

---

### B.1 `palindro.c`

**Descripción:** Programa que determina si una palabra es palíndroma (se lee igual de izquierda a derecha que de derecha a izquierda).

```c
#include <stdio.h>
#include <string.h>

#define TAM 100

// Rutina que calcula si una palabra es palíndroma.
// Parámetros:
//   char *cadena: puntero al string con la palabra.
// Retorno:
//   int: 0 si no es palíndroma, distinto de 0 si lo es.
int Palindroma(char *cadena) {
    register int i, j;
    i = 0;
    j = strlen(cadena) - 1;
    while (i < j && cadena[i] == cadena[j]) {
        i++;
        j--;
    }
    return (i >= j);
}

int main(void) {
    char cadena[TAM];

    printf("\nIntroduce la palabra:\n");
    gets(cadena);

    printf("La palabra: %s %s palíndroma.\n",
           cadena,
           (Palindroma(cadena)) ? "es" : "no es");

    return 0;
}
```

⚠️ **Nota:** El uso de `gets()` no es seguro y está obsoleto. Se recomienda usar `fgets()`.

---


## B.2 `matriz.c`

[![ÍNDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

**Descripción:** Programa que calcula el producto de dos matrices.

```c
#include <stdio.h>

#define TAM 10  // Tamaño máximo de las matrices
#define OK 0    // Código de éxito
#define ERROR 1 // Código de error

// Estructura para representar una matriz
struct MATRIZ {
    unsigned fila, columna;
    float matriz[TAM][TAM];
};

// Función que muestra el menú y solicita una opción
char Menu(void) {
    register char d;
    printf("\nElige la opción deseada:\n");
    printf("\t0 -- Salir del programa.\n");
    printf("\t1 -- Cambiar la matriz A.\n");
    printf("\t2 -- Cambiar la matriz B.\n");
    printf("\t3 -- Calcular A*B\n");
    printf("\t4 -- Calcular B*A\n");
    while ((d = getchar()) < '0' || d > '4');
    return d;
}

// Función que pide el número de filas o columnas de una matriz
unsigned PedirTamano(const char *cadena) {
    unsigned valor;
    do {
        printf("%s", cadena);
        scanf("%u", &valor);
    } while (valor == 0 || valor > TAM);
    return valor;
}

// Función que cambia los valores de una matriz
void PedirMatriz(struct MATRIZ *a) {
    register unsigned i, j;
    float valor;
    a->fila = PedirTamano("\nNúmero de filas de la matriz: ");
    a->columna = PedirTamano("\nNúmero de columnas de la matriz: \n");

    for (i = 0; i < a->fila; i++)
        for (j = 0; j < a->columna; j++) {
            printf("M[%u][%u]: ", i, j);
            scanf("%f", &valor);
            a->matriz[i][j] = valor;
        }
}

// Función que multiplica dos matrices
int Multiplicar(const struct MATRIZ *a, const struct MATRIZ *b, struct MATRIZ *res) {
    register unsigned i, j, k;

    if (a->columna != b->fila) return ERROR;

    res->fila = a->fila;
    res->columna = b->columna;

    for (i = 0; i < a->fila; i++)
        for (j = 0; j < b->columna; j++) {
            res->matriz[i][j] = 0;
            for (k = 0; k < a->columna; k++) {
                res->matriz[i][j] += a->matriz[i][k] * b->matriz[k][j];
            }
        }
    return OK;
}

// Función que muestra el resultado de la operación de multiplicación
void Mostrar(const struct MATRIZ *res) {
    register unsigned i, j;
    for (i = 0; i < res->fila; i++) {
        for (j = 0; j < res->columna; j++) {
            printf("Res[%u][%u]= %f\n", i, j, res->matriz[i][j]);
        }
        printf("\nPulsa Enter para continuar.\n");
        getchar();
    }
}

int main(void) {
    struct MATRIZ a, b, res;
    char d;

    // Inicialización de matrices
    a.fila = a.columna = b.fila = b.columna = 1;
    a.matriz[0][0] = b.matriz[0][0] = 1.0;

    do {
        switch (d = Menu()) {
            case '0': break;
            case '1': PedirMatriz(&a); break;
            case '2': PedirMatriz(&b); break;
            case '3':
                if (Multiplicar(&a, &b, &res) == ERROR)
                    printf("\nNo es posible multiplicar A*B\n");
                else
                    Mostrar(&res);
                break;
            case '4':
                if (Multiplicar(&b, &a, &res) == ERROR)
                    printf("\nNo es posible multiplicar B*A\n");
                else
                    Mostrar(&res);
                break;
        }
    } while (d != '0');
    return 0;
}
```

---

## B.3 `ordenar.c`

[![ÍNDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

**Descripción:** Programa que ordena un archivo de cualquier tamaño usando el algoritmo **QuickSort**. El archivo contiene un número **unsigned** como primer elemento, seguido de los elementos a ordenar.

```c
#include <stdio.h>
#include <stdlib.h>

// Función que lee un archivo de datos y devuelve un puntero al array de la memoria reservada
float *LeerFichero(const char *nombre, unsigned *num) {
    FILE *fp;
    float *p;
    register unsigned i;

    if ((fp = fopen(nombre, "rt")) == NULL) {
        printf("\nError, no puedo abrir el fichero: %s\n", nombre);
        return NULL;
    }

    fscanf(fp, "%u\n", num);

    if ((p = (float *)calloc(*num, sizeof(float))) == NULL) {
        printf("\nError, memoria insuficiente.\n");
        fclose(fp);
        return NULL;
    }

    for (i = 0; i < *num; i++)
        fscanf(fp, "%f\n", &p[i]);

    fclose(fp);
    return p;
}

// Función que guarda los datos ordenados en un archivo
void GuardarFichero(const char *nombre, const unsigned num, const float *p) {
    FILE *fp;
    register unsigned i;

    if ((fp = fopen(nombre, "wt")) == NULL) {
        printf("\nError, no puedo crear el fichero: %s\n", nombre);
        return;
    }

    fprintf(fp, "%u\n", num);
    for (i = 0; i < num; i++)
        fprintf(fp, "%f\n", p[i]);

    fclose(fp);
}

// Función que ordena un array usando el algoritmo QuickSort
void QuickSort(float *p, unsigned izq, unsigned der) {
    register unsigned i = izq, j = der;
    float val, inter;

    val = p[(i + j) / 2];

    do {
        while (p[i] < val) i++;
        while (p[j] > val) j--;

        if (i <= j) {
            inter = p[i];
            p[i] = p[j];
            p[j] = inter;
            i++;
            j--;
        }
    } while (i <= j);

    if (izq < j) QuickSort(p, izq, j);
    if (i < der) QuickSort(p, i, der);
}

// Función principal
int main(int argc, char *argv[]) {
    float *p;
    unsigned num;

    if (argc != 3) {
        printf("\nModo de uso: %s <fichero1> <fichero2>\n", argv[0]);
        return 1;
    }

    if ((p = LeerFichero(argv[1], &num)) == NULL)
        return 1;

    QuickSort(p, 0, num - 1);
    GuardarFichero(argv[2], num, p);

    free(p);
    return 0;
}
```


## B.4 fichero.c.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

```c
/* Programa que maneja una pequeña base de datos directamente sobre el fichero */

#include <stdio.h>
#include <string.h>

/* Definicion de las constantes del programa */
#define TAM 30
#define TAM_BUFFER 10

/* Definicion de los codigos de error */
#define OK 0
#define ERROR 1

/* Definicion de las estructuras de datos del programa */
struct FICHA {
    unsigned long dni;
    char nombre[TAM];
    char apellido[2][TAM];
};

/* Rutina que muestra un menu en pantalla.
Parametros: Ninguno.
Return: char Opcion elegida. */
char Menu(void) {
    register char d;
    printf("\nElige una opcion:\n");
    printf("\t0 -- Salir del programa.\n");
    printf("\t1 -- Insertar un nuevo elemento.\n");
    printf("\t2 -- Buscar un elemento por su dni.\n");
    printf("\t3 -- Buscar un elemento por su apellido.\n");
    while ((d = getchar()) < '0' || d > '3');
    return d;
}

/* Rutina que muestra un elemento en pantalla.
Parametros: struct FICHA *ficha Puntero a la estructura con los datos a mostrar.
Return: Ninguno. */
void Mostrar(const struct FICHA *ficha) {
    printf("\n\nDNI: %lu\n", ficha->dni);
    printf("NOMBRE: %s\n", ficha->nombre);
    printf("PRIMER APELLIDO: %s\n", ficha->apellido[0]);
    printf("SEGUNDO APELLIDO: %s\n", ficha->apellido[1]);
    printf("\nPulsa Enter para continuar\n");
    getchar();
}

/* Rutina que busca un elemento dado su dni.
Parametros: FILE *fichero Puntero al fichero de trabajo.
           unsigned long dni Numero de dni a buscar.
           char opcion Opcion de ejecucion, 1 mostrar, 0 no mostrar.
Return: int Codigo de error. */
int BuscarDni(FILE *fichero, const unsigned long dni, const char opcion) {
    struct FICHA ficha;
    fseek(fichero, 0L, SEEK_SET);
    while (fread(&ficha, sizeof(struct FICHA), 1, fichero) == 1)
        if (dni == ficha.dni) {
            if (opcion) Mostrar(&ficha);
            return OK;
        }
    return ERROR;
}

/* Rutina que busca por apellidos.
Parametros: FILE *fichero Puntero al fichero de trabajo.
           char *apellido Apellido a buscar.
Return: int Codigo de error. */
int BuscarApellido(FILE *fichero, char *apellido) {
    struct FICHA ficha;
    char encontrado = 0;
    fseek(fichero, 0L, SEEK_SET);
    while (fread(&ficha, sizeof(struct FICHA), 1, fichero) == 1)
        if (!strcmp(apellido, ficha.apellido[0]) || !strcmp(apellido, ficha.apellido[1])) {
            Mostrar(&ficha);
            encontrado = 1;
        }
    return (encontrado) ? OK : ERROR;
}

/* Rutina que inserta un nuevo elemento en el fichero.
Parametros: FILE *fichero Puntero al fichero de trabajo.
           struct FICHA *ficha Puntero a la ficha a insertar.
Return: int Codigo de error. */
int Insertar(FILE *fichero, const struct FICHA *ficha) {
    if (BuscarDni(fichero, ficha->dni, 0) != ERROR)
        return ERROR;
    fseek(fichero, 0L, SEEK_END);
    fwrite(ficha, sizeof(struct FICHA), 1, fichero);
    return OK;
}

/* Rutina que pide los datos de una ficha.
Parametros: struct FICHA *ficha Puntero a la ficha que contendra los datos.
           char opcion Opcion de ejecucion (0..2).
Return: struct FICHA * Puntero a la ficha que contiene los datos. */
struct FICHA *PedirDatos(struct FICHA *ficha, const char opcion) {
    switch(opcion) {
        case 0:
            printf("\nDNI: ");
            scanf("%lu", &ficha->dni);
            fflush(stdin);
            break;
        case 1:
            fflush(stdin);
            printf("APELLIDO: ");
            strupr(gets(ficha->apellido[1]));
            break;
        case 2:
            printf("\nDNI: ");
            scanf("%lu", &ficha->dni);
            fflush(stdin);
            printf("NOMBRE: ");
            strupr(gets(ficha->nombre));
            printf("PRIMER APELLIDO: ");
            strupr(gets(ficha->apellido[0]));
            printf("SEGUNDO APELLIDO: ");
            strupr(gets(ficha->apellido[1]));
            break;
    }
    return ficha;
}

int main(int argc, char *argv[]) {
    FILE *fichero;
    struct FICHA ficha;
    register char d;

    if (argc != 2) {
        printf("\nModo de uso: %s <fichero>\n", argv[0]);
        return 1;
    }

    if ((fichero = fopen(argv[1], "a+b")) == NULL) {
        printf("\nError creando el fichero: %s\n", argv[1]);
        return 1;
    }

    if (setvbuf(fichero, NULL, _IOFBF, TAM_BUFFER * sizeof(struct FICHA)) != 0) {
        printf("\nError creando el buffer para %d elementos.\n", TAM_BUFFER);
        fclose(fichero);
        return 1;
    }

    do {
        switch(d = Menu()) {
            case '0': break;
            case '1':
                if (Insertar(fichero, PedirDatos(&ficha, 2)) == ERROR)
                    printf("\nNumero de dni duplicado.\n");
                break;
            case '2':
                PedirDatos(&ficha, 0);
                if (BuscarDni(fichero, ficha.dni, 1) == ERROR)
                    printf("\nDni no existente.\n");
                break;
            case '3':
                PedirDatos(&ficha, 1);
                if (BuscarApellido(fichero, ficha.apellido[1]) == ERROR)
                    printf("\nApellido inexistente.\n");
                break;
        }
    } while (d != '0');

    fclose(fichero);
    return 0;
}
```



## B.5 - arbol.c.

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

```c

/* Programa que lee las palabras de un fichero y las almacena en un arbol binario */

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>

/* Definicion de la longitud maxima de una palabra */
#define TAM 30

/* Definicion de las estructuras de datos del programa */
struct ARBOL {
    char pal[TAM + 1];
    struct ARBOL *izq, *der;
};

/* Rutina que lee una palabra del fichero.
Parametros: 
    FILE *fichero Puntero al fichero de donde se leen las palabras.
    char *cadena Array de caracteres donde almacenar las palabras.
Return: 
    char * Puntero a la cadena con la palabra leida, NULL si error. */
char *LeerPalabra(FILE *fichero, char *cadena) {
    register char d, i = 0;

    while ((d = fgetc(fichero)) != EOF && !isalpha(d));

    if (d == EOF)
        return NULL;

    do
        cadena[i++] = d;
    while (i < TAM && (isalpha(d = fgetc(fichero)) || isdigit(d) || d == '_'));

    cadena[i] = '\0';

    return cadena;
}

/* Rutina que crea el arbol binario, leyendo para ello el fichero. 
Parametros: 
    char *nombre Nombre del fichero a leer.
Return: 
    struct ARBOL * Puntero a la raiz del arbol creado, NULL si error. */
struct ARBOL *LeerFichero(char *nombre) {
    FILE *fichero;
    char cadena[TAM + 1], insertado;
    int val;
    struct ARBOL *cab = NULL, *p, *q;

    if ((fichero = fopen(nombre, "rt")) == NULL) {
        printf("\nError, no puedo leer el fichero: %s\n", nombre);
        return NULL;
    }

    while (LeerPalabra(fichero, cadena) != NULL) {
        if ((q = (struct ARBOL *)malloc(sizeof(struct ARBOL))) == NULL) {
            printf("\nError reservando memoria.\n");
            fclose(fichero);
            return NULL;
        }

        strcpy(q->pal, cadena);
        q->izq = q->der = NULL;

        if (cab == NULL)
            cab = q;
        else {
            p = cab;
            insertado = 0;

            while (!insertado)
                if ((val = strcmp(cadena, p->pal)) < 0)
                    if (p->izq == NULL) {
                        p->izq = q;
                        insertado = 1;
                    } else
                        p = p->izq;
                else if (val > 0)
                    if (p->der == NULL) {
                        p->der = q;
                        insertado = 1;
                    } else
                        p = p->der;
                else
                    insertado = 1;
        }
    }

    fclose(fichero);
    return cab;
}

/* Rutina que muestra por pantalla el arbol ordenado a la vez que libera la memoria.
Parametros: 
    struct ARBOL *p Puntero al nodo a mostrar.
    unsigned *cont Puntero al contador de elementos para permitir parar la visualizacion.
Return: 
    Ninguno. */
void Mostrar(struct ARBOL *p, unsigned *cont) {
    if (p->izq != NULL)
        Mostrar(p->izq, cont);

    puts(p->pal);

    if (++*cont > 21) {
        *cont = 1;
        printf("\nPulsa Enter para continuar.\n");
        getchar();
    }

    if (p->der != NULL)
        Mostrar(p->der, cont);

    free(p);
}

int main(int argc, char *argv[]) {
    struct ARBOL *p;
    unsigned cont = 1;

    if (argc != 2) {
        printf("\nModo de uso: %s <fichero>\n", argv[0]);
        return 1;
    }

    if ((p = LeerFichero(argv[1])) == NULL)
        return 1;

    printf("\n\n\n\n\n\n");
    Mostrar(p, &cont);

    return 0;
}
```




## 🔍 **Uso de Valgrind para Depuración de Memoria en C**

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

Valgrind es una herramienta esencial para detectar **errores de memoria** (leaks, accesos inválidos, etc.) en programas C. Su uso es especialmente crítico en proyectos como los de 42, donde la gestión manual de memoria es frecuente.

### 📌 **Instalación (Linux/macOS)**
```bash
# Ubuntu/Debian
sudo apt install valgrind

# macOS (via Homebrew)
brew install valgrind
```

### 🔥 **Comando Básico**
```bash
valgrind --leak-check=full ./tu_programa argumentos
```

### 🛠️ **Flags Recomendados para Máxima Detección**
| Flag | Descripción |
|------|-------------|
| `--leak-check=full` | Detalla el origen de *todos* los memory leaks |
| `--show-leak-kinds=all` | Muestra leaks definitivos, indirectos y posibles |
| `--track-origins=yes` | Rastrea orígenes de valores no inicializados |
| `--trace-children=yes` | Analiza procesos hijos (útil si usas `fork()` o `system()`) |
| `--error-exitcode=1` | Retorna error si hay problemas (ideal para CI/CD) |

[![INDICE](https://img.shields.io/badge/%20<<%20I%20n%20d%20i%20c%20e%20-84ff38)](https://github.com/fran-byte/Learn-C/blob/main/readme.md#-programando-en-c---material-did%C3%A1ctico)

### 🎯 **Ejemplo Práctico**
Supongamos que tu programa `so_long` tiene un memory leak:
```bash
valgrind --leak-check=full --show-leak-kinds=all ./so_long map.ber
```
**Salida típica:**
```
==12345== 40 bytes in 1 blocks are definitely lost in loss record 1 of 2
==12345==    at 0x483877F: malloc (vg_replace_malloc.c:307)
==12345==    by 0x109234: crear_mapa (mapa.c:15)
==12345==    by 0x109567: main (main.c:28)
```
- **Interpretación**: 40 bytes perdidos en `mapa.c`, línea 15. ¡Debes liberarlos con `free()`!

### 📝 **Errores Comunes que Detecta**
| Error | Causa | Solución |
|-------|-------|----------|
| **Definitely lost** | Memoria nunca liberada | Añade `free()` donde corresponda |
| **Invalid read/write** | Acceso a memoria liberada o fuera de límites | Verifica índices y punteros |
| **Use of uninitialized values** | Variables no inicializadas | Inicializa siempre las variables |

### 🚨 **Supresión de Falsos Positivos (Ej: MiniLibX)**
Crea un archivo `mlx.supp`:
```xml
{
   <MLX_False_Positives>
   Memcheck:Leak
   ...
   fun:mlx_init
   ...
}
```
Y úsalo con:
```bash
valgrind --suppressions=mlx.supp ./tu_programa
```

